<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Wala-Mujib Digital Twin</title>

  <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    * { box-sizing: border-box; }

    body { margin: 0; overflow: hidden; font-family: 'Roboto','Segoe UI',sans-serif; background:#0b0c10; }

    #sidebar{
      position:absolute; top:0; left:0; width:380px; height:100vh;
      background:#1f2833; color:#c5c6c7; z-index:10;
      box-shadow:4px 0 10px rgba(0,0,0,0.5); display:flex; flex-direction:column;
    }

    #header{ padding:20px; background:#0b0c10; border-bottom:2px solid #66fcf1; }
    h1{ margin:0; color:#66fcf1; font-size:22px; letter-spacing:1px; }
    h2{ margin:5px 0 0; font-size:14px; color:#888; font-weight:normal; }

    #statusLine{
      margin-top:10px; padding:8px 10px; border:1px solid rgba(102,252,241,0.35);
      border-radius:6px; background:rgba(31,40,51,0.6);
      font-size:12px; color:#c5c6c7; line-height:1.4;
    }
    .ok{ color:#66fcf1; }
    .warn{ color:#ffcc80; }
    .bad{ color:#ff8a80; }

    .catalogue-container{ flex:1; overflow-y:auto; padding:10px; }

    .category-btn{
      background:#45a29e; color:white; cursor:pointer; padding:12px; width:100%;
      text-align:left; border:none; outline:none; transition:0.4s;
      font-weight:bold; margin-top:5px; border-radius:4px; display:flex; justify-content:space-between;
    }
    .category-btn:after{ content:'+'; font-weight:bold; float:right; }
    .category-btn.active{ background:#66fcf1; color:#0b0c10; }
    .category-btn.active:after{ content:'-'; }

    .analysis-btn{
      background:#1f4068; border:1px solid #66fcf1; color:#66fcf1;
      margin-top:15px; text-align:center; justify-content:center; transition:0.3s;
    }
    .analysis-btn:hover{ background:#66fcf1; color:#0b0c10; cursor:pointer; }
    .analysis-btn:after{ content:''; }

    .layer-panel{
      padding:0 10px; background:#28303b; max-height:0; overflow:hidden;
      transition:max-height 0.2s ease-out; margin-bottom:5px; border-radius:0 0 4px 4px;
    }

    .layer-item{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 0; border-bottom:1px solid #333; font-size:13px;
    }
    .layer-info{ display:flex; align-items:center; gap:10px; }

    .icon-box{ width:12px; height:12px; border:1px solid #fff; display:inline-block; }
    .icon-line{ width:20px; height:3px; display:inline-block; }
    .icon-dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    input[type=checkbox]{ transform:scale(1.2); cursor:pointer; accent-color:#66fcf1; }

    /* ===== Chart panel layout (fixed) ===== */
    #chartPanel{
      height:360px;
      background:#0b0c10;
      border-top:2px solid #45a29e;
      padding:10px;
      display:none;
      position:relative;

      overflow-y:auto;      /* ‚úÖ allow scroll */
      overflow-x:hidden;
      scroll-behavior:smooth;
    }

    #chartHeader{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding-bottom:10px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      margin-bottom:10px;
    }

    #controlsRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex: 1 1 auto;
      flex-wrap:wrap;
      min-width:0;
    }

    select.dtSelect{
      padding:8px;
      background:#1f2833;
      color:white;
      border:1px solid #45a29e;
      border-radius:6px;
      font-weight:bold;
      flex: 1 1 140px;
      min-width:140px;
      max-width:100%;
    }

    #closeChartBtn{
      padding:8px 12px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.25);
      background:#222;
      color:#fff;
      cursor:pointer;
      font-weight:bold;
      flex:0 0 auto;
      white-space:nowrap;
    }
    #closeChartBtn:hover{ background:#333; }

    #swatChart{
      width:100% !important;
      height: calc(360px - 10px - 10px - 62px) !important;
    }

    #legendPanel{
      position:absolute; bottom:30px; right:30px; width:300px;
      background:rgba(11,12,16,0.85); padding:15px; border-radius:8px;
      color:white; display:none; z-index:50; border:1px solid #66fcf1;
      font-family:sans-serif;
    }
    .gradient-bar{
      height:15px; width:100%; margin:8px 0; border-radius:3px;
      background:linear-gradient(to right, #ccc, #81D4FA, #29B6F6, #0277BD, #0D47A1);
    }
    .legend-labels{ display:flex; justify-content:space-between; font-size:11px; color:#ccc; }

    /* ===== Right-side asset details panel ===== */
    #assetPanel{
      position:absolute;
      top:20px;
      right:20px;
      width:360px;
      max-width: calc(100% - 420px); /* keep clear of left sidebar */
      max-height: calc(100vh - 40px);
      background: rgba(11,12,16,0.92);
      border:1px solid rgba(102,252,241,0.55);
      border-radius:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.55);
      color:#e6e6e6;
      z-index:80;
      display:none;
      overflow:hidden;
      backdrop-filter: blur(6px);
    }
    #assetPanelHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      background: rgba(31,40,51,0.55);
    }
    #assetPanelTitle{
      font-weight:800;
      color:#66fcf1;
      font-size:14px;
      line-height:1.25;
      word-break:break-word;
    }
    #assetPanelSubtitle{
      margin-top:4px;
      font-size:12px;
      color:#aab;
      line-height:1.25;
      word-break:break-word;
    }
    #assetPanelClose{
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.25);
      color:#fff;
      border-radius:8px;
      padding:6px 10px;
      cursor:pointer;
      font-weight:bold;
      flex:0 0 auto;
    }
    #assetPanelClose:hover{ background: rgba(255,255,255,0.08); }

    #assetPanelBody{
      padding:12px;
      overflow:auto;
      max-height: calc(100vh - 40px - 56px);
    }
    .assetBadges{ display:flex; flex-wrap:wrap; gap:8px; margin:10px 0 12px; }
    .assetBadge{
      font-size:11px; padding:5px 8px; border-radius:999px;
      border:1px solid rgba(102,252,241,0.35);
      background: rgba(31,40,51,0.55);
      color:#cfe;
      white-space:nowrap;
    }
    .assetActions{ display:flex; gap:8px; flex-wrap:wrap; margin:0 0 12px; }
    .assetBtn{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(102,252,241,0.45);
      background: rgba(69,162,158,0.15);
      color:#66fcf1;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
    }
    .assetBtn:hover{ background: rgba(102,252,241,0.18); }
    .kvGrid{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 10px; }
    .kv{
      background: rgba(31,40,51,0.45);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      padding:10px;
      min-width:0;
    }
    .kv .k{ font-size:11px; color:#9aa; margin-bottom:4px; }
    .kv .v{ font-size:13px; color:#fff; word-break:break-word; }
    .assetSectionTitle{
      margin:14px 0 8px;
      font-size:12px;
      color:#c5c6c7;
      text-transform:uppercase;
      letter-spacing:0.08em;
    }
    details.assetDetails{
      margin-top:12px;
      background: rgba(31,40,51,0.35);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      padding:8px 10px;
    }
    details.assetDetails summary{
      cursor:pointer;
      color:#66fcf1;
      font-weight:700;
      font-size:12px;
      outline:none;
    }
    pre.assetJson{
      white-space:pre-wrap;
      word-break:break-word;
      font-size:11px;
      color:#ddd;
      margin:10px 0 0;
    }
    @media (max-width: 1100px){
      #assetPanel{ width: 320px; }
    }

    #cesiumContainer{ width:100%; height:100vh; margin-left:380px; width:calc(100% - 380px); }
  </style>
</head>

<body>
  <div id="sidebar">
    <div id="header">
      <h1>Wala-Mujib Twin</h1>
      <h2>Eco-Hydrological Decision Support</h2>
      <div id="statusLine">
        <div>Subbasins layer: <span id="subStatus" class="warn">loading‚Ä¶</span></div>
        <div>Scenarios JSON: <span id="jsonStatus" class="warn">loading‚Ä¶</span></div>
        <div>Hover: <span id="hoverStatus" class="warn">none</span></div>
        <div>Click: <span id="clickStatus" class="warn">none</span></div>
      </div>
    </div>

    <div class="catalogue-container">
      <button class="category-btn analysis-btn" onclick="toggleHeatmap()">üó∫Ô∏è Smart Map (Metric / Decision)</button>

      <button class="category-btn active">üåä Water Resources</button>
      <div class="layer-panel" style="max-height: 520px;">
        <div class="layer-item">
          <div class="layer-info">
            <div class="icon-box" style="border:1px dashed gold;"></div>
            SWAT Sub-Basins (23) (Clickable)
          </div>
          <input type="checkbox" checked onchange="toggleLayer('subbasins', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info"><div class="icon-box" style="border-color:orange;"></div> Basin Boundary</div>
          <input type="checkbox" checked onchange="toggleLayer('basin', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info"><div class="icon-line" style="background:#00E5FF;"></div> River Network</div>
          <input type="checkbox" checked onchange="toggleLayer('rivers', this.checked)">
        </div>
        <div class="layer-item">
          <div class="layer-info"><div class="icon-dot" style="background:#ff5252;"></div> Flood Stations</div>
          <input type="checkbox" checked onchange="toggleLayer('floodStations', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info"><div class="icon-dot" style="background:#062B6F;"></div> Dams</div>
          <input type="checkbox" checked onchange="toggleLayer('dams', this.checked)">
        </div>
      </div>

      <button class="category-btn">üå± Ecosystems & Restoration</button>
      <div class="layer-panel">
        <div class="layer-item">
          <div class="layer-info"><div class="icon-dot" style="background:gold;"></div> Desert Dams (Inventory)</div>
          <input type="checkbox" checked onchange="toggleLayer('sites', this.checked)">
        </div>
      </div>

      <button class="category-btn">üèôÔ∏è Built Environment</button>
      <div class="layer-panel">
        <div class="layer-item">
          <div class="layer-info">
            <div class="icon-box" style="background:#888;"></div>
            LoD1 Buildings (3D Extrusion)
          </div>
          <input type="checkbox" onchange="toggleLayer('buildings', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info" style="font-size:12px; color:#9aa;">
            Tip: If loading is slow, use <span style="color:#66fcf1;">mujib_lod1_simplified.geojson</span> or 3D Tiles.
          </div>
        </div>
      </div>

    </div>

    <div id="chartPanel">
      <div id="chartHeader">
        <div id="controlsRow">
          <select id="scenarioSelect" class="dtSelect" onchange="refreshAll()">
            <option value="baseline">Baseline</option>
            <option value="marab">Marab</option>
            <option value="vallerani">Vallerani</option>
            <option value="combined">Combined</option>
          </select>

          <select id="whatifSelect" class="dtSelect" onchange="refreshAll()">
            <option value="auto">What-if (auto)</option>
          </select>

          <select id="metricSelect" class="dtSelect" onchange="refreshAll()">
            <option value="runoff">üåä Runoff (SURQ)</option>
            <option value="sediment">üìâ Sediment (SYLD)</option>
            <option value="groundwater">üíß Groundwater Recharge (PERC)</option>
            <option value="vegetation">üåø Vegetation / ET</option>
            <option value="decision">‚úÖ Decision: Best Intervention</option>
          </select>
        </div>

        <button id="closeChartBtn" onclick="document.getElementById('chartPanel').style.display='none'">
          Close ‚úï
        </button>
      </div>

      <canvas id="swatChart"></canvas>
    </div>
  </div>

  <div id="legendPanel">
    <strong id="legendTitle">Map</strong>
    <div id="legendSubtitle" style="font-size: 11px; color:#aaa; margin-bottom:5px;">‚Äî</div>
    <div class="gradient-bar" id="legendGradient"></div>
    <div class="legend-labels" id="legendLabels">
      <span>Low</span><span>Avg</span><span>High</span>
    </div>
  </div>

  <!-- ‚úÖ Right-side floating asset details -->
  <div id="assetPanel" aria-label="Asset details">
    <div id="assetPanelHeader">
      <div style="min-width:0;">
        <div id="assetPanelTitle">Asset</div>
        <div id="assetPanelSubtitle">‚Äî</div>
      </div>
      <button id="assetPanelClose" title="Close">‚úï</button>
    </div>
    <div id="assetPanelBody"></div>
  </div>

  <div id="cesiumContainer"></div>

<script>
  // ============================
  // CONFIG (YOUR FILES)
  // ============================
  const YOUR_ACCESS_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZjM2YjEyMC1lNTM1LTQzZmUtYjUwNi00ZGVmMmE4ZjdmYTgiLCJpZCI6MzY3MDE2LCJpYXQiOjE3NjQ5NDc0NDl9.jgizcSHHOPz8Q9DroBtP3pkAFsjrlCQxRuhWrIFoGi4';
  const MY_MUJIB_DEM_ASSET_ID = 4194989;

  // Put these NEXT TO index.html
  const SWAT_SUBBASINS_GEOJSON = 'subbasins_swat23.geojson';

  // ‚úÖ IMPORTANT: use FINAL JSON you created (with priority_by_scenario + summary)
  const SCENARIO_JSON = 'scenarios_USED_BY_CESIUM_FINAL.json';

  // LoD1 buildings (put next to index.html)
  // Tip: for faster loading, use a simplified GeoJSON or 3D Tiles.
  const LOD1_BUILDINGS_GEOJSON = 'mujib_lod1_simplified.geojson';

  // Extra layers (converted from SHP -> GeoJSON)
  const FLOOD_STATIONS_GEOJSON = 'flood_stations.geojson';
  const DAMS_GEOJSON = 'dams.geojson';

  // Desert dams inventory (points)
  const DESERT_DAMS_GEOJSON = 'interventions.json';

  // Dam English name overrides (Arabic -> English)
  const DAM_EN_NAME_OVERRIDE = {
    "ÿ≥ÿØ ÿßŸÑŸàÿßŸÑŸá": "Wala Dam"
  };

  // ============================
  // STATUS UI
  // ============================
  const subStatus = document.getElementById('subStatus');
  const jsonStatus = document.getElementById('jsonStatus');
  const hoverStatus = document.getElementById('hoverStatus');
  const clickStatus = document.getElementById('clickStatus');

  const scenarioSelect = document.getElementById('scenarioSelect');
  const whatifSelect = document.getElementById('whatifSelect');
  const metricSelect = document.getElementById('metricSelect');

  const legendPanel = document.getElementById('legendPanel');
  const legendTitle = document.getElementById('legendTitle');
  const legendSubtitle = document.getElementById('legendSubtitle');
  const legendLabels = document.getElementById('legendLabels');
  const legendGradient = document.getElementById('legendGradient');

  // ============================
  // RIGHT-SIDE ASSET PANEL (Flood Stations + Dams)
  // ============================
  const assetPanel = document.getElementById('assetPanel');
  const assetPanelTitle = document.getElementById('assetPanelTitle');
  const assetPanelSubtitle = document.getElementById('assetPanelSubtitle');
  const assetPanelBody = document.getElementById('assetPanelBody');
  const assetPanelClose = document.getElementById('assetPanelClose');

  function showAssetPanel(title, subtitle, bodyHtml) {
    assetPanelTitle.textContent = title || 'Asset';
    assetPanelSubtitle.textContent = subtitle || '';
    assetPanelBody.innerHTML = bodyHtml || '';
    assetPanel.style.display = 'block';
  }
  function hideAssetPanel() { assetPanel.style.display = 'none'; }

  assetPanelClose.addEventListener('click', hideAssetPanel);

  function escapeHtml(x){
    if (x === null || x === undefined) return '';
    return String(x)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function propVal(props, key) {
    if (!props) return null;
    const p = props[key];
    if (!p) return null;
    try {
      return (typeof p.getValue === "function") ? p.getValue(Cesium.JulianDate.now()) : p;
    } catch {
      return null;
    }
  }

  function propAny(props, keys) {
    for (const k of keys) {
      const v = propVal(props, k);
      if (v !== null && v !== undefined && v !== "") return v;
    }
    return null;
  }

  function getEntityCenterCartographic(entity){
    const now = Cesium.JulianDate.now();
    let cart = null;

    try {
      if (entity.position && typeof entity.position.getValue === "function") {
        cart = entity.position.getValue(now);
      } else if (entity.position) {
        cart = entity.position;
      }
    } catch {}

    if (!cart && entity.polygon && entity.polygon.hierarchy) {
      try {
        const h = entity.polygon.hierarchy.getValue ? entity.polygon.hierarchy.getValue(now) : entity.polygon.hierarchy;
        const positions = h?.positions;
        if (positions && positions.length) cart = Cesium.BoundingSphere.fromPoints(positions).center;
      } catch {}
    }

    if (!cart && entity.polyline && entity.polyline.positions) {
      try {
        const positions = entity.polyline.positions.getValue ? entity.polyline.positions.getValue(now) : entity.polyline.positions;
        if (positions && positions.length) cart = Cesium.BoundingSphere.fromPoints(positions).center;
      } catch {}
    }

    if (!cart) return null;
    return Cesium.Cartographic.fromCartesian(cart);
  }

  function latLonString(entity){
    const c = getEntityCenterCartographic(entity);
    if (!c) return null;
    const lat = Cesium.Math.toDegrees(c.latitude);
    const lon = Cesium.Math.toDegrees(c.longitude);
    return `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
  }

  function extractAllProps(entity){
    const props = entity?.properties;
    if (!props || !Array.isArray(props.propertyNames)) return {};
    const out = {};
    const now = Cesium.JulianDate.now();
    props.propertyNames.forEach((name) => {
      try {
        const p = props[name];
        out[name] = (p && typeof p.getValue === "function") ? p.getValue(now) : p;
      } catch {
        out[name] = null;
      }
    });
    return out;
  }

  function kv(label, value){
    const v = (value === null || value === undefined || value === "") ? "‚Äî" : value;
    return `<div class="kv"><div class="k">${escapeHtml(label)}</div><div class="v">${escapeHtml(v)}</div></div>`;
  }

  function flyToEntity(entity){
    if (!entity) return;
    try {
      viewer.flyTo(entity, { duration: 1.2, offset: new Cesium.HeadingPitchRange(0, -0.55, 2500) });
    } catch {
      viewer.flyTo(entity);
    }
  }

  function renderFloodStationPanel(entity){
    const p = entity.properties;
    const stationId = propAny(p, ["Station_Id","Station_ID","station_id","ID","Id"]);
    const stationName = propAny(p, ["Station_Na","Station_Name","Name","name"]);
    const sub = propAny(p, ["Subbasin","Sub_Basin","Basin","Surface_Ba"]);
    const gov = propAny(p, ["Governorat","Governorate"]);
    const own = propAny(p, ["Ownership"]);
    const elev = propAny(p, ["Elevation","ELEVATION"]);
    const date = propAny(p, ["Date_stati","Date_start","Date"]);
    const village = propAny(p, ["Village_To","Village"]);

    const coords = latLonString(entity);

    const title = stationName ? `${stationName}` : "Flood Station";
    const subtitle = `Station ID: ${stationId || "‚Äî"}${sub ? " ‚Ä¢ " + sub : ""}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">Flood Station</div>
        <div class="assetBadge">ID: ${escapeHtml(stationId || "‚Äî")}</div>
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || "‚Äî")}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Key details</div>
      <div class="kvGrid">
        ${kv("Station Name", stationName)}
        ${kv("Station ID", stationId)}
        ${kv("Subbasin", propAny(p, ["Subbasin"]))}
        ${kv("Elevation (m)", elev)}
        ${kv("Governorate", gov)}
        ${kv("Ownership", own)}
        ${kv("Start date", date)}
        ${kv("Nearest village/town", village)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById("assetZoomBtn");
    if (btn) btn.onclick = () => flyToEntity(entity);
  }

  function renderDamPanel(entity){
    const p = entity.properties;
    const en = propAny(p, ["En_name","EN_NAME","Name","NAME"]);
    const ar = propAny(p, ["Ar_Name","AR_NAME"]);
    const node = propAny(p, ["NODE_ID","Node_ID","node_id","ID"]);
    const type = propAny(p, ["TYPE","Type"]);
    const status = propAny(p, ["STATUS","Status"]);
    const comp = propAny(p, ["COMPLETION","Completion"]);
    const damType = propAny(p, ["DAM_TYPE","Dam_Type"]);
    const height = propAny(p, ["HEIGHT__M_","HEIGHT_M","HEIGHT"]);
    const catchment = propAny(p, ["CATCHMENT_","CATCHMENT","Catchment"]);
    const live = propAny(p, ["LIVE_STORA","LIVE_STORAGE"]);
    const dead = propAny(p, ["DEAD_STORA","DEAD_STORAGE"]);
    const purpose = propAny(p, ["PURPOSE","Purpose"]);
    const spill = propAny(p, ["SPILLWAY_C","SPILLWAY"]);
    const saf = propAny(p, ["YEARLY_SAF","SAFE_YIELD"]);
    const sed = propAny(p, ["SEDIMENT_L","SEDIMENT"]);
    const evap = propAny(p, ["EVAPORAT_1","EVAPORATIO","Evaporation"]);
    const maxEl = propAny(p, ["MAX_ELEVAT","MAX_ELEVATION"]);
    const free = propAny(p, ["FREE_BOARD","FREEBOARD"]);

    const coords = latLonString(entity);
    const title = en || ar || "Dam / Reservoir";
    const subtitle = `${node ? "Node: " + node : "Dam asset"}${type ? " ‚Ä¢ " + type : ""}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">${escapeHtml((type || "Dam").toString())}</div>
        ${node ? `<div class="assetBadge">Node: ${escapeHtml(node)}</div>` : ``}
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || "‚Äî")}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Names</div>
      <div class="kvGrid">
        ${kv("English name", en)}
        ${kv("Arabic name", ar)}
        ${kv("Node ID", node)}
        ${kv("Type", type)}
      </div>

      <div class="assetSectionTitle">Status & design</div>
      <div class="kvGrid">
        ${kv("Status", status)}
        ${kv("Completion", comp)}
        ${kv("Dam type", damType)}
        ${kv("Height (m)", height)}
        ${kv("Max elevation (m)", maxEl)}
        ${kv("Freeboard (m)", free)}
        ${kv("Spillway capacity", spill)}
      </div>

      <div class="assetSectionTitle">Hydrology & storage</div>
      <div class="kvGrid">
        ${kv("Catchment", catchment)}
        ${kv("Purpose", purpose)}
        ${kv("Live storage", live)}
        ${kv("Dead storage", dead)}
        ${kv("Safe yield / yearly", saf)}
        ${kv("Sediment load", sed)}
        ${kv("Evaporation", evap)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById("assetZoomBtn");
    if (btn) btn.onclick = () => flyToEntity(entity);
  }

  
  function renderDesertDamPanel(entity){
    const p = entity.properties;

    // Desert dam inventory fields (from interventions.json)
    const name = propAny(p, ["Dam_Name","DAM_NAME","Name","NAME"]);
    const whNo = propAny(p, ["WH_No","WH_NO","WHNO","ID","Id"]);
    const gov = propAny(p, ["Governorat","Governorate","GOVERNORAT"]);
    const project = propAny(p, ["Project","PROJECT"]);
    const damType = propAny(p, ["Dam_type","DAM_TYPE","Type","TYPE"]);
    const year = propAny(p, ["Constructi","Construction","Year","YEAR"]);
    const curCap = propAny(p, ["Current_ca","CURRENT_CA","CurrentCap"]);
    const desCap = propAny(p, ["Design_Cap","DESIGN_CAP","DesignCap"]);
    const east = propAny(p, ["East","EAST"]);
    const north = propAny(p, ["North","NORTH"]);

    const coords = latLonString(entity);
    const title = name ? String(name) : 'Desert Dam';
    const subtitle = `WH No: ${whNo || '‚Äî'}${gov ? ' ‚Ä¢ ' + gov : ''}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">Desert Dam (Inventory)</div>
        ${whNo ? `<div class="assetBadge">WH No: ${escapeHtml(String(whNo))}</div>` : ``}
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || '‚Äî')}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Key details</div>
      <div class="kvGrid">
        ${kv('Dam name', name)}
        ${kv('WH No', whNo)}
        ${kv('Governorate', gov)}
        ${kv('Project', project)}
        ${kv('Dam type', damType)}
        ${kv('Construction year', year)}
        ${kv('Current capacity', curCap)}
        ${kv('Design capacity', desCap)}
        ${kv('East (source)', east)}
        ${kv('North (source)', north)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById('assetZoomBtn');
    if (btn) btn.onclick = () => flyToEntity(entity);
  }

function renderBuildingPanel(entity){
    const p = entity.properties;

    const bId = propAny(p, ["id","ID","identificatie","Identificatie","bag_id","BAG_ID","pand_id","Pand_ID","pandid","PANDID","building_id","Building_ID"]);
    const name = propAny(p, ["name","Name","building_name","Building_Name","pandnaam","PandNaam"]);

    const h = Number.isFinite(entity.buildingHeight)
      ? entity.buildingHeight
      : Number(propAny(p, ["height","Height"]));
    const hOk = Number.isFinite(h);
    const src = entity.heightSource || (propAny(p, ["height"]) != null ? "height" : (propAny(p, ["Height"]) != null ? "Height" : "unknown"));

    const coords = latLonString(entity);
    const title = name ? String(name) : (bId ? `Building ${bId}` : "Building");
    const subtitle = `Height: ${hOk ? (h + ' m') : '‚Äî'} ‚Ä¢ Source: ${src}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">Building (LoD1)</div>
        ${bId ? `<div class="assetBadge">ID: ${escapeHtml(String(bId))}</div>` : ``}
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || '‚Äî')}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Key details</div>
      <div class="kvGrid">
        ${kv("Name", name)}
        ${kv("Building ID", bId)}
        ${kv("Extrusion height (m)", hOk ? h : null)}
        ${kv("Height source", src)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById("assetZoomBtn");
    if (btn) btn.onclick = () => flyToEntity(entity);
  }


  // ============================
  // CESIUM VIEWER
  // ============================
  Cesium.Ion.defaultAccessToken = YOUR_ACCESS_TOKEN;

  const viewer = new Cesium.Viewer('cesiumContainer', {
    baseLayerPicker: true,
    animation: true,
    timeline: true,
    geocoder: false,
    homeButton: false,
    sceneModePicker: true,
    selectionIndicator: true,
    infoBox: false
  });

  viewer.scene.globe.depthTestAgainstTerrain = false;

  async function loadTerrain() {
    try {
      viewer.terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(MY_MUJIB_DEM_ASSET_ID);
    } catch (e) {
      console.error("Terrain Error", e);
    }
  }
  loadTerrain();

  // ============================
  // DATA / STATE
  // ============================
  let scenarioData = null;
  let currentSubbasinId = null;
  let myChart = null;

  // Map state
  let heatmapOn = false;
  let isDeltaMode = false;        // only for numeric metrics (not decision)
  let hoverHandlerInstalled = false;
  let lastHover = null;

  // ============================
  // LOAD SCENARIOS
  // ============================
  async function loadScenarioData() {
    try {
      const res = await fetch(SCENARIO_JSON);
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${SCENARIO_JSON}`);
      scenarioData = await res.json();

      const keys = Object.keys(scenarioData || {});
      const ok = (keys.length === 23 && scenarioData["Subbasin_1"] && scenarioData["Subbasin_23"]);
      jsonStatus.textContent = `loaded (${keys.length} keys) ${ok ? '‚úÖ' : '‚ö†Ô∏è'}`;
      jsonStatus.className = ok ? 'ok' : 'warn';

      setupWhatifDropdown();
      console.log("‚úÖ scenarios loaded:", keys.slice(0,5), "‚Ä¶");

    } catch (err) {
      console.error("‚ùå Scenario JSON load failed:", err);
      jsonStatus.textContent = 'FAILED ‚ùå';
      jsonStatus.className = 'bad';
      alert(`Could not load ${SCENARIO_JSON}. Put it next to index.html and run with Live Server (not file://).`);
    }
  }

  function setupWhatifDropdown() {
    whatifSelect.innerHTML = `<option value="auto">What-if (auto)</option>`;

    const s1 = scenarioData?.["Subbasin_1"];
    const whatifs = s1?.whatifs ? Object.keys(s1.whatifs) : [];
    if (whatifs.length === 0) {
      const opt = document.createElement("option");
      opt.value = "dP0_dT0";
      opt.textContent = "dP0_dT0 (fallback)";
      whatifSelect.appendChild(opt);
      whatifSelect.value = "auto";
      return;
    }

    const def = s1.default_whatif || whatifs[0];
    const ordered = [def, ...whatifs.filter(x => x !== def)];
    ordered.forEach(k => {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      whatifSelect.appendChild(opt);
    });

    whatifSelect.value = "auto";
  }

  function getActiveWhatifKey(subId) {
    const selected = whatifSelect.value;
    if (selected !== "auto") return selected;
    const s = scenarioData?.[`Subbasin_${subId}`] || scenarioData?.["Subbasin_1"];
    return (s?.default_whatif) || "dP0_dT0";
  }

  function getWhatifObject(subId) {
    const node = scenarioData?.[`Subbasin_${subId}`];
    if (!node) return null;
    const wKey = getActiveWhatifKey(subId);
    const wObj = node.whatifs?.[wKey];
    return { node, wKey, wObj };
  }

  // ============================
  // METRIC GETTERS
  // ============================
  function getAnnualValue(subId, scenarioName, metricName) {
    const pack = getWhatifObject(subId);
    if (!pack) return null;

    const { node, wObj } = pack;

    let v = wObj?.annual?.[scenarioName]?.[metricName];
    if (Number.isFinite(v)) return v;

    v = wObj?.annual_by_scenario?.[metricName]?.[scenarioName];
    if (Number.isFinite(v)) return v;

    if (metricName === "runoff") {
      v = wObj?.annual_runoff_by_scenario?.[scenarioName];
      if (Number.isFinite(v)) return v;
      v = node?.annual_runoff_by_scenario?.[scenarioName];
      if (Number.isFinite(v)) return v;
      v = node?.annual_runoff_mm;
      if (Number.isFinite(v)) return v;
    }

    v = node?.[`annual_${metricName}_by_scenario`]?.[scenarioName];
    if (Number.isFinite(v)) return v;

    v = node?.[`annual_${metricName}`];
    if (Number.isFinite(v)) return v;

    return null;
  }

  function getDeltaAnnual(subId, scenarioName, metricName) {
    const base = getAnnualValue(subId, "baseline", metricName);
    const sel  = getAnnualValue(subId, scenarioName, metricName);
    if (!Number.isFinite(base) || !Number.isFinite(sel)) return null;
    return sel - base;
  }

  // ============================
  // DECISION (PRIORITY) GETTERS
  // ============================
  function getPriorityPack(subId) {
    const key = `Subbasin_${subId}`;
    const node = scenarioData?.[key];
    if (!node) return null;

    const wKey = getActiveWhatifKey(subId);
    const wObj = node.whatifs?.[wKey];
    if (!wObj) return null;

    const scenarioName = scenarioSelect.value;
    const pr = wObj.priority_by_scenario?.[scenarioName] || {};
    const sum = wObj.priority_summary_by_scenario?.[scenarioName] || {};

    return { wKey, wObj, pr, sum };
  }

  function focusColor(focus) {
    if (focus === "marab")     return Cesium.Color.ORANGE;
    if (focus === "vallerani") return Cesium.Color.MEDIUMPURPLE;
    if (focus === "recharge")  return Cesium.Color.DODGERBLUE;
    if (focus === "erosion")   return Cesium.Color.DARKRED;
    return Cesium.Color.LIGHTGRAY;
  }

  function applyScoreToColor(color, score) {
    const s = Math.max(0, Math.min(1, Number(score) || 0));
    return color.withAlpha(0.25 + 0.65 * s); // 0.25..0.90
  }

  // ============================
  // COLOR RAMPS (numeric metrics)
  // ============================
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function lerpColor(c1, c2, t){
    const out = new Cesium.Color();
    Cesium.Color.lerp(c1, c2, clamp01(t), out);
    return out;
  }

  const RAMP = {
    runoff:      { lo: Cesium.Color.LIGHTBLUE.withAlpha(0.60), hi: Cesium.Color.NAVY.withAlpha(0.85), legend: "linear-gradient(to right,#ccc,#81D4FA,#29B6F6,#0277BD,#0D47A1)" },
    sediment:    { lo: Cesium.Color.MISTYROSE.withAlpha(0.60), hi: Cesium.Color.DARKRED.withAlpha(0.85), legend: "linear-gradient(to right,#fee,#fbb,#f66,#c00,#6b0000)" },
    groundwater: { lo: Cesium.Color.LIGHTCYAN.withAlpha(0.60), hi: Cesium.Color.DARKSLATEBLUE.withAlpha(0.85), legend: "linear-gradient(to right,#e0ffff,#9be7ff,#4db6ff,#1565c0,#0d2a6b)" },
    vegetation:  { lo: Cesium.Color.PALEGREEN.withAlpha(0.55), hi: Cesium.Color.DARKGREEN.withAlpha(0.85), legend: "linear-gradient(to right,#e8f5e9,#a5d6a7,#66bb6a,#2e7d32,#0b3d18)" },
  };

  const DELTA = {
    neg: Cesium.Color.DARKRED.withAlpha(0.80),
    mid: Cesium.Color.WHITE.withAlpha(0.20),
    pos: Cesium.Color.DARKGREEN.withAlpha(0.80),
    legend: "linear-gradient(to right,#6b0000,#ff6b6b,#ffffff,#7ee081,#0b3d18)"
  };

  function metricLabel(metric){
    if(metric === "runoff") return "Runoff (Annual)";
    if(metric === "sediment") return "Sediment (Annual)";
    if(metric === "groundwater") return "Recharge (Annual)";
    if(metric === "vegetation") return "Vegetation / ET (Annual)";
    if(metric === "decision") return "Decision: Best Intervention";
    return metric;
  }

  function computeRange(metricName, scenarioName) {
    if (!layers?.subbasins || !scenarioData) return {min:0, max:1};
    const vals = [];

    layers.subbasins.entities.values.forEach(e => {
      const id = e.subbasinId;
      if (id == null) return;
      const v = isDeltaMode ? getDeltaAnnual(id, scenarioName, metricName)
                            : getAnnualValue(id, scenarioName, metricName);
      if (Number.isFinite(v)) vals.push(v);
    });

    if (vals.length < 3) return {min:0, max:1};
    vals.sort((a,b)=>a-b);

    const p5  = vals[Math.floor(0.05*(vals.length-1))];
    const p95 = vals[Math.floor(0.95*(vals.length-1))];
    if (p5 === p95) return {min:p5-1, max:p95+1};
    return {min:p5, max:p95};
  }

  // ============================
  // MAP STYLING (metric + decision)
  // ============================
  function applyDecisionMap() {
    if (!layers?.subbasins || !scenarioData) return;

    const scenarioName = scenarioSelect.value;
    const whatifLabel = getActiveWhatifKey(1);

    legendPanel.style.display = "block";
    legendTitle.textContent = "Decision Map (Best Focus)";
    legendSubtitle.textContent = `Scenario: ${scenarioName} | What-if: ${whatifLabel}`;
    legendGradient.style.background = "linear-gradient(to right,#ff9800,#9c27b0,#2196f3,#b71c1c)";
    legendLabels.innerHTML = `<span>Marab</span><span>Vallerani</span><span>Recharge/Erosion</span>`;

    const entities = layers.subbasins.entities.values;

    entities.forEach(e => {
      if (!e.polygon) return;
      const id = e.subbasinId;
      if (id == null) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }

      const pack = getPriorityPack(id);
      if (!pack) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }

      const focus = pack.sum?.best_focus;   // marab/vallerani/recharge/erosion
      const score = pack.sum?.best_score;   // 0..1

      const baseCol = focusColor(focus);
      e.polygon.material = applyScoreToColor(baseCol, score);

      e.polygon.outline = true;
      e.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(0.95);
      e.polygon.outlineWidth = 3;
    });
  }

  function applyNumericMap(metricName) {
    if (!layers?.subbasins || !scenarioData) return;

    const scenarioName = scenarioSelect.value;
    const whatifLabel = getActiveWhatifKey(1);

    const range = computeRange(metricName, scenarioName);

    legendPanel.style.display = "block";
    legendTitle.textContent = (isDeltaMode ? `Œî ${metricLabel(metricName)} vs Baseline` : metricLabel(metricName));
    legendSubtitle.textContent = `Scenario: ${scenarioName} | What-if: ${whatifLabel}`;

    if (isDeltaMode) {
      legendGradient.style.background = DELTA.legend;
      legendLabels.innerHTML = `<span>Negative</span><span>0</span><span>Positive</span>`;
    } else {
      legendGradient.style.background = (RAMP[metricName]?.legend || RAMP.runoff.legend);
      legendLabels.innerHTML = `<span>Low</span><span>Avg</span><span>High</span>`;
    }

    const entities = layers.subbasins.entities.values;

    entities.forEach(e => {
      if (!e.polygon) return;
      const id = e.subbasinId;
      if (id == null) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }

      const v = isDeltaMode ? getDeltaAnnual(id, scenarioName, metricName)
                            : getAnnualValue(id, scenarioName, metricName);

      if (!Number.isFinite(v)) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }

      if (isDeltaMode) {
        const span = Math.max(Math.abs(range.min), Math.abs(range.max), 1e-6);
        const t = clamp01((v + span) / (2*span));
        let col;
        if (t < 0.5) col = lerpColor(DELTA.neg, DELTA.mid, t/0.5);
        else         col = lerpColor(DELTA.mid, DELTA.pos, (t-0.5)/0.5);
        e.polygon.material = col;
      } else {
        const t = clamp01((v - range.min) / (range.max - range.min));
        const ramp = RAMP[metricName] || RAMP.runoff;
        e.polygon.material = lerpColor(ramp.lo, ramp.hi, t);
      }

      e.polygon.outline = true;
      e.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(0.95);
      e.polygon.outlineWidth = 3;
    });
  }

  function applyMapStyle() {
    const metricName = metricSelect.value;

    if (metricName === "decision") {
      applyDecisionMap();
      return;
    }

    applyNumericMap(metricName);
  }

  function resetSubbasinColors() {
    if (!layers?.subbasins) return;
    layers.subbasins.entities.values.forEach(e => {
      if (e.polygon && e.originalColor) {
        e.polygon.material = e.originalColor;
        e.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(0.95);
        e.polygon.outlineWidth = 3;
      }
    });
    legendPanel.style.display = "none";
  }

  // ============================
  // LAYERS
  // ============================
  const layers = {};

  async function toggleLayer(id, isVisible) {
    if (!layers[id]) {
      if (id === 'basin') await loadBasinLayer();
      else if (id === 'rivers') await loadRiverLayer();
      else if (id === 'dams') await loadDamsLayer();
      else if (id === 'sites') await loadSitesLayer();
      else if (id === 'subbasins') await loadSubbasinsLayer();
      else if (id === 'buildings') await loadBuildingsLayer();
      else if (id === 'floodStations') await loadFloodStationsLayer();
}
    if (layers[id]) layers[id].show = isVisible;
    if (id === 'basin' && isVisible) viewer.flyTo(layers[id], { offset: new Cesium.HeadingPitchRange(0, -0.7, 5000) });
  }

  async function loadSubbasinsLayer() {
    console.log("‚è≥ Loading SWAT subbasins:", SWAT_SUBBASINS_GEOJSON);

    try {
      const resource = await Cesium.GeoJsonDataSource.load(SWAT_SUBBASINS_GEOJSON, {
        stroke: Cesium.Color.WHITE.withAlpha(1.0),
        strokeWidth: 3,
        clampToGround: true
      });

      const entities = resource.entities.values;
      let valid = 0;

      function colorFromId(id) {
        const hue = (id * 37) % 360;
        return Cesium.Color.fromHsl(hue / 360, 0.65, 0.45).withAlpha(0.22);
      }

      entities.forEach((entity) => {
        if (!entity.polygon) return;

        if (entity.properties && entity.properties.subbasinId) {
          entity.subbasinId = entity.properties.subbasinId.getValue();
          valid += 1;
        } else if (entity.properties && entity.properties.SUB) {
          entity.subbasinId = entity.properties.SUB.getValue();
          valid += 1;
        } else if (entity.properties && entity.properties.Subbasin) {
          entity.subbasinId = entity.properties.Subbasin.getValue();
          valid += 1;
        } else {
          entity.subbasinId = null;
        }

        const id = entity.subbasinId;

        entity.originalColor = (id != null)
          ? colorFromId(id)
          : Cesium.Color.GRAY.withAlpha(0.25);

        entity.polygon.material = entity.originalColor;
        entity.polygon.outline = true;
        entity.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(0.95);
        entity.polygon.outlineWidth = 3;

        entity.label = new Cesium.LabelGraphics({
          text: id != null ? `SUB ${id}` : "SUB ?",
          show: false,
          font: "14px sans-serif",
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 4,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -12),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });
      });

      viewer.dataSources.add(resource);
      layers['subbasins'] = resource;

      subStatus.textContent = `loaded (${entities.length} features, ${valid} valid IDs)`;
      subStatus.className = (entities.length === 23 && valid >= 23) ? 'ok' : 'warn';

      console.log(`‚úÖ Loaded SWAT subbasins: ${entities.length} (valid IDs: ${valid})`);
      viewer.flyTo(resource);

      if (!hoverHandlerInstalled) {
        installHoverHandler();
        hoverHandlerInstalled = true;
      }

      if (heatmapOn && scenarioData) applyMapStyle();

    } catch (e) {
      console.error("Error loading subbasins", e);
      subStatus.textContent = 'FAILED ‚ùå';
      subStatus.className = 'bad';
      alert(`Failed to load ${SWAT_SUBBASINS_GEOJSON}. Put it next to index.html and run with Live Server.`);
    }
  }

  function installHoverHandler() {
    viewer.screenSpaceEventHandler.setInputAction(function(movement) {
      const picked = viewer.scene.pick(movement.endPosition);

      // Reset previous hover styling
      if (lastHover && lastHover.polygon) {
        lastHover.polygon.outlineColor = Cesium.Color.WHITE.withAlpha(0.95);
        lastHover.polygon.outlineWidth = 3;
        if (lastHover.label) lastHover.label.show = false;
      }
      if (lastHover && !lastHover.polygon && lastHover.label) {
        lastHover.label.show = false;
      }

      if (Cesium.defined(picked) && picked.id) {
        const e = picked.id;

        // Subbasins hover
        if (e.subbasinId != null) {
          hoverStatus.textContent = `SUB ${e.subbasinId}`;
          hoverStatus.className = 'ok';

          if (e.polygon) {
            e.polygon.outlineColor = Cesium.Color.YELLOW.withAlpha(1.0);
            e.polygon.outlineWidth = 5;
          }
          if (e.label) e.label.show = true;
          lastHover = e;
          return;
        }

        // Desert dam hover
        if (e.assetType === 'desert_dam') {
          hoverStatus.textContent = `Desert Dam`;
          hoverStatus.className = 'ok';
          if (e.label) e.label.show = true;
          lastHover = e;
          return;
        }
      }

      // Nothing found
      hoverStatus.textContent = 'none';
      hoverStatus.className = 'warn';
      lastHover = null;

    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  }

  async function loadBasinLayer() {
    try {
      const res = await Cesium.GeoJsonDataSource.load('basin.geojson');
      res.entities.values.forEach(e => {
        if (e.polygon) {
          e.corridor = {
            positions: e.polygon.hierarchy.getValue().positions,
            width: 150.0,
            material: Cesium.Color.DARKORANGE,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          };
          e.polygon = undefined;
        }
      });
      viewer.dataSources.add(res); layers['basin'] = res;
    } catch (e) { console.error("Basin load error", e); }
  }

  async function loadRiverLayer() {
    try {
      const res = await Cesium.GeoJsonDataSource.load('rivers.json');
      res.entities.values.forEach(e => {
        if (e.polyline) {
          e.corridor = {
            positions: e.polyline.positions,
            width: 20.0,
            material: Cesium.Color.CYAN.withAlpha(0.8),
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            cornerType: Cesium.CornerType.ROUNDED
          };
          e.polyline = undefined;
        }
      });
      viewer.dataSources.add(res); layers['rivers'] = res;
    } catch (e) { console.error("Rivers load error", e); }
  }
  // ============================
  // FLOOD STATIONS (GeoJSON)
  // ============================
  async function loadFloodStationsLayer() {
    try {
      const res = await Cesium.GeoJsonDataSource.load(FLOOD_STATIONS_GEOJSON, { clampToGround: true });

      res.entities.values.forEach(e => {
        // Style point features
        if (e.position) {
          e.billboard = undefined;
          e.point = {
            pixelSize: 10,
            color: Cesium.Color.RED.withAlpha(0.9),
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          };
        }

        // Optional label (hidden by default)
        const p = e.properties;
        const name =
          (p?.Station?.getValue?.() ?? p?.station?.getValue?.() ??
           p?.Name?.getValue?.() ?? p?.name?.getValue?.() ??
           p?.ID?.getValue?.() ?? p?.id?.getValue?.() ?? "Flood Station");

        e.label = new Cesium.LabelGraphics({
          text: String(name),
          show: false,
          font: "12px sans-serif",
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 3,
          pixelOffset: new Cesium.Cartesian2(0, -14),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        // ‚úÖ Tag for click-details panel
        e.assetType = "flood_station";
        e.assetId = (p?.Station_Id?.getValue?.() ?? p?.Station_ID?.getValue?.() ?? p?.ID?.getValue?.() ?? null);
        e.assetName = (p?.Station_Na?.getValue?.() ?? p?.Station_Name?.getValue?.() ?? p?.Name?.getValue?.() ?? "Flood Station");
      });

      viewer.dataSources.add(res);
      layers['floodStations'] = res;

      console.log("‚úÖ Flood Stations loaded:", res.entities.values.length);
    } catch (e) {
      console.error("‚ùå Flood Stations load error", e);
      alert(`Failed to load ${FLOOD_STATIONS_GEOJSON}. Put it next to index.html and run with Live Server.`);
    }
  }

  // ============================
// DAMS (GeoJSON)
// ============================
async function loadDamsLayer() {
  try {
    const res = await Cesium.GeoJsonDataSource.load(DAMS_GEOJSON, { clampToGround: true });

    // Solid, readable styling on satellite imagery
    const DAM_FILL = Cesium.Color.fromCssColorString("#062B6F");     // very dark navy
    const DAM_OUTLINE = Cesium.Color.fromCssColorString("#00B8FF");  // crisp cyan edge

    res.entities.values.forEach(e => {
      // Points
      if (e.position) {
        e.billboard = undefined;
        e.point = {
          pixelSize: 10,
          color: DAM_FILL.withAlpha(1.0),
          outlineColor: DAM_OUTLINE.withAlpha(1.0),
          outlineWidth: 2,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
        };
      }

      // Polygons
      if (e.polygon) {
        e.polygon.material = DAM_FILL.withAlpha(0.98);
        e.polygon.outline = true;
        e.polygon.outlineColor = DAM_OUTLINE.withAlpha(0.98);
        e.polygon.outlineWidth = 3;
      }

      // Polylines
      if (e.polyline) {
        e.polyline.material = DAM_OUTLINE.withAlpha(0.98);
        e.polyline.width = 4;
        e.polyline.clampToGround = true;
      }

      // ‚úÖ Tag for click-details panel
      e.assetType = "dam";
      const p = e.properties;

      e.assetId = (p?.NODE_ID?.getValue?.() ?? p?.Node_ID?.getValue?.() ?? p?.ID?.getValue?.() ?? null);

      // --- Name extraction + override (Wala Dam) ---
      const rawEn = (p?.En_name?.getValue?.() ?? p?.EN_NAME?.getValue?.() ?? "");
      const rawAr = (p?.Ar_Name?.getValue?.() ?? p?.AR_NAME?.getValue?.() ?? "");
      const rawNm = (p?.Name?.getValue?.() ?? p?.NAME?.getValue?.() ?? "");

      const en = String(rawEn || "").trim();
      const ar = String(rawAr || "").trim();
      const nm = String(rawNm || "").trim();

      // Normalize Arabic (remove spaces + tatweel + diacritics)
      const arNorm = String(ar || nm).replace(/[\s\u0640\u064B-\u065F\u0670]/g, "");

      // Force English for Wala if English missing
      if (en) {
        e.assetName = en;
      } else if (
        arNorm.includes("ÿ≥ÿØÿßŸÑŸàÿßŸÑŸá") || arNorm.includes("ÿ≥ÿØÿßŸÑŸàÿßŸÑÿ©") ||
        arNorm.includes("ÿßŸÑŸàÿßŸÑŸá")   || arNorm.includes("ÿßŸÑŸàÿßŸÑÿ©")
      ) {
        e.assetName = "Wala Dam";
      } else {
        e.assetName = ar || nm || "Dam";
      }
    });

    viewer.dataSources.add(res);
    layers["dams"] = res;

    console.log("‚úÖ Dams loaded:", res.entities.values.length);
  } catch (e) {
    console.error("‚ùå Dams load error", e);
    alert(`Failed to load ${DAMS_GEOJSON}. Put it next to index.html and run with Live Server.`);
  }
}

  
  // ============================
  // DESERT DAMS INVENTORY (GeoJSON points)
  // ============================
  async function loadSitesLayer() {
    try {
      const res = await Cesium.GeoJsonDataSource.load(DESERT_DAMS_GEOJSON, { clampToGround: true });

      res.entities.values.forEach(e => {
        // Style points (gold)
        if (e.position) {
          e.billboard = undefined;
          e.point = {
            pixelSize: 11,
            color: Cesium.Color.GOLD.withAlpha(0.95),
            outlineColor: Cesium.Color.BLACK.withAlpha(0.85),
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          };
        }

        // Hidden label (optional)
        const p = e.properties;
        const nm = (p?.Dam_Name?.getValue?.() ?? p?.DAM_NAME?.getValue?.() ?? p?.Name?.getValue?.() ?? p?.NAME?.getValue?.() ?? 'Desert Dam');

        e.label = new Cesium.LabelGraphics({
          text: String(nm),
          show: false,
          font: '12px sans-serif',
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 3,
          pixelOffset: new Cesium.Cartesian2(0, -14),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        // ‚úÖ Tag for click-details panel
        e.assetType = 'desert_dam';
        e.assetId = (p?.WH_No?.getValue?.() ?? p?.WH_NO?.getValue?.() ?? p?.ID?.getValue?.() ?? null);
        e.assetName = String(nm);
      });

      viewer.dataSources.add(res);
      layers['sites'] = res;

      console.log('‚úÖ Desert Dams (Inventory) loaded:', res.entities.values.length);
    } catch (e) {
      console.error('‚ùå Desert Dams load error', e);
      alert(`Failed to load ${DESERT_DAMS_GEOJSON}. Put it next to index.html and run with Live Server.`);
    }
  }

// ============================
  // LOD1 BUILDINGS (GeoJSON -> 3D extrusion)
  // ============================
  async function loadBuildingsLayer() {
    console.log("‚è≥ Loading LoD1 buildings:", LOD1_BUILDINGS_GEOJSON);

    try {
      const ds = await Cesium.GeoJsonDataSource.load(LOD1_BUILDINGS_GEOJSON, {
        clampToGround: true
      });

      const entities = ds.entities.values;

      function getPropNumber(props, key) {
        if (!props || !props[key]) return null;
        const v = props[key];
        const x = (typeof v.getValue === "function")
          ? v.getValue(Cesium.JulianDate.now())
          : v;
        const n = Number(x);
        return Number.isFinite(n) ? n : null;
      }

      let extruded = 0;

      for (const e of entities) {
        if (!e.polygon) continue;

        const props = e.properties;

        let h = getPropNumber(props, "height");
        let hSrc = Number.isFinite(h) ? "height" : null;
        if (!Number.isFinite(h)) { h = getPropNumber(props, "Height"); if (Number.isFinite(h)) hSrc = "Height"; }
        if (!Number.isFinite(h)) { h = 10; hSrc = "default (10m)"; }

        const now = Cesium.JulianDate.now();

        function flattenHierarchy(h) {
          if (!h || !h.positions) return h;
          const flatPositions = h.positions.map((p) => {
            const c = Cesium.Cartographic.fromCartesian(p);
            return Cesium.Cartesian3.fromRadians(c.longitude, c.latitude, 0.0);
          });
          const flatHoles = (h.holes || []).map((hole) => flattenHierarchy(hole));
          return new Cesium.PolygonHierarchy(flatPositions, flatHoles);
        }

        try {
          const hierarchy = e.polygon.hierarchy && e.polygon.hierarchy.getValue
            ? e.polygon.hierarchy.getValue(now)
            : e.polygon.hierarchy;
          if (hierarchy && hierarchy.positions && hierarchy.positions.length) {
            e.polygon.hierarchy = flattenHierarchy(hierarchy);
          }
        } catch (err) {}

        e.polygon.perPositionHeight = false;

        e.polygon.height = 0.0;
        e.polygon.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;

        e.polygon.extrudedHeight = h;
        e.polygon.extrudedHeightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;

        e.polygon.outline = false;
        e.polygon.material = Cesium.Color.LIGHTGRAY.withAlpha(0.75);

        // ‚úÖ Tag for click-details panel (show building height)
        e.assetType = "building";
        e.buildingHeight = h;
        e.heightSource = hSrc;
        e.assetId = propAny(props, ["id","ID","identificatie","Identificatie","bag_id","BAG_ID","pand_id","Pand_ID","pandid","PANDID","building_id","Building_ID"]);
        const bName = propAny(props, ["name","Name","building_name","Building_Name","pandnaam","PandNaam"]);
        e.assetName = bName || (e.assetId ? ("Building " + e.assetId) : "Building");


        extruded += 1;
      }

      viewer.dataSources.add(ds);
      layers["buildings"] = ds;

      console.log(`‚úÖ LoD1 buildings loaded: ${entities.length} entities (${extruded} extruded)`);

      viewer.scene.globe.depthTestAgainstTerrain = false;

      await viewer.flyTo(ds, { offset: new Cesium.HeadingPitchRange(0, -0.55, 9000) });

    } catch (e) {
      console.error("Buildings load error", e);
      alert(
        "Failed to load LoD1 buildings.\n" +
        "1) Put 'mujib_lod1.geojson' next to index.html\n" +
        "2) Run using Live Server (not file://)\n" +
        "3) If it is too heavy, try 'mujib_lod1_simplified.geojson' or 3D Tiles."
      );
    }
  }

  // ============================
  // MAP TOGGLE (Œî alternates for numeric metrics only)
  // ============================
  function toggleHeatmap() {
    if (!layers['subbasins']) { alert("Subbasins are still loading..."); return; }
    if (!scenarioData) { alert("Scenario JSON still loading..."); return; }

    heatmapOn = !heatmapOn;

    if (heatmapOn) {
      if (metricSelect.value !== "decision") {
        isDeltaMode = !isDeltaMode;
      } else {
        isDeltaMode = false;
      }
      applyMapStyle();
    } else {
      resetSubbasinColors();
    }
  }

  // ============================
  // CHART + CONTROLS
  // ============================
  function refreshAll() {
    if (currentSubbasinId != null) updateChart(currentSubbasinId);
    if (heatmapOn) {
      if (metricSelect.value === "decision") isDeltaMode = false;
      applyMapStyle();
    }
  }

  function updateChart(subbasinId) {
    if (!scenarioData) { alert("Scenario data still loading..."); return; }

    const metric = metricSelect.value;
    const chartMetric = (metric === "decision") ? "runoff" : metric;

    const pack = getWhatifObject(subbasinId);
    const wKey = pack?.wKey || "dP0_dT0";
    const wObj = pack?.wObj;
    const node = pack?.node;

    const monthly = wObj?.monthly || node?.monthly;

    const sNames = ["baseline", "marab", "vallerani", "combined"];
    const colors = {
      baseline: "#FBC02D",
      marab: "#66BB6A",
      vallerani: "#29B6F6",
      combined: "#AB47BC"
    };

    const labels = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    const datasets = sNames.map(s => ({
      label: `${s.toUpperCase()} (${wKey})`,
      data: monthly?.[s]?.[chartMetric] || [],
      borderColor: colors[s],
      backgroundColor: colors[s] + "22",
      tension: 0.35,
      fill: false
    }));

    const title = `SUB ${subbasinId} | ${chartMetric.toUpperCase()} | what-if ${wKey}`;

    const ctx = document.getElementById('swatChart').getContext('2d');
    if (myChart) myChart.destroy();

    myChart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: title, color: 'white', font: { size: 14 } },
          legend: { labels: { color: 'white' } }
        },
        scales: {
          y: { ticks: { color:'#ccc' }, grid: { color:'#333' } },
          x: { ticks: { color:'#ccc' }, grid: { color:'#333' } }
        }
      }
    });
  }

  // ============================
  // CLICK INTERACTION (subbasins + assets)
  // ============================
  viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
    // drillPick so buildings don't block clicks
    const picks = viewer.scene.drillPick(movement.position, 10);

    let asset = null;
    let building = null;
    let sub = null;

    for (const p of picks) {
      const e = p?.id;
      if (!e) continue;

      if (e.assetType === "flood_station" || e.assetType === "dam" || e.assetType === "desert_dam") {
        asset = e;
        break; // prioritize assets over subbasins
      }

      if (e.assetType === "building" && !building) {
        building = e;
      }

      if (e.subbasinId != null && !sub) {
        sub = e;
      }
    }

    // 1) Assets
    if (asset) {
      viewer.selectedEntity = asset;

      if (asset.assetType === "flood_station") {
        clickStatus.textContent = `Flood Station ${asset.assetId || ''}`.trim();
        clickStatus.className = 'ok';
        renderFloodStationPanel(asset);
        return;
      }

      if (asset.assetType === "dam") {
        clickStatus.textContent = `Dam ${asset.assetId || ''}`.trim();
        clickStatus.className = 'ok';
        renderDamPanel(asset);
        return;
      }

      if (asset.assetType === "desert_dam") {
        clickStatus.textContent = `Desert Dam ${asset.assetId || ''}`.trim();
        clickStatus.className = 'ok';
        renderDesertDamPanel(asset);
        return;
      }
    }

    // 2) Buildings
    if (building) {
      viewer.selectedEntity = building;
      const h = Number.isFinite(building.buildingHeight) ? building.buildingHeight : null;
      clickStatus.textContent = `Building${h !== null ? (' ‚Ä¢ H ' + h + ' m') : ''}`;
      clickStatus.className = 'ok';
      renderBuildingPanel(building);
      return;
    }

    // 3) Subbasins (same behavior as before)
    if (sub && sub.subbasinId != null) {
      currentSubbasinId = sub.subbasinId;

      clickStatus.textContent = `SUB ${currentSubbasinId} ‚úÖ`;
      clickStatus.className = 'ok';

      hideAssetPanel(); // keep focus on chart
      document.getElementById('chartPanel').style.display = 'block';
      updateChart(currentSubbasinId);
      return;
    }

    // 3) Nothing useful picked
    clickStatus.textContent = `none`;
    clickStatus.className = 'warn';
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  // ============================
  // UI Accordion + Init
  // ============================
  const acc = document.getElementsByClassName("category-btn");
  for (let i = 0; i < acc.length; i++) {
    acc[i].addEventListener("click", function() {
      if (this.classList.contains('analysis-btn')) return;
      this.classList.toggle("active");
      const panel = this.nextElementSibling;
      panel.style.maxHeight = panel.style.maxHeight ? null : panel.scrollHeight + "px";
    });
  }

  // Load data + layers
  loadScenarioData();

  toggleLayer('basin', true);
  toggleLayer('rivers', true);
  toggleLayer('dams', true);
  toggleLayer('sites', true);
  toggleLayer('subbasins', true);

  // ‚úÖ since checkboxes are checked by default, load these too
  toggleLayer('floodStations', true);
</script>
</body>
</html>
