<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mujib Basin Digital Twin</title>

  <!-- Prevent 404 errors for the missing favicon during development -->
  <link rel="icon" href="data:,">

  <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <!-- CSV parsing helper for robust client-side ingestion (handles quoted commas) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Helper script to correct CRS mismatches when projected GeoJSON exports need converting to WGS84 -->
  <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.min.js"></script>

  <style>
    * { box-sizing: border-box; }

/* Dark scrollbar styling (keeps scrolling enabled; matches dashboard theme) */
* { scrollbar-width: thin; scrollbar-color: rgba(69,162,158,0.55) rgba(11,12,16,0.88); }
*::-webkit-scrollbar{ width: 10px; height: 10px; }
*::-webkit-scrollbar-track{ background: rgba(11,12,16,0.88); }
*::-webkit-scrollbar-thumb{
  background-color: rgba(69,162,158,0.42);
  border-radius: 999px;
  border: 2px solid rgba(11,12,16,0.88);
}
*::-webkit-scrollbar-thumb:hover{ background-color: rgba(102,252,241,0.35); }

    body { margin: 0; overflow: hidden; font-family: 'Roboto','Segoe UI',sans-serif; background:#0b0c10; }
    button, input, select { font-family: inherit; }
    body { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }


    #sidebar{
      position:absolute; top:0; left:0; width:380px; height:100vh;
      background:#1f2833; color:#c5c6c7; z-index:10;
      box-shadow:4px 0 10px rgba(0,0,0,0.5); display:flex; flex-direction:column;
    }

    #header{ display:none; }
    h1{ margin:0; color:#66fcf1; font-size:22px; letter-spacing:1px; }
    h2{ margin:5px 0 0; font-size:14px; color:#888; font-weight:normal; }

    #statusLine{
      margin-top:10px; padding:8px 10px; border:1px solid rgba(102,252,241,0.35);
      border-radius:6px; background:rgba(31,40,51,0.6);
      font-size:12px; color:#c5c6c7; line-height:1.4;
    }
    .ok{ color:#66fcf1; }
    .warn{ color:#ffcc80; }
    .bad{ color:#ff8a80; }

    .catalogue-container{ flex:1; overflow-y:auto; padding:10px; }

    .category-btn{
      background:#45a29e; color:white; cursor:pointer; padding:12px; width:100%;
      text-align:left; border:none; outline:none; transition:0.4s;
      font-weight:bold; margin-top:5px; border-radius:4px; display:flex; justify-content:space-between;
    }
    .category-btn:after{ content:'+'; font-weight:bold; float:right; }
    .category-btn.active{ background:#66fcf1; color:#0b0c10; }
    .category-btn.active:after{ content:'-'; }

    .analysis-btn{
      background:#1f4068; border:1px solid #66fcf1; color:#66fcf1;
      margin-top:15px; text-align:center; justify-content:center; transition:0.3s;
    }
    .analysis-btn:hover{ background:#66fcf1; color:#0b0c10; cursor:pointer; }
    .analysis-btn:after{ content:''; }

    .layer-panel{
      padding:0 10px; background:#28303b; max-height:0; overflow:hidden;
      transition:max-height 0.2s ease-out; margin-bottom:5px; border-radius:0 0 4px 4px;
    }

    .layer-item{
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 0; border-bottom:1px solid #333; font-size:13px;
    }
    .layer-info{ display:flex; align-items:center; gap:10px; }

    .icon-box{ width:12px; height:12px; border:1px solid #fff; display:inline-block; }
    .icon-line{ width:20px; height:3px; display:inline-block; }
    .icon-dot{ width:10px; height:10px; border-radius:50%; display:inline-block; }
    input[type=checkbox]{ transform:scale(1.2); cursor:pointer; accent-color:#66fcf1; }

    /* ===== Chart panel layout (fixed) ===== */
    #chartPanel{
      height:360px;
      background:#0b0c10;
      border-top:2px solid #45a29e;
      padding:10px;
      display:none;
      position:relative;

      overflow-y:auto;      /* ‚úÖ allow scroll */
      overflow-x:hidden;
      scroll-behavior:smooth;
    }

    #chartHeader{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding-bottom:10px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      margin-bottom:10px;
    }

    #controlsRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex: 1 1 auto;
      flex-wrap:wrap;
      min-width:0;
    }

    select.dtSelect{
      padding:8px;
      background:#1f2833;
      color:white;
      border:1px solid #45a29e;
      border-radius:6px;
      font-weight:bold;
      flex: 1 1 140px;
      min-width:140px;
      max-width:100%;
    }

    #closeChartBtn{
      padding:8px 12px;
      border-radius:6px;
      border:1px solid rgba(255,255,255,0.25);
      background:#222;
      color:#fff;
      cursor:pointer;
      font-weight:bold;
      flex:0 0 auto;
      white-space:nowrap;
    }
    #closeChartBtn:hover{ background:#333; }

    #swatChart{
      width:100% !important;
      height: calc(360px - 10px - 10px - 62px) !important;
    }

    


    /* ===== Chart tabs (Hydrology / Climate) ===== */
    #chartTabs{
      display:flex;
      gap:8px;
      margin:6px 0 10px;
    }
    .chartTabBtn{
      flex:1 1 auto;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(102,252,241,0.35);
      background: rgba(31,40,51,0.55);
      color:#c5c6c7;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      letter-spacing:0.02em;
      user-select:none;
    }
    .chartTabBtn:hover{ background: rgba(255,255,255,0.06); }
    .chartTabBtn.active{
      background: rgba(102,252,241,0.15);
      color:#66fcf1;
      border-color: rgba(102,252,241,0.65);
    }
    .chartTabPane{ width:100%; }
    #hydrologyNotice{
      margin:8px 0;
      padding:10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,0.08);
      background: rgba(31,40,51,0.35);
      color:#ffcc80;
      font-size:12px;
      line-height:1.35;
      display:none;
    }
    #climateHeader{
      padding:10px;
      border:1px solid rgba(255,255,255,0.08);
      border-radius:10px;
      background: rgba(31,40,51,0.35);
    }
    #climateTitle{
      font-weight:900;
      color:#66fcf1;
      font-size:12px;
      letter-spacing:0.04em;
      text-transform:uppercase;
    }
    #climateStatus{
      margin-top:6px;
      font-size:12px;
      color:#c5c6c7;
      line-height:1.35;
      word-break:break-word;
    }
    .climatePills{ display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .climatePill{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(102,252,241,0.28);
      background: rgba(0,0,0,0.18);
      color:#e6e6e6;
      white-space:nowrap;
    }
    #climateChart{
      width:100% !important;
      height:260px !important;
    }

    /* ===== Soil moisture (ERA5-Land) chart panel ===== */
    #soilHeader{
      padding:10px;
      border:1px solid rgba(255,255,255,0.08);
      border-radius:10px;
      background: rgba(31,40,51,0.35);
    }
    #soilTitle{
      font-weight:900;
      color:#66fcf1;
      font-size:12px;
      letter-spacing:0.04em;
      text-transform:uppercase;
    }
    #soilStatus{
      margin-top:6px;
      font-size:12px;
      color:#c5c6c7;
      line-height:1.35;
      word-break:break-word;
    }
    #soilChart{
      width:100% !important;
      height:260px !important;
    }
    #soilClassStrip{ border-radius:6px; overflow:hidden; }
    #soilClassStrip > div{ flex:1; min-width:1px; }

    /* ===== NDVI expandable panel and info styles ===== */
    .ndvi-main{
      margin-top:10px;
      padding:10px 0;
      border-top:1px solid rgba(255,255,255,0.08);
      font-weight:700;
      color:#66fcf1;
      font-size:14px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      cursor:pointer;
    }
    .ndvi-main::after{
      content:'+';
      font-weight:bold;
      color:#66fcf1;
    }
    .ndvi-main.active::after{
      content:'-';
    }
    .ndvi-panel{
      display:none;
      padding-left:10px;
      border-left:1px solid rgba(255,255,255,0.08);
      margin-bottom:8px;
    }
    .info-icon{
      margin-left:6px;
      /* Unified info icon styling.  A small circular button with cyan ‚Äúi‚Äù
         inside.  This style will be reused for all information buttons
         across the dashboard (NDVI, mini weather, soil moisture, etc.). */
      color:#66fcf1;
      background:rgba(255,255,255,0.12);
      border-radius:50%;
      width:18px;
      height:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      /* Use a normal weight and a generic sans‚Äëserif font so the lowercase
         ‚Äúi‚Äù looks distinct from an uppercase ‚ÄúI‚Äù. */
      font-weight:400;
      font-family: Arial, sans-serif;
      font-size:12px;
      line-height:1;
      cursor:pointer;
    }
    .info-icon:hover{
      background:rgba(102,252,241,0.3);
    }
    .info-content{
      display:none;
      font-size:12px;
      color:#b9c6cc;
      margin-left:18px;
      margin-top:4px;
      margin-bottom:4px;
      line-height:1.35;
    }

    /* Hide Cesium UI elements (timeline, animation, scale/credits, compass, etc.) for a clean dashboard.
       Note: we deliberately do not hide the base layer picker so that users can switch between
       different base maps (e.g. ArcGIS Imagery, OpenStreetMap). */
    .cesium-viewer-bottom,
    /* .cesium-viewer-toolbar is intentionally shown so that the base layer picker can appear.
       Other toolbar buttons are disabled via viewer options. */
    .cesium-viewer-cesiumWidgetContainer .cesium-navigationContainer,
    .cesium-navigationControlsContainer,
    .cesium-navigation-help-button,
    .cesium-navigation-help,
    .cesium-navigation-help-button-wrapper,
    .cesium-animationContainer,
    .cesium-timeline,
    /* .cesium-baseLayerPicker-container is intentionally omitted from this list to keep the base
       layer picker visible. */
    .cesium-credit-container,
    .cesium-widget-credits,
    .cesium-distance-legend,
    .cesium-distanceLegend,
    .cesium-performanceDisplay {
      display: none !important;
    }

#legendPanel{
      position:absolute; bottom:90px; right:30px; width:300px;
      background:rgba(11,12,16,0.85); padding:15px; border-radius:8px;
      color:white; display:none; z-index:50; border:1px solid #66fcf1;
      font-family:sans-serif;
    }
    .gradient-bar{
      height:15px; width:100%; margin:8px 0; border-radius:3px;
      background:linear-gradient(to right, #ccc, #81D4FA, #29B6F6, #0277BD, #0D47A1);
    }
    .legend-labels{ display:flex; justify-content:space-between; font-size:11px; color:#ccc; }

    /* ============================
       NDVI Legend
       A custom legend for the NDVI overlays (Baseline, Recent and Delta).  It
       appears in the bottom‚Äëright corner of the map when any NDVI layer is
       active.  We choose a bottom offset greater than the assistant toggle
       (which sits at bottom:20px) to avoid overlap. */
    #ndviLegend{
      position:absolute;
      bottom:90px;
      right:20px;
      min-width:200px;
      max-width:260px;
      background: rgba(11,12,16,0.85);
      border: 1px solid rgba(102,252,241,0.45);
      border-radius: 8px;
      padding: 10px;
      z-index:60;
      color:#e6e6e6;
      font-size:11px;
      display:none;
    }
    #ndviLegend .ndviLegendTitle{
      font-weight:700;
      margin-bottom:6px;
      color:#66fcf1;
      font-size:12px;
    }
    #ndviLegend .ndviLegendItem{
      display:flex;
      align-items:center;
      margin-bottom:4px;
    }
    #ndviLegend .ndviSwatch{
      width:14px;
      height:14px;
      border-radius:3px;
      margin-right:8px;
      flex:0 0 auto;
    }

    #ndviLegend .ndviLegendContent {
      /* space out legend items from the title */
    }

    /* ===== Right-side asset details panel ===== */
    #assetPanel{
      position: fixed;
      top: var(--topbar-h);
      right: 0;
      width: var(--assetpanel-w);
      height: calc(100vh - var(--topbar-h));
      background: rgba(11,12,16,0.96);
      border-left: 1px solid rgba(102,252,241,0.35);
      box-shadow: -10px 0 28px rgba(0,0,0,0.55);
      color: #e6e6e6;
      z-index: 9800;
      display: none;
      overflow: hidden;
      backdrop-filter: blur(6px);
    }
    #assetPanelHeader{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px 10px 12px;
      border-bottom:1px solid rgba(255,255,255,0.08);
      background: rgba(31,40,51,0.55);
    }
    #assetPanelTitle{
      font-weight:800;
      color:#66fcf1;
      font-size:14px;
      line-height:1.25;
      word-break:break-word;
    }
    #assetPanelSubtitle{
      margin-top:4px;
      font-size:12px;
      color:#aab;
      line-height:1.25;
      word-break:break-word;
    }
    #assetPanelClose{
      border:1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.25);
      color:#fff;
      border-radius:8px;
      padding:6px 10px;
      cursor:pointer;
      font-weight:bold;
      flex:0 0 auto;
    }
    #assetPanelClose:hover{ background: rgba(255,255,255,0.08); }

    #assetPanelBody{
      padding:12px;
      overflow:auto;
      height: calc(100% - 58px);
      max-height: calc(100% - 58px);
    }
    .assetBadges{ display:flex; flex-wrap:wrap; gap:8px; margin:10px 0 12px; }
    .assetBadge{
      font-size:11px; padding:5px 8px; border-radius:999px;
      border:1px solid rgba(102,252,241,0.35);
      background: rgba(31,40,51,0.55);
      color:#cfe;
      white-space:nowrap;
    }
    .assetActions{ display:flex; gap:8px; flex-wrap:wrap; margin:0 0 12px; }
    .assetBtn{
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(102,252,241,0.45);
      background: rgba(69,162,158,0.15);
      color:#66fcf1;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
    }
    .assetBtn:hover{ background: rgba(102,252,241,0.18); }
    .kvGrid{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 10px; }
    .kv{
      background: rgba(31,40,51,0.45);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      padding:10px;
      min-width:0;
    }
    .kv .k{ font-size:11px; color:#9aa; margin-bottom:4px; }
    .kv .v{ font-size:13px; color:#fff; word-break:break-word; }
    .assetSectionTitle{
      margin:14px 0 8px;
      font-size:12px;
      color:#c5c6c7;
      text-transform:uppercase;
      letter-spacing:0.08em;
    }
    details.assetDetails{
      margin-top:12px;
      background: rgba(31,40,51,0.35);
      border:1px solid rgba(255,255,255,0.06);
      border-radius:10px;
      padding:8px 10px;
    }
    details.assetDetails summary{
      cursor:pointer;
      color:#66fcf1;
      font-weight:700;
      font-size:12px;
      outline:none;
    }
    pre.assetJson{
      white-space:pre-wrap;
      word-break:break-word;
      font-size:11px;
      color:#ddd;
      margin:10px 0 0;
    }
    @media (max-width: 1100px){
      :root{ --assetpanel-w: 320px; }
    }

    #cesiumContainer{ width:100%; height:100vh; margin-left:380px; width:calc(100% - 380px); }
  
    /* ============================
       Climate chart: expand + modal
       ============================ */
    #climateHeader { position: relative; }
    .miniActionBtn{
      position: relative;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(17, 24, 39, 0.55);
      color: #c5c6c7;
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 12px;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      user-select: none;
      white-space: nowrap;
    }
    .miniActionBtn:hover{ background: rgba(17, 24, 39, 0.72); border-color: rgba(102,252,241,0.35); transform: translateY(-1px); }
    .miniActionBtn:active{ transform: translateY(0px); }
    #climateExpandBtn{
      position:absolute;
      top: 10px;
      right: 10px;
    }
    #simRainBtn{
      position:absolute;
      top: 10px;
      right: 110px;
    }
    #simRainBtn.active{
      border-color: rgba(255,204,128,0.75);
      background: rgba(255,204,128,0.10);
      color: #ffcc80;
    }

    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 18px;
    }
    .modalCard{
      width: min(1100px, 96vw);
      height: min(720px, 86vh);
      background: rgba(11, 14, 18, 0.98);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.6);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .modalHeader{
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .modalTitle{
      font-weight: 600;
      color: #e5e7eb;
      font-size: 14px;
      letter-spacing: 0.2px;
    }
    .modalActions{ display:flex; gap:10px; align-items:center; }
    .modalBody{
      position: relative;
      flex: 1;
      padding: 10px 14px 6px 14px;
    }
    #climateChartBig{
      width: 100% !important;
      height: 100% !important;
    }

    /* Ensure the full‚Äëview soil moisture chart fills the available modal space. Without
       an explicit size, the canvas may collapse and appear as a black rectangle. */
    #soilChartBig{
      width: 100% !important;
      height: 100% !important;
    }
    .modalHint{
      padding: 10px 14px 14px 14px;
      font-size: 12px;
      color: #9aa;
      border-top: 1px solid rgba(255,255,255,0.08);
    }

  
    /* ===== NDVI value tooltip (no map overlay) ===== */
    #ndviTooltip{
      position:absolute;
      z-index:9999;
      display:none;
      background:rgba(11,12,16,0.92);
      border:1px solid rgba(102,252,241,0.35);
      padding:10px 12px;
      border-radius:12px;
      color:#e8e8e8;
      pointer-events:none;
      backdrop-filter: blur(4px);
      font-size:14px;
      min-width:160px;
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
    }
    #ndviTooltip .k{
      color:#66fcf1;
      font-weight:700;
    }
    #ndviTooltip .ndvi-label{
      margin-top:4px;
      font-size:12px;
      color:#b9c6cc;
      line-height:1.25;
    }

  
  /* ============================
     WEATHER TAB
  ============================ */
  .weatherControls{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-top:10px;
  }
  .weatherCtrl{
    flex:1 1 160px;
    min-width:160px;
    background:rgba(31,40,51,0.35);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:10px;
    padding:10px;
  }
  .weatherCtrl label{
    display:block;
    font-size:11px;
    color:#9aa;
    margin-bottom:6px;
  }
  .weatherCtrl input{
    width:100%;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.12);
    background:rgba(0,0,0,0.22);
    color:#fff;
    font-size:12px;
    outline:none;
  }
  .weatherCtrlBtn{
    flex:0 0 120px;
    min-width:120px;
    display:flex;
    flex-direction:column;
    justify-content:flex-end;
  }
  .weatherMetaRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    margin-top:10px;
  }
  .weatherMeta{
    flex:1 1 160px;
    min-width:160px;
    font-size:12px;
    color:#c5c6c7;
    background:rgba(0,0,0,0.16);
    border:1px solid rgba(255,255,255,0.06);
    border-radius:10px;
    padding:8px 10px;
  }
  .weatherFlag{
    flex:1 1 220px;
    min-width:220px;
    font-size:12px;
    font-weight:900;
    border-radius:10px;
    padding:8px 10px;
    border:1px solid rgba(255,255,255,0.08);
  }
  .weatherFlag.neutral{ background:rgba(255,255,255,0.05); color:#c5c6c7; }
  .weatherFlag.ok{ background:rgba(0,255,180,0.10); color:#66fcf1; }
  .weatherFlag.warn{ background:rgba(255,120,0,0.12); color:#ffb86b; }
  .weatherFlag.alert{ background:rgba(255,0,80,0.14); color:#ff6b9a; }


    /* ============================
       MINI WEATHER WIDGET (Open-Meteo)
       Simple top widget + details modal (no charts)
    ============================ */
    .miniWeatherWidget{
      position: fixed;
      top: 10px;
      right: 100px;
      z-index: 9998;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 10px;
      background: rgba(11, 14, 18, 0.86);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      color: #e5e7eb;
      user-select: none;
      cursor: pointer;
      max-width: min(520px, 92vw);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .mwLeft{
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 120px;
    }
    .mwLoc{
      font-size: 11px;
      color: rgba(197, 198, 199, 0.95);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 220px;
    }
    .mwTemp{
      font-size: 14px;
      font-weight: 900;
      color: #ffffff;
      letter-spacing: 0.2px;
    }
    .mwMid{
      display: flex;
      flex-direction: column;
      gap: 6px;
      flex: 1;
      min-width: 180px;
    }
    .mwEvent{
      font-size: 12px;
      color: rgba(229,231,235,0.92);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .mwBar{
      height: 6px;
      width: 100%;
      background: rgba(255,255,255,0.10);
      border-radius: 999px;
      overflow: hidden;
    }
    .mwBarFill{
      height: 100%;
      width: 0%;
      background: rgba(102,252,241,0.85);
    }
    .mwNowMini{
      font-size: 11px;
      font-weight: 700;
      color: #22d3ee;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .mwInfoTooltip{
      position: fixed;
      top: 60px;
      right: 16px;
      width: 280px;
      max-width: calc(100vw - 32px);
      background: rgba(15,23,42,0.96);
      border: 1px solid rgba(148,163,184,0.25);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.55);
      z-index: 9999;
      display: none;
      backdrop-filter: blur(10px);
    }
    .mwInfoTitle{
      font-size: 12px;
      font-weight: 800;
      color: rgba(226,232,240,0.95);
      margin-bottom: 6px;
    }
    .mwInfoBody{
      font-size: 11px;
      line-height: 1.35;
      color: rgba(226,232,240,0.78);
    }
    .mwInfoBody a{
      color: #22d3ee;
      text-decoration: none;
    }
    .mwInfoBody a:hover{ text-decoration: underline; }

    /* Reuse the same style as .info-icon for the mini weather info button.  This
       gives a consistent look across NDVI, soil and weather tooltips. */
    .mwInfoBtn{
      width: 18px;
      height: 18px;
      border-radius:50%;
      border: none;
      background:rgba(255,255,255,0.12);
      color:#66fcf1;
      font-weight:bold;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      cursor:pointer;
    }
    .mwInfoBtn:hover{
      background:rgba(102,252,241,0.3);
    }

    .mwModalWrap{
      width: min(760px, 96vw);
      height: min(640px, 86vh);
    }
    .mwMeta{
      margin-top: 6px;
      font-size: 11px;
      color: rgba(197,198,199,0.95);
    }
    .mwNowLine{
      margin-top: 10px;
      font-size: 12px;
      color: #22d3ee;
      font-weight: 700;
    }
    .mwModalTop{
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .mwModalCtrl label{
      display: block;
      font-size: 11px;
      color: rgba(197,198,199,0.95);
      margin-bottom: 4px;
    }
    .mwTable{
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      font-size: 12px;
    }
    .mwTable td{
  color: rgba(229,231,235,0.95);  /* <-- this controls Date/Precip/Temp text */
}
    }
    .mwTable th{
      text-align: left;
      color: rgba(197,198,199,0.95);
      font-weight: 800;
      font-size: 11px;
      letter-spacing: 0.2px;
    }
    .mwStatus{
      margin-top: 10px;
      font-size: 11px;
      color: rgba(197,198,199,0.95);
    }



    /* ============================
   PRODUCT HEADER (TOP BAR)
   ============================ */
:root{ --topbar-h: 70px; --assetpanel-w: 380px; }

#topbar{
  position: fixed;
  top: 0; left: 0; right: 0;
  height: var(--topbar-h);
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  padding: 0 14px;
  background: rgba(11,12,16,0.92);
  border-bottom: 1px solid rgba(102,252,241,0.28);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  z-index: 9900;
  overflow: visible; /* allow Cesium basemap dropdown to open */
  gap: 10px;
}

#topbarLeft{
  display:flex;
  align-items:center;
  gap:12px;
  min-width:0;
}

#topbarTitleWrap{
  display:flex;
  flex-direction:column;
  justify-content:center;
  min-width:0;
  /* Keep enough vertical line box space so descenders (g/j/p/y) are not clipped */
  line-height: normal;
  padding: 2px 0;
}

#topbarTitle{
  font-size: 18px;
  font-weight: 900;
  letter-spacing: 0.4px;
  color: #66fcf1; /* teal */
  line-height: 1.25;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 520px;
}

#topbarSubtitle{
  margin-top: 4px;
  font-size: 12px;
  font-weight: 700;
  color: #ffffff;
  opacity: 0.92;
  line-height: 1.25;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 520px;
}

/* Top bar icon button (Home / Reset view) */
.topbarIconBtn{
  width: 30px;
  height: 30px;
  border: none;
  background: transparent;
  padding: 0;
  margin-right: 10px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
}
.topbarIconBtn svg{
  width: 28px;
  height: 28px;
  display: block;
}
.topbarIconBtn:hover{ transform: translateY(-1px); }
.topbarIconBtn:active{ transform: translateY(0px); }

#topbarCenter{
  display:flex;
  align-items:center;
  justify-content:center;
  min-width:0;
}

#topbarRight{
  display:flex;
  justify-content:flex-end;
  align-items:center;
  gap: 0;
  min-width:0;
}

#topbarCesiumSlot{
  display:flex;
  align-items:center;
  gap:10px;
}

/* Shift main layout down to make room for the top bar (no other logic changes) */
#sidebar{
  top: var(--topbar-h) !important;
  height: calc(100vh - var(--topbar-h)) !important;
}
#cesiumContainer{
  position:absolute !important;
  top: var(--topbar-h) !important;
  left: 380px !important;
  right: 0 !important;
  bottom: 0 !important;
  width: auto !important;
  height: auto !important;
  margin-left: 0 !important;
}

/* Reserve space for the right-side details panel when it is open (no overlap with the map). */
body.hasAssetPanel #cesiumContainer{
  right: var(--assetpanel-w) !important;
}
body.hasAssetPanel #legendPanel{
  right: calc(var(--assetpanel-w) + 30px) !important;
}
body.hasAssetPanel #ndviLegend{
  right: calc(var(--assetpanel-w) + 20px) !important;
}
body.hasAssetPanel .mwInfoTooltip{
  right: calc(var(--assetpanel-w) + 14px) !important;
}


/* Compact, crisp mini weather widget (no transform scaling) */
#topbarRight .miniWeatherWidget{
  position: static !important;
  inset: auto !important;
  padding: 4px 6px !important;
  gap: 6px !important;
  border-radius: 12px !important;
  box-shadow: none !important;
  max-width: 340px !important;
  margin-right: 0 !important;
}
#topbarRight .mwLeft{ min-width: 76px !important; }
#topbarRight .mwLoc{ font-size: 9px !important; max-width: 120px !important; }
#topbarRight .mwTemp{ font-size: 11px !important; }
#topbarRight .mwMid{ min-width: 130px !important; gap: 2px !important; }
#topbarRight .mwNowMini{ font-size: 9px !important; margin-bottom: 0 !important; }
#topbarRight .mwEvent{ font-size: 9px !important; }
#topbarRight .mwBar{ height: 4px !important; }
#topbarRight .mwInfoBtn{ width: 14px !important; height: 14px !important; font-size: 9px !important; }

/* Weather info tooltip: drop below the top bar */
.mwInfoTooltip{
  top: calc(var(--topbar-h) + 10px) !important;
  right: 14px !important;
}

/* Basemap picker: keep it visually tight inside the header */
#topbarCesiumSlot .cesium-baseLayerPicker-container{ margin: 0 !important; }
#topbarCesiumSlot .cesium-baseLayerPicker-selected{ border-radius: 12px !important; overflow: hidden; }
#topbarCesiumSlot .cesium-baseLayerPicker-dropDown{ border-radius: 14px !important; }
</style>
</head>

<body>

  <!-- Product header (top bar) -->
  <div id="topbar" role="banner" aria-label="Product header">
    <div id="topbarLeft">
      <button id="overviewBtn" class="topbarActionBtn" type="button" onclick="openOverviewModal()">Overview</button>

      <div id="topbarTitleWrap" aria-label="Dashboard title">
        <div id="topbarTitle">Mujib Basin Digital Twin</div>
        <div id="topbarSubtitle">Eco-Hydrological Decision Support</div>
      </div>
    </div>

    <div id="topbarCenter" aria-label="Basemap controls">
      <div id="topbarCesiumSlot" aria-label="Basemap picker"></div>
    </div>

    <div id="topbarRight" aria-label="Utilities">
      <!-- Home / Reset view (returns camera to the initial overview) -->
      <button id="homeBtn" class="topbarIconBtn" type="button" title="Home (Reset view)" aria-label="Home (Reset view)" onclick="goHomeView(event)">
        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
          <circle cx="12" cy="12" r="10.5" fill="rgba(255,255,255,0.92)" stroke="rgba(0,0,0,0.28)" stroke-width="1" />
          <path d="M8.2 11.3L12 8.5l3.8 2.8v5.0c0 .6-.5 1.1-1.1 1.1h-2.1v-3.2H11.4v3.2H9.3c-.6 0-1.1-.5-1.1-1.1v-5.0z"
                fill="none" stroke="#111827" stroke-width="1.6" stroke-linejoin="round" stroke-linecap="round" />
        </svg>
      </button>
<!-- Mini weather widget (Open-Meteo). Click to open details. -->
<div id="miniWeatherWidget" class="miniWeatherWidget" onclick="openWeatherModal()" title="Weather forecast (click for details)">
  <div class="mwLeft">
    <div class="mwLoc" id="mwLoc">Weather</div>
    <div class="mwTemp" id="mwTemp">‚Äî¬∞C</div>
  </div>
  <div class="mwMid">
    <div class="mwNowMini" id="mwNowMini">Wind ‚Äî km/h ‚Ä¢ Humid ‚Äî%</div>
    <div class="mwEvent" id="mwEvent">Next precipitation: ‚Äî</div>
    <div class="mwBar"><div id="mwBarFill" class="mwBarFill"></div></div>
  </div>
  <button class="mwInfoBtn" type="button" onclick="toggleMwInfo(event)" aria-label="Weather details">i</button>
</div>
    </div>
  </div>

<!-- Overview modal -->
  <div id="overviewModal" class="modalOverlay" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="overviewModalTitle" onclick="if(event.target===this) closeOverviewModal();">
    <div class="modalCard overviewModalCard" role="document">
      <div class="modalHeader">
        <div id="overviewModalTitle" class="modalTitle">Dashboard Overview</div>
        <div class="modalActions">
          <button class="miniActionBtn" type="button" onclick="closeOverviewModal()" title="Close">‚úï</button>
        </div>
      </div>

      <div id="overviewBody" class="modalBody overviewBody">
        <div class="overviewIntro">
          <div class="overviewHeadline">Mujib Basin Digital Twin</div>
          <div class="overviewSubhead">Eco‚ÄëHydrological Decision Support</div>
          <p class="overviewText">
            This dashboard is a prototype eco‚Äëhydrological digital twin for the Mujib Basin. It combines spatial layers,
            hydrological model outputs and operational climate information to support exploration, comparison and
            scenario‚Äëbased discussion for water and land management.
          </p>
        </div>

        <div class="overviewGrid">
          <div class="overviewCardSmall">
            <div class="overviewCardTitle">What you can do</div>
            <ul class="overviewList">
              <li>Explore basin layers (boundary, rivers, dams, stations, buildings).</li>
              <li>Compare vegetation change using NDVI (baseline, recent, Œî).</li>
              <li>Review SWAT outputs for sub‚Äëbasins and compare interventions/scenarios.</li>
              <li>Check ERA5 precipitation and ERA5‚ÄëLand soil moisture context.</li>
              <li>Use the mini weather widget for short‚Äëterm forecast awareness.</li>
            </ul>
          </div>

          <div class="overviewCardSmall">
            <div class="overviewCardTitle">How to start</div>
            <ol class="overviewList">
              <li>Turn on <b>Basin Boundary</b> (default) to orient yourself.</li>
              <li>Open a category in the left panel and toggle layers as needed.</li>
              <li>Click a sub‚Äëbasin to populate the analysis panel and charts.</li>
              <li>Switch chart tabs (Hydrology / Climate / Soil) for details.</li>
            </ol>
          </div>
        </div>

        <details class="overviewDetails" open>
          <summary>Existing Hydrological Digital Twin</summary>
          <div class="overviewCases">
            <a class="overviewLinkBtn" href="https://digitaltwins.iwmi.org/innovations/limpopo-web-portal/" target="_blank" rel="noopener noreferrer">
              Limpopo Web Portal (IWMI)
              <span class="overviewLinkMeta">Digital twins platform example</span>
            </a>
            <a class="overviewLinkBtn" href="https://dtehydrology.org/" target="_blank" rel="noopener noreferrer">
              DTE Hydrology
              <span class="overviewLinkMeta">Hydrology digital twin community / resources</span>
            </a>
          </div>
        </details>

        <details class="overviewDetails">
          <summary>Related Publications &amp; Case Studies</summary>
          <div class="overviewCases">
            <a class="overviewLinkBtn" href="https://icarda.org/impact/impact-stories/vallerani-micro-water-harvesting" target="_blank" rel="noopener noreferrer" style="min-height:64px; padding:10px 12px; font-size:12.5px;">
              Vallerani Micro Water Harvesting
              <span class="overviewLinkMeta">ICARDA impact story on rangeland water harvesting</span>
            </a>
            <a class="overviewLinkBtn" href="https://icarda.org/publications/49986/suitability-mapping-micro-and-meso-scale-rain-water-harvesting-vegetation-based" target="_blank" rel="noopener noreferrer" style="min-height:64px; padding:10px 12px; font-size:12.5px;">
              Suitability Mapping for Rainwater Harvesting
              <span class="overviewLinkMeta">ICARDA publication (micro &amp; meso-scale, vegetation-based)</span>
            </a>
            <a class="overviewLinkBtn" href="https://icarda.org/publications/41697/modeling-based-performance-assessment-indigenous-macro-catchment-water" target="_blank" rel="noopener noreferrer" style="min-height:64px; padding:10px 12px; font-size:12.5px;">
              Modeling-based Performance Assessment
              <span class="overviewLinkMeta">ICARDA publication on indigenous macro-catchment harvesting</span>
            </a>
            <a class="overviewLinkBtn" href="https://icarda.org/research/innovations/strengthening-resilience-rangeland-watersheds-jordan" target="_blank" rel="noopener noreferrer" style="min-height:64px; padding:10px 12px; font-size:12.5px;">
              Strengthening Resilience in Jordan Watersheds
              <span class="overviewLinkMeta">ICARDA innovation page (Jordan rangeland watersheds)</span>
            </a>
          </div>
        </details>

        <div class="overviewNote">
          Note: This interface presents a decision‚Äësupport view. Forecast and model layers depend on the underlying datasets and assumptions used in this prototype.
        </div>
      </div>
    </div>
  </div>

<div id="sidebar">
    <div id="header">
      <h1>Wala-Mujib Twin</h1>
      <h2>Eco-Hydrological Decision Support</h2>
      <div id="statusLine">
        <div>Subbasins layer: <span id="subStatus" class="warn">loading‚Ä¶</span></div>
        <div>Scenarios JSON: <span id="jsonStatus" class="warn">loading‚Ä¶</span></div>
        <div>Hover: <span id="hoverStatus" class="warn">none</span></div>
        <div>Click: <span id="clickStatus" class="warn">none</span></div>
      </div>
    </div>

    <div class="catalogue-container">
      <button class="category-btn"> Water Resources</button>
      <div class="layer-panel">
        <div class="layer-item">
          <div class="layer-info">
            <div class="icon-box" style="border:1px dashed gold;"></div>
            SWAT Sub-Basins 
          </div>
          <input id="swatSubChk" type="checkbox" onchange="toggleSubbasinMode('swat', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info">
            <div class="icon-box" style="border:1px solid #ffb74d;"></div>
            All Sub-Basins (429)
          </div>
          <input id="allSubChk" type="checkbox" onchange="toggleSubbasinMode('all', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info"><div class="icon-box" style="border-color:orange;"></div> Basin Boundary</div>
          <input type="checkbox" checked onchange="toggleLayer('basin', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info"><div class="icon-line" style="background:#00E5FF;"></div> River Network</div>
          <input type="checkbox" onchange="toggleLayer('rivers', this.checked)">
        </div>
        <div class="layer-item">
          <div class="layer-info"><div class="icon-dot" style="background:#ff5252;"></div> Flood Stations</div>
          <input type="checkbox" onchange="toggleLayer('floodStations', this.checked)">
        </div>

        <div class="layer-item">
          <div class="layer-info"><div class="icon-dot" style="background:#5D4037;"></div> Dams</div>
          <input type="checkbox" onchange="toggleLayer('dams', this.checked)">
        </div>
      </div>

      <button class="category-btn"> Ecosystems & Restoration</button>
      <!-- Ecosystems & Restoration layers -->
      <div class="layer-panel">
        <!-- Desert dam inventory toggle -->
        <div class="layer-item">
          <div class="layer-info"><div class="icon-dot" style="background:gold;"></div> Desert Dams (Inventory)</div>
          <input type="checkbox" onchange="toggleLayer('sites', this.checked)">
        </div>

        <!-- NDVI group with expandable sublayers -->
        <div id="ndviMain" class="ndvi-main" onclick="toggleNdviPanel()">
          <span>NDVI</span>
        </div>
        <div id="ndviPanel" class="ndvi-panel">
          <!-- Baseline NDVI toggle -->
          <div class="layer-item">
            <div class="layer-info" style="display:flex; align-items:center; font-size:13px;">
              <span>Baseline NDVI <span style="color:#9aa;">(2015‚Äì2017)</span></span>
              <span class="info-icon" onclick="ndviInfoClick(event, 'info-baseline')">&#8505;</span>
            </div>
            <input id="ndviBaselineChk" type="checkbox" onchange="setNdviMode('baseline', this.checked)">
          </div>
          <div id="info-baseline" class="info-content">
            <div><b>Baseline NDVI (2015‚Äì2017)</b>: typical vegetation greenness during baseline period.</div>
            <div>The baseline map represents natural vegetation conditions before recent changes. Within this dataset (range&nbsp;‚âà&nbsp;0.04‚Äì0.22), higher values correspond to relatively denser vegetation, while lower values indicate bare soil or sparse vegetation.</div>
          </div>

          <!-- Recent NDVI toggle -->
          <div class="layer-item">
            <div class="layer-info" style="display:flex; align-items:center; font-size:13px;">
              <span>Recent NDVI <span style="color:#9aa;">(2023‚Äì2025)</span></span>
              <span class="info-icon" onclick="ndviInfoClick(event, 'info-recent')">&#8505;</span>
            </div>
            <input id="ndviRecentChk" type="checkbox" onchange="setNdviMode('recent', this.checked)">
          </div>
          <div id="info-recent" class="info-content">
            <div><b>Recent NDVI (2023‚Äì2025)</b>: current vegetation greenness.</div>
            <div>This recent map shows current vegetation conditions. Compare it to the baseline to spot increases or decreases in greenness. Within this dataset (range&nbsp;‚âà&nbsp;0.05‚Äì0.27), higher values correspond to relatively denser vegetation, whereas lower values indicate bare soil or sparse vegetation.</div>
          </div>

          <!-- Œî NDVI toggle -->
          <div class="layer-item">
            <div class="layer-info" style="display:flex; align-items:center; font-size:13px;">
              <span>Œî NDVI <span style="color:#9aa;">(2023‚Äì2025 ‚àí 2015‚Äì2017)</span></span>
              <span class="info-icon" onclick="ndviInfoClick(event, 'info-delta')">&#8505;</span>
            </div>
            <input id="ndviDeltaChk" type="checkbox" onchange="setNdviMode('delta', this.checked)">
          </div>
          <div id="info-delta" class="info-content">
            <div><b>Œî NDVI (Recent ‚àí Baseline)</b>: change over time.</div>
            <div>The Œî&nbsp;NDVI map highlights vegetation change between the baseline and recent periods. Positive values (greater than +0.01) indicate vegetation increase, negative values (less than ‚àí0.01) indicate vegetation decrease, and values near zero (between ‚àí0.01 and +0.01) indicate little or no change.</div>
          </div>

          <!-- NDVI legend for value interpretation -->
          <div style="margin-top:8px; font-size:12px; color:#9aa; line-height:1.3;">
            <b>NDVI value meaning</b>:<br/>
            0.04‚Äì0.06: very sparse / bare soil<br/>
            0.06‚Äì0.08: low vegetation<br/>
            0.08‚Äì0.10: sparse vegetation<br/>
            0.10‚Äì0.13: moderate vegetation<br/>
            &gt; 0.13: relatively high vegetation<br/>
            <span style="font-size:11px;color:#777;">Note: NDVI values are scaled to the observed range (vmin‚Äìvmax) for each period.</span><br/>
            <b>Œî interpretation</b>: Increase &gt; +0.01 ‚Ä¢ Decrease &lt; ‚àí0.01 ‚Ä¢ Stable ‚àí0.01 to +0.01
          </div>
        </div> <!-- end ndviPanel -->

      </div> <!-- end ecosystems layer-panel -->

      <button class="category-btn"> Built Environment</button>
      <div class="layer-panel">
        <div class="layer-item">
          <div class="layer-info">
            <div class="icon-box" style="background:#888;"></div>
            LoD1 Buildings
          </div>
          <input id="buildingsChk" type="checkbox" onchange="toggleLayer('buildings', this.checked)">
        </div>
</div>

    </div>

    <div id="chartPanel">
      <div id="chartHeader">
        <div id="controlsRow">
          <select id="scenarioSelect" class="dtSelect" onchange="refreshAll()">
            <option value="baseline">Baseline</option>
            <option value="marab">Marab</option>
            <option value="vallerani">Vallerani</option>
            <option value="combined">Combined</option>
          </select>

          <select id="whatifSelect" class="dtSelect" onchange="refreshAll()">
            <option value="auto">What-if (auto)</option>
          </select>

          <select id="metricSelect" class="dtSelect" onchange="refreshAll()">
            <option value="runoff">üåä Runoff (SURQ)</option>
            <option value="sediment">üìâ Sediment (SYLD)</option>
            <option value="groundwater">üíß Groundwater Recharge (PERC)</option>
            <option value="vegetation">üåø Vegetation / ET</option>
            <option value="decision">‚úÖ Decision: Best Intervention</option>
          </select>
        
          <select id="viewModeSelect" class="dtSelect" onchange="refreshAll()" title="Map display mode">
            <option value="absolute">View: Absolute</option>
            <option value="delta">View: Œî vs Baseline</option>
            <option value="pct">View: %Œî vs Baseline</option>
          </select>
</div>

        <button id="closeChartBtn" onclick="document.getElementById('chartPanel').style.display='none'">
          Close ‚úï
        </button>
      </div>

      
      <div id="chartTabs" role="tablist" aria-label="Charts">
        <button id="tabHydrology" class="chartTabBtn active" type="button" onclick="setChartTab('hydrology')">Hydrology (SWAT)</button>
        <button id="tabClimate" class="chartTabBtn" type="button" onclick="setChartTab('climate')">Climate (ERA5)</button>
        <button id="tabSoil" class="chartTabBtn" type="button" onclick="setChartTab('soil')">Soil Moisture</button>
      </div>

      <div id="hydrologyTab" class="chartTabPane">
        <div id="hydrologyNotice">Hydrology scenarios are available only for the SWAT (71) sub-basin layer.</div>
        
        <div id="subInfoLine" style="margin:8px 0 10px; font-size:12px; color:#c5c6c7; line-height:1.35;">
          Click a sub-basin to view details.
        </div>

        <div id="kpiRow" style="display:none; gap:8px; flex-wrap:wrap; margin:0 0 10px;">
          <div class="climatePills" style="margin-top:0;">
            <span class="climatePill" id="kpiRunoff">Runoff: ‚Äî</span>
            <span class="climatePill" id="kpiSediment">Sediment: ‚Äî</span>
            <span class="climatePill" id="kpiRecharge">Recharge: ‚Äî</span>
          </div>
        </div>
<canvas id="swatChart"></canvas>
        <div id="rankPanel" style="display:none; margin-top:10px;">
          <div class="assetSectionTitle" style="margin:10px 0 8px;">Top changes (selected metric)</div>
          <div style="display:flex; gap:10px; flex-wrap:wrap;">
            <div style="flex:1 1 150px; min-width:150px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
              <div style="font-size:12px; font-weight:800; color:#66fcf1; margin-bottom:6px;">Least Changed</div>
              <ol id="topWinners" style="margin:0; padding-left:18px; font-size:12px; color:#c5c6c7; line-height:1.35;"></ol>
            </div>
            <div style="flex:1 1 150px; min-width:150px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
              <div style="font-size:12px; font-weight:800; color:#ffcc80; margin-bottom:6px;">Most Changed</div>
              <ol id="topLosers" style="margin:0; padding-left:18px; font-size:12px; color:#c5c6c7; line-height:1.35;"></ol>
            </div>
          </div>
        </div>

      </div>

      <div id="climateTab" class="chartTabPane" style="display:none;">
        <div id="climateHeader">
          <div id="climateTitle">ERA5 precipitation</div>
          <button id="climateExpandBtn" class="miniActionBtn" type="button" title="Expand / Full view">‚§¢ Full view</button>
          <button id="simRainBtn" class="miniActionBtn" type="button" aria-pressed="false" title="Response-based simulation: Rainfall ‚Üí Runoff ‚Üí Dam">+20% Rain</button>
          <div id="climateStatus">Click a sub-basin to view monthly rainfall, anomaly and percentile.</div>
          <div id="climatePills" class="climatePills"></div>
        </div>
        <div style="height:260px; margin-top:10px;">
          <canvas id="climateChart"></canvas>
        </div>
      </div>

      <div id="soilTab" class="chartTabPane" style="display:none;">
        <div id="soilHeader">
          <div id="soilTitle">ERA5-Land soil moisture (0‚Äì28 cm)</div>
          <button id="soilToggleBtn" class="miniActionBtn" type="button" title="Toggle monthly comparison vs anomaly view">Show Anomaly</button>
          <div id="soilStatus">Loading soil moisture‚Ä¶</div>
          <div id="soilPills" class="climatePills"></div>
        </div>

        <div style="height:260px; margin-top:10px; position:relative;">
          <!-- Main soil moisture chart -->
          <canvas id="soilChart"></canvas>
          <!-- Zoom button in top‚Äëright corner -->
          <button id="soilZoomBtn" class="miniActionBtn" type="button" title="Expand / Full view" style="position:absolute; top:0; right:0; margin:6px;">‚§¢ Full view</button>
        </div>

        <div class="assetSectionTitle" style="margin:12px 0 8px; display:flex; align-items:center; gap:4px;">
          <span>Baseline vs recent</span>
          <!-- Info button explaining baseline vs recent periods (using unified icon) -->
          <span class="info-icon" onclick="toggleSoilInfo(event)">&#8505;</span>
        </div>
        <!-- Inline soil moisture explanation. Hidden by default; toggled via toggleSoilInfo(). -->
        <div id="soilInfoContent" class="info-content" style="display:none;">
          <div><b>Baseline vs recent soil moisture</b>: Baseline values use ERA5‚ÄëLand soil moisture from 2015‚Äì2017, representing typical conditions. Recent values use data from 2023‚Äì2025, capturing current conditions. Compare the two summaries to gauge drying or wetting trends. Values are volumetric moisture (m¬≥/m¬≥) and converted to equivalent water depth.</div>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1 1 160px; min-width:160px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
            <div style="font-size:11px; color:#9aa;">Baseline mean (2015‚Äì2017)</div>
            <div id="soilBaselineMean" style="font-size:18px; font-weight:900; color:#fff; margin-top:4px;">‚Äî</div>
          </div>
          <div style="flex:1 1 160px; min-width:160px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
            <div style="font-size:11px; color:#9aa;">Recent mean (2023‚Äì2025)</div>
            <div id="soilRecentMean" style="font-size:18px; font-weight:900; color:#fff; margin-top:4px;">‚Äî</div>
          </div>
          <div style="flex:1 1 160px; min-width:160px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
            <div style="font-size:11px; color:#9aa;">Change</div>
            <div id="soilPctChange" style="font-size:18px; font-weight:900; color:#fff; margin-top:4px;">‚Äî</div>
          </div>
        </div>
        <!-- Display units and equivalent water depth conversions -->
        <div id="soilMeanInfo" style="font-size:11px; color:#9aa; margin-top:4px;">
          Volumetric soil moisture (m¬≥/m¬≥), 0‚Äì28&nbsp;cm. Equivalent water depth: <span id="soilBaselineMM">‚Äî</span>‚ÄØmm (baseline), <span id="soilRecentMM">‚Äî</span>‚ÄØmm (recent).
        </div>

        <div class="assetSectionTitle" style="margin:12px 0 8px;">Dryness highlights (last 10 years)</div>
        <!-- Define what constitutes a ‚Äúdry‚Äù month so users understand the highlights -->
        <div style="font-size:11px; color:#9aa; margin-bottom:6px;">Dry month definition: bottom 20% of monthly soil moisture (p20)</div>

        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1 1 200px; min-width:200px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
            <div style="font-size:12px; font-weight:800; color:#ffcc80; margin-bottom:6px;">Top driest months</div>
            <ol id="soilTopDriestMonths" style="margin:0; padding-left:18px; font-size:12px; color:#c5c6c7; line-height:1.35;"></ol>
          </div>
          <div style="flex:1 1 200px; min-width:200px; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
            <div style="font-size:12px; font-weight:800; color:#66fcf1; margin-bottom:6px;">Driest year</div>
            <div id="soilDriestYear" style="font-size:13px; color:#fff; font-weight:800;">‚Äî</div>
            <div id="soilDrySpell" style="margin-top:8px; font-size:12px; color:#c5c6c7; line-height:1.35;">‚Äî</div>
          </div>
        </div>

        <!-- Interpretation legend to help users read the soil moisture charts -->
        <div class="assetSectionTitle" style="margin:12px 0 8px;">How to read this</div>
        <div style="font-size:12px; color:#c5c6c7; line-height:1.4; background: rgba(31,40,51,0.35); border:1px solid rgba(255,255,255,0.06); border-radius:10px; padding:10px;">
          ‚Ä¢ Higher values = wetter soil<br>
          ‚Ä¢ Anomaly &gt; 0 = wetter than baseline<br>
          ‚Ä¢ Anomaly &lt; 0 = drier than baseline<br>
          ‚Ä¢ Dry month = bottom 20% of historical distribution
        </div>

      </div>


      <div id="weatherTab" class="chartTabPane" style="display:none;">
        <div id="weatherHeader">
          <div id="weatherTitle" style="font-size:13px; font-weight:900; color:#66fcf1;">Open-Meteo weather forecast</div>
          <div id="weatherSubTitle" style="font-size:11px; color:#9aa; margin-top:2px;">Short-term forecast for the basin (operational awareness, not long-term climate projection)</div>

          <div class="weatherControls">
            <div class="weatherCtrl">
              <label for="weatherLocSelect">Location</label>
              <select id="weatherLocSelect" class="dtSelect">
                <option value="wala">Wala Dam</option>
                <option value="mujib">Mujib Dam</option>
                <option value="selected">Selected (last click)</option>
              </select>
            </div>

            <div class="weatherCtrl">
              <label for="weatherThreshold">Runoff-event threshold (mm/day)</label>
              <input id="weatherThreshold" type="number" min="0" step="1" value="10" />
            </div>

            <div class="weatherCtrl weatherCtrlBtn">
              <label>&nbsp;</label>
              <button id="weatherRefreshBtn" class="miniActionBtn" type="button">Update</button>
            </div>
          </div>

          <div id="weatherMetaRow" class="weatherMetaRow">
            <div id="weatherLocMeta" class="weatherMeta">Location: ‚Äî</div>
            <div id="weatherNowMeta" class="weatherMeta">Now: ‚Äî</div>
            <div id="weatherFlag" class="weatherFlag neutral">Event flag: ‚Äî</div>
          </div>

          <div id="weatherStatus" style="margin-top:8px; font-size:12px; color:#c5c6c7;">Click a location to fetch forecast.</div>
        </div>

        <div style="height:260px; margin-top:10px;">
          <canvas id="weatherChart"></canvas>
        </div>

        <div style="margin-top:10px; font-size:11px; color:#9aa; line-height:1.35;">
          Tip: click any subbasin, dam or point on the map ‚Üí choose <strong>Selected (last click)</strong> to view its forecast.
        </div>
      </div>


    </div>
  </div>

  <div id="legendPanel">
    <strong id="legendTitle">Map</strong>
    <div id="legendSubtitle" style="font-size: 11px; color:#aaa; margin-bottom:5px;">‚Äî</div>
    <div class="gradient-bar" id="legendGradient"></div>
    <div class="legend-labels" id="legendLabels">
      <span>Low</span><span>Avg</span><span>High</span>
    </div>
  </div>

  <!-- NDVI legend overlay (hidden by default).  This element will be populated
       dynamically in the script depending on the selected NDVI mode (baseline,
       recent or delta).  It lives near the legend panel but uses its own
       positioning so as not to overlap the assistant toggle. -->
  <div id="ndviLegend">
    <div class="ndviLegendTitle">NDVI legend</div>
    <div class="ndviLegendContent"></div>
  </div>

  <!-- Right-side panel showing asset details -->
  <div id="assetPanel" aria-label="Asset details">
    <div id="assetPanelHeader">
      <div style="min-width:0;">
        <div id="assetPanelTitle">Asset</div>
        <div id="assetPanelSubtitle">‚Äî</div>
      </div>
      <button id="assetPanelClose" title="Close">‚úï</button>
    </div>
    <div id="assetPanelBody"></div>
  </div>

  
<!-- Full view modal for the climate chart, reusing existing chart data -->
<div id="climateModal" class="modalOverlay" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="climateModalTitle">
  <div class="modalCard" role="document">
    <div class="modalHeader">
      <div id="climateModalTitle" class="modalTitle">ERA5 precipitation ‚Äî Full view</div>
      <div class="modalActions">
        <button id="climateModalClose" class="miniActionBtn" type="button" title="Close">‚úï</button>
      </div>
    </div>
    <div class="modalBody">
      <canvas id="climateChartBig"></canvas>
    </div>
    <div class="modalHint">Tip: scroll / pinch to zoom, drag to pan (x-axis)</div>
  </div>
</div>

<!-- Full view modal for the soil moisture chart -->
<div id="soilModal" class="modalOverlay" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="soilModalTitle">
  <div class="modalCard" role="document">
    <div class="modalHeader">
      <div id="soilModalTitle" class="modalTitle">ERA5‚ÄëLand soil moisture ‚Äî Full view</div>
      <div class="modalActions">
        <button id="soilModalClose" class="miniActionBtn" type="button" title="Close">‚úï</button>
      </div>
    </div>
    <div class="modalBody">
      <canvas id="soilChartBig"></canvas>
    </div>
    <div class="modalHint">Tip: scroll / pinch to zoom, drag to pan (x‚Äëaxis)</div>
  </div>
</div>

<div id="cesiumContainer"></div>

<!-- Weather widget info tooltip (data source) -->
<div id="mwInfoTooltip" class="mwInfoTooltip" onclick="event.stopPropagation();">
  <div class="mwInfoTitle">Weather data source</div>
  <div class="mwInfoBody">
    Forecast and current conditions are fetched from <a href="https://open-meteo.com/" target="_blank" rel="noopener noreferrer">Open‚ÄëMeteo</a> (public weather API).
    Variables used: temperature (¬∞C), wind speed (km/h), relative humidity (%), and daily precipitation sum (mm). Timezone: Asia/Amman.
  </div>
</div>
<!-- Soil moisture baseline vs recent tooltip.  Reuses the weather tooltip styling (mwInfoTooltip) to
     provide a concise explanation of how the baseline and recent soil moisture statistics are
     defined.  Click the small ‚Äúi‚Äù button near the Baseline vs recent heading to toggle this. -->
<div id="soilInfoTooltip" class="mwInfoTooltip" onclick="event.stopPropagation();">
  <div class="mwInfoTitle">Baseline vs Recent soil moisture</div>
  <div class="mwInfoBody">
    Baseline values use ERA5‚ÄëLand soil moisture from 2015‚Äì2017, representing typical conditions.
    Recent values use data from 2023‚Äì2025, capturing current conditions. Compare the two
    summaries to gauge drying or wetting trends. Values are volumetric moisture (m¬≥/m¬≥) and
    converted to equivalent water depth.
  </div>
</div>
</div>
<!-- Weather details modal (no charts). -->
<div id="weatherMiniModal" class="modalOverlay" style="display:none;" onclick="if(event.target===this) closeWeatherModal();">
  <div class="modalCard mwModalWrap">
    <div class="modalHeader">
      <div class="modalTitle">Weather Details</div>
      <button class="modalClose" type="button" onclick="closeWeatherModal()">√ó</button>
    </div>
    <div class="modalBody" style="padding:14px; overflow:auto;">
      <div class="mwModalTop">
        <div class="mwModalCtrl">
          <label for="mwLocSelect">Forecast location</label>
          <select id="mwLocSelect" class="dtSelect">
            <option value="wala">Wala Dam</option>
            <option value="mujib">Mujib Dam</option>
            <option value="selected">Selected (last click)</option>
          </select>
          <div id="mwLocMeta" class="mwMeta">‚Äî</div>
        </div>

        <button id="mwRefreshBtn" class="btnSmall" type="button" style="height:34px; margin-top:18px;">Refresh</button>
      </div>

      <div id="mwNowLine" class="mwNowLine">Now: ‚Äî</div>

      <table class="mwTable">
        <thead>
          <tr>
            <th>Date</th>
            <th style="text-align:right;">Precip (mm/day)</th>
            <th style="text-align:right;">Temp (min‚Äìmax)</th>
          </tr>
        </thead>
        <tbody id="mwTableBody">
          <tr><td colspan="3" style="color:#9aa;">Loading‚Ä¶</td></tr>
        </tbody>
      </table>

      <div id="mwStatus" class="mwStatus">‚Äî</div>
    </div>
  </div>
</div>


<div id="ndviTooltip">
  <div><span class="k" id="ndviTitle">NDVI</span>: <span id="ndviVal">‚Äî</span></div>
  <div id="ndviLabel" class="ndvi-label"></div>
</div>


<script>
  // ============================
  // Configuration for tokens and asset identifiers
  // ============================
  const YOUR_ACCESS_TOKEN = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1ZjM2YjEyMC1lNTM1LTQzZmUtYjUwNi00ZGVmMmE4ZjdmYTgiLCJpZCI6MzY3MDE2LCJpYXQiOjE3NjQ5NDc0NDl9.jgizcSHHOPz8Q9DroBtP3pkAFsjrlCQxRuhWrIFoGi4';
  const MY_MUJIB_DEM_ASSET_ID = 4194989;


  // ============================
  // OVERVIEW MODAL (Product header)
  // ============================
  function openOverviewModal(){
    const m = document.getElementById('overviewModal');
    if (!m) return;
    m.style.display = 'flex';
  }
  function closeOverviewModal(){
    const m = document.getElementById('overviewModal');
    if (!m) return;
    m.style.display = 'none';
  }
  // Allow ESC to close the overview modal
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeOverviewModal();
  });

  // Append a timestamp to prevent the browser from loading outdated GeoJSON files
  const CACHE_BUSTER = `v=${Date.now()}`;

  // Approximate WGS84 bounds for the Wala‚ÄìMujib area; used to detect and correct CRS issues such as swapped coordinates or projected inputs
  const EXPECTED_BOUNDS = { lonMin: 34.0, lonMax: 37.8, latMin: 29.0, latMax: 33.8 };
  const EXPECTED_CENTER = {
    lon: (EXPECTED_BOUNDS.lonMin + EXPECTED_BOUNDS.lonMax) / 2,
    lat: (EXPECTED_BOUNDS.latMin + EXPECTED_BOUNDS.latMax) / 2
  };

  // Jordan GIS layers typically use UTM Zone¬†36N; when exported without a CRS they may be interpreted in UTM meters
  const DEFAULT_PROJECTED_CRS = "EPSG:32636"; // WGS84 / UTM zone 36N

  // Adjust this if a different UTM zone is required (for example, EPSG:32637)
  const PROJECTED_CRS_FALLBACKS = ["EPSG:32636", "EPSG:32637"];

  // Define EPSG codes for proj4 (kept local so the HTML is portable)
  if (window.proj4 && typeof window.proj4.defs === "function") {
    proj4.defs("EPSG:32636", "+proj=utm +zone=36 +datum=WGS84 +units=m +no_defs");
    proj4.defs("EPSG:32637", "+proj=utm +zone=37 +datum=WGS84 +units=m +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
  }

  function withCacheBust(url) {
    if (!url) return url;
    const hasQ = url.includes("?");
    return url + (hasQ ? "&" : "?") + CACHE_BUSTER;
  }

  // ----- GeoJSON CRS sanity helpers (alignment fix) -----
  function walkCoords(coords, fn) {
    if (!Array.isArray(coords)) return coords;
    if (coords.length >= 2 && typeof coords[0] === "number" && typeof coords[1] === "number") {
      return fn(coords);
    }
    return coords.map(c => walkCoords(c, fn));
  }

  function cloneJson(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  function geojsonBbox(obj) {
    let minx = Infinity, miny = Infinity, maxx = -Infinity, maxy = -Infinity;
    function visit(c) {
      if (!Array.isArray(c) || c.length < 2) return;
      const x = Number(c[0]), y = Number(c[1]);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return;
      if (x < minx) minx = x;
      if (y < miny) miny = y;
      if (x > maxx) maxx = x;
      if (y > maxy) maxy = y;
    }
    function handleGeom(geom) {
      if (!geom || !geom.type) return;
      if (geom.type === "GeometryCollection" && Array.isArray(geom.geometries)) {
        geom.geometries.forEach(handleGeom);
        return;
      }
      if (geom.coordinates) {
        walkCoords(geom.coordinates, (c) => { visit(c); return c; });
      }
    }
    if (!obj) return null;
    if (obj.type === "FeatureCollection" && Array.isArray(obj.features)) {
      obj.features.forEach(f => handleGeom(f.geometry));
    } else if (obj.type === "Feature" && obj.geometry) {
      handleGeom(obj.geometry);
    } else if (obj.type && obj.coordinates) {
      handleGeom(obj);
    }
    if (!Number.isFinite(minx) || !Number.isFinite(miny)) return null;
    return { minx, miny, maxx, maxy };
  }

  function bboxOverlapsExpected(bb) {
    if (!bb) return false;
    const lonOk = bb.maxx >= EXPECTED_BOUNDS.lonMin && bb.minx <= EXPECTED_BOUNDS.lonMax;
    const latOk = bb.maxy >= EXPECTED_BOUNDS.latMin && bb.miny <= EXPECTED_BOUNDS.latMax;
    return lonOk && latOk;
  }

  function bboxCenter(bb) {
    if (!bb) return null;
    return { lon: (bb.minx + bb.maxx) / 2, lat: (bb.miny + bb.maxy) / 2 };
  }

  function haversineKm(a, b) {
    if (!a || !b) return Number.POSITIVE_INFINITY;
    const R = 6371.0;
    const toRad = (d) => d * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const la1 = toRad(a.lat);
    const la2 = toRad(b.lat);
    const s1 = Math.sin(dLat / 2);
    const s2 = Math.sin(dLon / 2);
    const h = s1 * s1 + Math.cos(la1) * Math.cos(la2) * s2 * s2;
    return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
  }

  function looksProjected(bb) {
    if (!bb) return false;
    // Anything outside lon/lat bounds OR typical UTM magnitudes
    if (bb.maxx > 180 || bb.minx < -180 || bb.maxy > 90 || bb.miny < -90) return true;
    if (Math.abs(bb.maxx) > 1000 || Math.abs(bb.maxy) > 1000) return true;
    return false;
  }

  function swapXYGeoJSON(obj) {
    const out = cloneJson(obj);
    function swap(c) { return [c[1], c[0], ...(c.length > 2 ? c.slice(2) : [])]; }
    function handleGeom(geom) {
      if (!geom) return;
      if (geom.type === "GeometryCollection" && Array.isArray(geom.geometries)) {
        geom.geometries.forEach(handleGeom);
        return;
      }
      if (geom.coordinates) geom.coordinates = walkCoords(geom.coordinates, swap);
    }
    if (out.type === "FeatureCollection" && Array.isArray(out.features)) {
      out.features.forEach(f => handleGeom(f.geometry));
    } else if (out.type === "Feature" && out.geometry) {
      handleGeom(out.geometry);
    } else if (out.type && out.coordinates) {
      handleGeom(out);
    }
    return out;
  }

  function reprojectGeoJSON(obj, fromEpsg) {
    if (!window.proj4) return { obj, ok: false, note: "proj4 missing" };
    const out = cloneJson(obj);
    function tx(c) {
      const x = Number(c[0]), y = Number(c[1]);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return c;
      const ll = proj4(fromEpsg, "EPSG:4326", [x, y]);
      return [ll[0], ll[1], ...(c.length > 2 ? c.slice(2) : [])];
    }
    function handleGeom(geom) {
      if (!geom) return;
      if (geom.type === "GeometryCollection" && Array.isArray(geom.geometries)) {
        geom.geometries.forEach(handleGeom);
        return;
      }
      if (geom.coordinates) geom.coordinates = walkCoords(geom.coordinates, tx);
    }
    if (out.type === "FeatureCollection" && Array.isArray(out.features)) {
      out.features.forEach(f => handleGeom(f.geometry));
    } else if (out.type === "Feature" && out.geometry) {
      handleGeom(out.geometry);
    } else if (out.type && out.coordinates) {
      handleGeom(out);
    }
    return { obj: out, ok: true, note: `reprojected ${fromEpsg}‚ÜíEPSG:4326` };
  }

  function normalizeGeoJSON(obj, label, referenceCenter = null) {
    // Strategy:
    // - Build candidate variants: original, swapped lon/lat, and (if looks projected) reprojected from common CRS.
    // - Score candidates by: whether they overlap EXPECTED_BOUNDS (Jordan-ish), whether they still look projected,
    //   and distance to a reference center (e.g. basin layer center). Pick the lowest-score candidate.
    try {
      const ref = referenceCenter || EXPECTED_CENTER;
      const candidates = [];
      const bb0 = geojsonBbox(obj);
      candidates.push({ obj, bb: bb0, note: "original" });

      const swapped = swapXYGeoJSON(obj);
      const bbS = geojsonBbox(swapped);
      candidates.push({ obj: swapped, bb: bbS, note: "swapped lon/lat" });

      if (looksProjected(bb0)) {
        for (const epsg of PROJECTED_CRS_FALLBACKS) {
          const rp = reprojectGeoJSON(obj, epsg);
          if (rp.ok) {
            candidates.push({ obj: rp.obj, bb: geojsonBbox(rp.obj), note: rp.note });
          }
        }
      }

      function score(c) {
        if (!c.bb) return Number.POSITIVE_INFINITY;
        let s = 0;
        // Penalize being outside expected bounds heavily (but don't make it impossible)
        if (!bboxOverlapsExpected(c.bb)) s += 10000;
        // Penalize candidates that still look projected
        if (looksProjected(c.bb)) s += 5000;
        const ctr = bboxCenter(c.bb);
        s += haversineKm(ctr, ref); // km distance to ref
        return s;
      }

      let best = candidates[0];
      let bestScore = score(best);
      for (const c of candidates) {
        const sc = score(c);
        if (sc < bestScore) { best = c; bestScore = sc; }
      }

      const bestCtr = bboxCenter(best.bb);
      const dist = haversineKm(bestCtr, ref);
      const note = (best.note === "original" && bboxOverlapsExpected(best.bb))
        ? "ok"
        : `fixed (${best.note})`;

      if (label) {
        console.log(`üß≠ normalizeGeoJSON[${label}]: picked '${note}' (dist-to-ref ‚âà ${dist.toFixed(1)} km)`);
      }

      return { obj: best.obj, note, bbox: best.bb, center: bestCtr, distKmToRef: dist };
    } catch (e) {
      console.warn("normalizeGeoJSON failed for", label, e);
      return { obj, note: "normalize failed" };
    }
  }

  // Place these data files next to index.html
  // GeoJSON containing 429 subbasin polygons for the Mujib basin with properties for annual runoff, sediment yield and whether each value comes from SWAT (71 subbasins) or a proxy.  A SWAT-only subset can be obtained by filtering features where source¬†===¬†"SWAT".
  const SUBBASINS_FULL_GEOJSON = 'subbasins_FULL429_with_runoff_sed_proxy.geojson';

  // Scenario JSON (unused for now but kept for compatibility).
  // When using annual SWAT + proxy data, scenarios are not applied; however the constant is retained to allow potential re‚Äëenabling of dP/dT toggles.
  const SCENARIO_JSON = 'scenarios_USED_BY_CESIUM_FINAL_71.json';

  // ERA5 monthly precipitation (subbasin-aggregated, compact JSON)
  const ERA5_CLIMATE_JSON = 'era5_precip_monthly_ALL429_compact.json';

  // ERA5-Land soil moisture (0‚Äì28 cm) files (kept in the ERA5_SOIL folder)
  // Note: browser fetch cannot read Windows absolute paths (e.g. C:\\...).
  // These must be served by Live Server and referenced with a relative URL.
  const SOIL_MOISTURE_DIR = 'ERA5_SOIL/';
  const SOIL_MOISTURE_CSV = SOIL_MOISTURE_DIR + 'soil_moisture_simple.csv';
  const SOIL_MOISTURE_FALLBACK_CSV = SOIL_MOISTURE_DIR + 'Mujib_ERA5Land_SM028_monthly_2015_01_to_2026_01.csv';
  const SOIL_MOISTURE_SUMMARY_JSON = SOIL_MOISTURE_DIR + 'soil_moisture_summary_Mujib.json';

  // Subbasin locations (precomputed representative point lat/lon for ALL 429)
  const SUBBASIN_LOC_JSON = 'subbasin_locations_ALL429.json';
  // Optional: nearest settlement/admin name per subbasin (offline-generated). If missing, DT will still work.
  const SUBBASIN_PLACE_JSON = 'subbasin_places_ALL429.json';

  // LoD1 buildings (put next to index.html)
  // Use the clipped version to avoid buildings outside the official basin.
  const LOD1_BUILDINGS_GEOJSON = 'mujib_lod1_simplified_CLIPPED.geojson';

  // Extra layers (converted from SHP -> GeoJSON)
  const FLOOD_STATIONS_GEOJSON = 'flood_stations.geojson';
  const DAMS_GEOJSON = 'dams.geojson';

  // Desert dams inventory (points)
  const DESERT_DAMS_GEOJSON = 'interventions.json';

  // NDVI (Sentinel-2) processed PNGs + bounds (place folder next to this HTML)
  // Used ONLY for click-to-value (no map overlay)
  const NDVI_BOUNDS_SCALES_JSON = 'NDVI_CESIUM_PREVIEW_4326/s2_bounds_scales.json';
  const NDVI_PNG = {
    baseline: 'NDVI_CESIUM_PREVIEW_4326/s2_baseline.png', // Baseline NDVI (2015‚Äì2017)
    recent:   'NDVI_CESIUM_PREVIEW_4326/s2_recent.png',   // Recent NDVI (2023‚Äì2025)
    delta:    'NDVI_CESIUM_PREVIEW_4326/s2_delta.png'     // Delta NDVI (Recent ‚àí Baseline)
  };

  // Colour NDVI overlays for map display. These PNGs are colour‚Äëcoded versions of the NDVI datasets
  // that will be overlaid on the map when users activate Baseline, Recent or Delta. They live in the
  // same folder as this HTML file.
  
const NDVI_COLOR_PNG = {
    baseline: 'NDVI_CESIUM_PREVIEW_4326/s2_baseline_color.png',
    recent:   'NDVI_CESIUM_PREVIEW_4326/s2_recent_color.png',
    delta:    'NDVI_CESIUM_PREVIEW_4326/s2_delta_color.png'
  };



  // Dam English name overrides (Arabic -> English)
  const DAM_EN_NAME_OVERRIDE = {
    "ÿ≥ÿØ ÿßŸÑŸàÿßŸÑŸá": "Wala Dam"
  };

  // ============================
  // STATUS UI
  // ============================
  const subStatus = document.getElementById('subStatus');
  const jsonStatus = document.getElementById('jsonStatus');
  const hoverStatus = document.getElementById('hoverStatus');
  const clickStatus = document.getElementById('clickStatus');

  const scenarioSelect = document.getElementById('scenarioSelect');
  const whatifSelect = document.getElementById('whatifSelect');
  const metricSelect = document.getElementById('metricSelect');

  // ============================
  // Metric ranges (computed after loading subbasins)
  // These hold the min and max values for runoff and sediment across all subbasins.
  // They are filled in loadSubbasinsLayer() and used by applyNumericMap() to normalize colors.
  const subMetricRanges = {
    runoff: { min: null, max: null },
    sediment: { min: null, max: null }
  };

  const legendPanel = document.getElementById('legendPanel');
  const legendTitle = document.getElementById('legendTitle');
  const legendSubtitle = document.getElementById('legendSubtitle');
  const legendLabels = document.getElementById('legendLabels');
  const legendGradient = document.getElementById('legendGradient');

  // NDVI legend overlay (custom for NDVI overlays)
  const ndviLegend = document.getElementById('ndviLegend');

  // ============================
  // RIGHT-SIDE ASSET PANEL (Flood Stations + Dams)
  // ============================
  const assetPanel = document.getElementById('assetPanel');
  const assetPanelTitle = document.getElementById('assetPanelTitle');
  const assetPanelSubtitle = document.getElementById('assetPanelSubtitle');
  const assetPanelBody = document.getElementById('assetPanelBody');
  const assetPanelClose = document.getElementById('assetPanelClose');

  function showAssetPanel(title, subtitle, bodyHtml) {
    assetPanelTitle.textContent = title || 'Asset';
    assetPanelSubtitle.textContent = subtitle || '';
    assetPanelBody.innerHTML = bodyHtml || '';
    assetPanel.style.display = 'block';
    document.body.classList.add('hasAssetPanel');
    // Ensure Cesium resizes to the new available width (map does not sit underneath the panel).
    try { requestAnimationFrame(() => { try { viewer.resize(); } catch(_) {} }); } catch(_) {}
  }
  function hideAssetPanel() {
    assetPanel.style.display = 'none';
    document.body.classList.remove('hasAssetPanel');
    try { requestAnimationFrame(() => { try { viewer.resize(); } catch(_) {} }); } catch(_) {}
  }

  assetPanelClose.addEventListener('click', hideAssetPanel);

  function escapeHtml(x){
    if (x === null || x === undefined) return '';
    return String(x)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function propVal(props, key) {
    if (!props) return null;
    const p = props[key];
    if (!p) return null;
    try {
      return (typeof p.getValue === "function") ? p.getValue(Cesium.JulianDate.now()) : p;
    } catch {
      return null;
    }
  }

  function propAny(props, keys) {
    for (const k of keys) {
      const v = propVal(props, k);
      if (v !== null && v !== undefined && v !== "") return v;
    }
    return null;
  }

  function getEntityCenterCartographic(entity){
    const now = Cesium.JulianDate.now();
    let cart = null;

    try {
      if (entity.position && typeof entity.position.getValue === "function") {
        cart = entity.position.getValue(now);
      } else if (entity.position) {
        cart = entity.position;
      }
    } catch {}

    if (!cart && entity.polygon && entity.polygon.hierarchy) {
      try {
        const h = entity.polygon.hierarchy.getValue ? entity.polygon.hierarchy.getValue(now) : entity.polygon.hierarchy;
        const positions = h?.positions;
        if (positions && positions.length) cart = Cesium.BoundingSphere.fromPoints(positions).center;
      } catch {}
    }

    if (!cart && entity.polyline && entity.polyline.positions) {
      try {
        const positions = entity.polyline.positions.getValue ? entity.polyline.positions.getValue(now) : entity.polyline.positions;
        if (positions && positions.length) cart = Cesium.BoundingSphere.fromPoints(positions).center;
      } catch {}
    }

    if (!cart) return null;
    return Cesium.Cartographic.fromCartesian(cart);
  }

  function latLonString(entity){
    const c = getEntityCenterCartographic(entity);
    if (!c) return null;
    const lat = Cesium.Math.toDegrees(c.latitude);
    const lon = Cesium.Math.toDegrees(c.longitude);
    return `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
  }

  function extractAllProps(entity){
    const props = entity?.properties;
    if (!props || !Array.isArray(props.propertyNames)) return {};
    const out = {};
    const now = Cesium.JulianDate.now();
    props.propertyNames.forEach((name) => {
      try {
        const p = props[name];
        out[name] = (p && typeof p.getValue === "function") ? p.getValue(now) : p;
      } catch {
        out[name] = null;
      }
    });
    return out;
  }

  function kv(label, value){
    const v = (value === null || value === undefined || value === "") ? "‚Äî" : value;
    return `<div class="kv"><div class="k">${escapeHtml(label)}</div><div class="v">${escapeHtml(v)}</div></div>`;
  }

  function flyToEntity(entity){
    if (!entity) return;
    try {
      viewer.flyTo(entity, { duration: 1.2, offset: new Cesium.HeadingPitchRange(0, -0.55, 2500) });
    } catch {
      viewer.flyTo(entity);
    }
  }

  function renderFloodStationPanel(entity){
    const p = entity.properties;
    const stationId = propAny(p, ["Station_Id","Station_ID","station_id","ID","Id"]);
    const stationName = propAny(p, ["Station_Na","Station_Name","Name","name"]);
    const sub = propAny(p, ["Subbasin","Sub_Basin","Basin","Surface_Ba"]);
    const gov = propAny(p, ["Governorat","Governorate"]);
    const own = propAny(p, ["Ownership"]);
    const elev = propAny(p, ["Elevation","ELEVATION"]);
    const date = propAny(p, ["Date_stati","Date_start","Date"]);
    const village = propAny(p, ["Village_To","Village"]);

    const coords = latLonString(entity);

    const title = stationName ? `${stationName}` : "Flood Station";
    const subtitle = `Station ID: ${stationId || "‚Äî"}${sub ? " ‚Ä¢ " + sub : ""}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">Flood Station</div>
        <div class="assetBadge">ID: ${escapeHtml(stationId || "‚Äî")}</div>
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || "‚Äî")}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Key details</div>
      <div class="kvGrid">
        ${kv("Station Name", stationName)}
        ${kv("Station ID", stationId)}
        ${kv("Subbasin", propAny(p, ["Subbasin"]))}
        ${kv("Elevation (m)", elev)}
        ${kv("Governorate", gov)}
        ${kv("Ownership", own)}
        ${kv("Start date", date)}
        ${kv("Nearest village/town", village)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById("assetZoomBtn");
    if (btn) btn.onclick = () => flyToEntity(entity);
  }

  function renderDamPanel(entity){
    const p = entity.properties;
    const en = propAny(p, ["En_name","EN_NAME","Name","NAME"]);
    const ar = propAny(p, ["Ar_Name","AR_NAME"]);
    const node = propAny(p, ["NODE_ID","Node_ID","node_id","ID"]);
    const type = propAny(p, ["TYPE","Type"]);
    const status = propAny(p, ["STATUS","Status"]);
    const comp = propAny(p, ["COMPLETION","Completion"]);
    const damType = propAny(p, ["DAM_TYPE","Dam_Type"]);
    const height = propAny(p, ["HEIGHT__M_","HEIGHT_M","HEIGHT"]);
    const catchment = propAny(p, ["CATCHMENT_","CATCHMENT","Catchment"]);
    const live = propAny(p, ["LIVE_STORA","LIVE_STORAGE"]);
    const dead = propAny(p, ["DEAD_STORA","DEAD_STORAGE"]);
    const purpose = propAny(p, ["PURPOSE","Purpose"]);
    const spill = propAny(p, ["SPILLWAY_C","SPILLWAY"]);
    const saf = propAny(p, ["YEARLY_SAF","SAFE_YIELD"]);
    const sed = propAny(p, ["SEDIMENT_L","SEDIMENT"]);
    const evap = propAny(p, ["EVAPORAT_1","EVAPORATIO","Evaporation"]);
    const maxEl = propAny(p, ["MAX_ELEVAT","MAX_ELEVATION"]);
    const free = propAny(p, ["FREE_BOARD","FREEBOARD"]);

    const coords = latLonString(entity);
    const title = entity.assetName || en || ar || "Dam / Reservoir";
    const subtitle = `${node ? "Node: " + node : "Dam asset"}${type ? " ‚Ä¢ " + type : ""}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">${escapeHtml((type || "Dam").toString())}</div>
        ${node ? `<div class="assetBadge">Node: ${escapeHtml(node)}</div>` : ``}
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || "‚Äî")}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Names</div>
      <div class="kvGrid">
        ${kv("English name", en)}
        ${kv("Arabic name", entity.assetNameAr || ar)}
        ${kv("Node ID", node)}
        ${kv("Type", type)}
      </div>

      <div class="assetSectionTitle">Status & design</div>
      <div class="kvGrid">
        ${kv("Status", status)}
        ${kv("Completion", comp)}
        ${kv("Dam type", damType)}
        ${kv("Height (m)", height)}
        ${kv("Max elevation (m)", maxEl)}
        ${kv("Freeboard (m)", free)}
        ${kv("Spillway capacity", spill)}
      </div>

      <div class="assetSectionTitle">Hydrology & storage</div>
      <div class="kvGrid">
        ${kv("Catchment", catchment)}
        ${kv("Purpose", purpose)}
        ${kv("Live storage", live)}
        ${kv("Dead storage", dead)}
        ${kv("Safe yield / yearly", saf)}
        ${kv("Sediment load", sed)}
        ${kv("Evaporation", evap)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById("assetZoomBtn");
    if (btn) btn.onclick = () => flyToEntity(entity);
  }

  
  function renderDesertDamPanel(entity){
    const p = entity.properties;

    // Desert dam inventory fields (from interventions.json)
    const name = propAny(p, ["Dam_Name","DAM_NAME","Name","NAME"]);
    const whNo = propAny(p, ["WH_No","WH_NO","WHNO","ID","Id"]);
    const gov = propAny(p, ["Governorat","Governorate","GOVERNORAT"]);
    const project = propAny(p, ["Project","PROJECT"]);
    const damType = propAny(p, ["Dam_type","DAM_TYPE","Type","TYPE"]);
    const year = propAny(p, ["Constructi","Construction","Year","YEAR"]);
    const curCap = propAny(p, ["Current_ca","CURRENT_CA","CurrentCap"]);
    const desCap = propAny(p, ["Design_Cap","DESIGN_CAP","DesignCap"]);
    const east = propAny(p, ["East","EAST"]);
    const north = propAny(p, ["North","NORTH"]);

    const coords = latLonString(entity);
    const title = name ? String(name) : 'Desert Dam';
    const subtitle = `WH No: ${whNo || '‚Äî'}${gov ? ' ‚Ä¢ ' + gov : ''}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">Desert Dam (Inventory)</div>
        ${whNo ? `<div class="assetBadge">WH No: ${escapeHtml(String(whNo))}</div>` : ``}
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || '‚Äî')}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Key details</div>
      <div class="kvGrid">
        ${kv('Dam name', name)}
        ${kv('WH No', whNo)}
        ${kv('Governorate', gov)}
        ${kv('Project', project)}
        ${kv('Dam type', damType)}
        ${kv('Construction year', year)}
        ${kv('Current capacity', curCap)}
        ${kv('Design capacity', desCap)}
        ${kv('East (source)', east)}
        ${kv('North (source)', north)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById('assetZoomBtn');
    if (btn) btn.onclick = () => flyToEntity(entity);
  }

function renderBuildingPanel(entity){
    const p = entity.properties;

    const bId = propAny(p, ["id","ID","identificatie","Identificatie","bag_id","BAG_ID","pand_id","Pand_ID","pandid","PANDID","building_id","Building_ID"]);
    const name = propAny(p, ["name","Name","building_name","Building_Name","pandnaam","PandNaam"]);

    const h = Number.isFinite(entity.buildingHeight)
      ? entity.buildingHeight
      : Number(propAny(p, ["height","Height"]));
    const hOk = Number.isFinite(h);
    const src = entity.heightSource || (propAny(p, ["height"]) != null ? "height" : (propAny(p, ["Height"]) != null ? "Height" : "unknown"));

    const coords = latLonString(entity);
    const title = name ? String(name) : (bId ? `Building ${bId}` : "Building");
    const subtitle = `Height: ${hOk ? (h + ' m') : '‚Äî'} ‚Ä¢ Source: ${src}`;

    const body = `
      <div class="assetBadges">
        <div class="assetBadge">Building (LoD1)</div>
        ${bId ? `<div class="assetBadge">ID: ${escapeHtml(String(bId))}</div>` : ``}
        <div class="assetBadge">Lat/Lon: ${escapeHtml(coords || '‚Äî')}</div>
      </div>

      <div class="assetActions">
        <button class="assetBtn" id="assetZoomBtn">Zoom to</button>
      </div>

      <div class="assetSectionTitle">Key details</div>
      <div class="kvGrid">
        ${kv("Name", name)}
        ${kv("Building ID", bId)}
        ${kv("Extrusion height (m)", hOk ? h : null)}
        ${kv("Height source", src)}
      </div>

      <details class="assetDetails">
        <summary>All attributes</summary>
        <pre class="assetJson">${escapeHtml(JSON.stringify(extractAllProps(entity), null, 2))}</pre>
      </details>
    `;

    showAssetPanel(title, subtitle, body);
    const btn = document.getElementById("assetZoomBtn");
    if (btn) btn.onclick = () => flyToEntity(entity);
  }


  // ============================
  // CESIUM VIEWER
  // ============================
  Cesium.Ion.defaultAccessToken = YOUR_ACCESS_TOKEN;

  const viewer = new Cesium.Viewer('cesiumContainer', {
    // Show the base layer picker so that users can switch between imagery layers (e.g. ArcGIS, OSM)
    baseLayerPicker: true,
    // Hide most other built‚Äëin UI controls for a clean dashboard
    animation: false,
    timeline: false,
    geocoder: false,
    homeButton: false,
    sceneModePicker: true,
    selectionIndicator: false,
    infoBox: false
  });

  // ============================
  // Mount Cesium basemap picker into the top bar (keeps functionality unchanged)
  // ============================
  function mountCesiumBasemapPickerToTopbar(){
    const slot = document.getElementById('topbarCesiumSlot');
    if (!slot) return;

    const picker = document.querySelector('.cesium-baseLayerPicker-container');
    if (!picker) {
      window.setTimeout(mountCesiumBasemapPickerToTopbar, 150);
      return;
    }

    // Move the existing Cesium base layer picker (two icon tiles) into the header.
    try {
      picker.style.position = 'static';
      picker.style.top = 'auto';
      picker.style.right = 'auto';
      picker.style.bottom = 'auto';
      picker.style.left = 'auto';
      slot.appendChild(picker);
    } catch (e) {
      // If anything fails, keep Cesium's default placement (no interruption).
      console.warn('Basemap picker mount skipped:', e);
    }
  }
  window.setTimeout(mountCesiumBasemapPickerToTopbar, 0);



  viewer.scene.globe.depthTestAgainstTerrain = false;

  // Immediately position the camera over the study area. Without this, Cesium shows
  // the entire globe and then zooms in, which is jarring. We set the view to the
  // expected centre of the Wala‚ÄìMujib basin with a reasonable altitude and tilt.
  try {
    const centerLon = EXPECTED_CENTER.lon;
    const centerLat = EXPECTED_CENTER.lat;
    const destination = Cesium.Cartesian3.fromDegrees(centerLon, centerLat, 180000.0);
    viewer.camera.setView({
      destination: destination,
      orientation: {
        heading: 0.0,
        pitch: Cesium.Math.toRadians(-90.0),
        roll: 0.0
      }
    });
  } catch (e) {
    console.warn('Failed to set initial camera view', e);
  }

  // ============================
  // HOME VIEW (Reset camera)
  // Captures the first overview view and lets the user return to it via the Home button.
  // ============================
  let __homeView = null;
  let __homeViewCaptured = false;

  function captureHomeView(){
    if (__homeViewCaptured) return;
    try {
      __homeView = {
        destination: viewer.camera.positionWC.clone(),
        orientation: {
          heading: viewer.camera.heading,
          pitch: viewer.camera.pitch,
          roll: viewer.camera.roll
        }
      };
      __homeViewCaptured = true;
    } catch (e) {
      // keep silent; capture will be retried later
    }
  }

  function goHomeView(event){
    try { if (event) event.stopPropagation(); } catch(_) {}
    try {
      if (__homeView && __homeView.destination) {
        viewer.camera.flyTo({
          destination: __homeView.destination,
          orientation: __homeView.orientation,
          duration: 0.9
        });
      } else {
        // Fallback: use basin overview if the capture did not happen yet.
        flyToBasinOverview();
      }
    } catch (e) {
      try { flyToBasinOverview(); } catch(_) {}
    }
  }

  // Fallback capture (in case the basin overview capture happens later).
  window.setTimeout(() => { if (!__homeViewCaptured) captureHomeView(); }, 900);

  async function loadTerrain() {
    try {
      viewer.terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(MY_MUJIB_DEM_ASSET_ID);
    } catch (e) {
      console.error("Terrain Error", e);
    }
  }
  loadTerrain();
  // ============================
  // NDVI (Sentinel-2) ‚Äî value-only (no overlay)
  // ============================
  const ndviUI = {
    activeMode: null, // 'baseline' | 'recent' | 'delta' | null
    metaLoaded: false,
    metaPromise: null,
    west: null, south: null, east: null, north: null,
    width: null, height: null,
    datasets: {
      baseline: { mode:'baseline', years:'2015‚Äì2017', vmin:null, vmax:null, ready:false, promise:null, canvas:null, ctx:null, img:null, png: null },
      recent:   { mode:'recent',   years:'2023‚Äì2025', vmin:null, vmax:null, ready:false, promise:null, canvas:null, ctx:null, img:null, png: null },
      delta:    { mode:'delta',    years:'2023‚Äì2025 ‚àí 2015‚Äì2017', vmin:null, vmax:null, ready:false, promise:null, canvas:null, ctx:null, img:null, png: null }
    }
  };

  // assign pngs
  ndviUI.datasets.baseline.png = NDVI_PNG.baseline;
  ndviUI.datasets.recent.png   = NDVI_PNG.recent;
  ndviUI.datasets.delta.png    = NDVI_PNG.delta;

  // ============================
  // NDVI overlay (colour maps)
  // ============================
  // Each overlay layer displays a colourised NDVI PNG on the map. They are created on demand
  // using Cesium.SingleTileImageryProvider and hidden by default. Only one overlay is shown
  // at a time to keep the map clear.
  const ndviOverlayLayers = { baseline: null, recent: null, delta: null };

  async function getNdviOverlayLayer(mode) {
    if (!mode) return null;
    // Already created? return existing
    if (ndviOverlayLayers[mode]) return ndviOverlayLayers[mode];
    // Ensure we know the NDVI bounds before creating the imagery provider
    const ok = await loadNdviMetaOnce();
    if (!ok) return null;
    // Create a rectangle covering the NDVI extent
    const rect = Cesium.Rectangle.fromDegrees(ndviUI.west, ndviUI.south, ndviUI.east, ndviUI.north);
    // Build the provider using the colour PNG corresponding to the mode
    const provider = new Cesium.SingleTileImageryProvider({
      url: NDVI_COLOR_PNG[mode],
      rectangle: rect,
      credit: ''
    });
    const layer = viewer.imageryLayers.addImageryProvider(provider);
    layer.show = false;
    ndviOverlayLayers[mode] = layer;
    return layer;
  }

  async function updateNdviOverlay() {
    // Hide all overlays first
    ['baseline','recent','delta'].forEach(m => {
      const lyr = ndviOverlayLayers[m];
      if (lyr) lyr.show = false;
    });
    const mode = ndviUI.activeMode;
    // When no NDVI layer is active, hide the custom legend and exit.
    if (!mode) {
      try { if (ndviLegend) ndviLegend.style.display = 'none'; } catch(_) {}
      return;
    }
    const layer = await getNdviOverlayLayer(mode);
    if (layer) layer.show = true;
    // Update the NDVI legend based on the active mode.
    if (ndviLegend) {
      const contentEl = ndviLegend.querySelector('.ndviLegendContent');
      let html = '';
      if (mode === 'delta') {
        // Œî NDVI legend: use ¬±0.01 thresholds and neutral terms. Colours match the Œî overlay (red = decrease, white = stable, blue = increase).
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#d32f2f;"></span><span>Decrease (Œî &lt; ‚àí0.01)</span></div>';
        // Use a white swatch with a light border for stable values on dark backgrounds.
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#ffffff; border:1px solid #ccc;"></span><span>Stable (‚àí0.01 to +0.01)</span></div>';
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#1976d2;"></span><span>Increase (Œî &gt; +0.01)</span></div>';
      } else {
        // Baseline or Recent NDVI legend: define classes based on the observed range (~0.04‚Äì0.27).
        // These swatches approximate the colours in the NDVI colour PNGs.
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#c19a6b;"></span><span>0.04‚Äì0.06: very sparse / bare soil</span></div>';
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#d4ba8a;"></span><span>0.06‚Äì0.08: low vegetation</span></div>';
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#e5d8a2;"></span><span>0.08‚Äì0.10: sparse vegetation</span></div>';
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#a8d693;"></span><span>0.10‚Äì0.13: moderate vegetation</span></div>';
        html += '<div class="ndviLegendItem"><span class="ndviSwatch" style="background:#2c7a26;"></span><span>&gt; 0.13: relatively high vegetation</span></div>';
      }
      if (contentEl) contentEl.innerHTML = html;
      // Update title to reflect the active NDVI period
      const titleEl = ndviLegend.querySelector('.ndviLegendTitle');
      if (titleEl) {
        if (mode === 'baseline') titleEl.textContent = 'Baseline NDVI (2015‚Äì2017)';
        else if (mode === 'recent') titleEl.textContent = 'Recent NDVI (2023‚Äì2025)';
        else titleEl.textContent = 'Œî NDVI (Recent ‚àí Baseline)';
      }
      ndviLegend.style.display = 'block';
    }
  }

  const ndviTooltip = document.getElementById('ndviTooltip');
  const ndviTitleEl = document.getElementById('ndviTitle');
  const ndviValEl   = document.getElementById('ndviVal');
  const ndviLabelEl = document.getElementById('ndviLabel');

  function showNdviTooltipAt(pageX, pageY, title, valueText, labelText) {
    if (!ndviTooltip) return;
    if (ndviTitleEl) ndviTitleEl.textContent = title || 'NDVI';
    if (ndviValEl) ndviValEl.textContent = valueText ?? '‚Äî';
    if (ndviLabelEl) ndviLabelEl.textContent = labelText || '';
    ndviTooltip.style.left = (pageX + 12) + 'px';
    ndviTooltip.style.top  = (pageY + 12) + 'px';
    ndviTooltip.style.display = 'block';
  }
  function hideNdviTooltip() {
    if (ndviTooltip) ndviTooltip.style.display = 'none';
  }

  function classifyNdvi(val, mode) {
    if (val === null || !Number.isFinite(val)) return '';
    // Œî NDVI values: classify based on ¬±0.01 thresholds with neutral language.
    if (mode === 'delta') {
      if (val > 0.01) return 'Increase';
      if (val < -0.01) return 'Decrease';
      return 'Stable';
    }
    // Baseline/Recent NDVI values: classify within the observed range (~0.04‚Äì0.27).
    // Values below 0.04 are uncommon for these datasets but are treated as very sparse.
    if (val < 0.06) return 'Very sparse / bare soil';
    if (val < 0.08) return 'Low vegetation';
    if (val < 0.10) return 'Sparse vegetation';
    if (val < 0.13) return 'Moderate vegetation';
    return 'Relatively high vegetation';
  }

  function lonLatToPixel(lon, lat) {
    if (!ndviUI.metaLoaded) return null;
    if (lon < ndviUI.west || lon > ndviUI.east || lat < ndviUI.south || lat > ndviUI.north) return null;

    const x = (lon - ndviUI.west) / (ndviUI.east - ndviUI.west) * (ndviUI.width - 1);
    const y = (ndviUI.north - lat) / (ndviUI.north - ndviUI.south) * (ndviUI.height - 1);
    return { x: Math.round(x), y: Math.round(y) };
  }

  function samplePixelWithFallback(ds, x, y, maxRadius = 3) {
    const ctx = ds.ctx;
    if (!ctx) return null;

    const w = ndviUI.width, h = ndviUI.height;
    const inBounds = (xx, yy) => (xx >= 0 && yy >= 0 && xx < w && yy < h);

    const get = (xx, yy) => {
      // readImageData 1x1 is ok; neighbor search makes it robust at edges
      return ctx.getImageData(xx, yy, 1, 1).data;
    };

    if (inBounds(x, y)) {
      const p0 = get(x, y);
      if (p0 && p0[3] > 0) return { px: p0, x, y };
    }

    for (let r = 1; r <= maxRadius; r++) {
      for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
          // only ring points (fast)
          if (Math.abs(dx) !== r && Math.abs(dy) !== r) continue;
          const xx = x + dx, yy = y + dy;
          if (!inBounds(xx, yy)) continue;
          const p = get(xx, yy);
          if (p && p[3] > 0) return { px: p, x: xx, y: yy };
        }
      }
    }
    return null;
  }

  function ndviValueAtLonLat(lon, lat, mode) {
    const ds = ndviUI.datasets[mode];
    if (!ds || !ds.ready || !ndviUI.metaLoaded) return null;

    const pix = lonLatToPixel(lon, lat);
    if (!pix) return null;

    const s = samplePixelWithFallback(ds, pix.x, pix.y, 3);
    if (!s) return null;

    // Grayscale PNG: R=G=B, map 0..255 back to NDVI using vmin/vmax
    const gray = s.px[0];
    const val = ds.vmin + (gray / 255.0) * (ds.vmax - ds.vmin);
    return val;
  }

  async function loadNdviMetaOnce() {
    if (ndviUI.metaLoaded) return true;
    if (ndviUI.metaPromise) return ndviUI.metaPromise;

    ndviUI.metaPromise = (async () => {
      const r = await fetch(withCacheBust(NDVI_BOUNDS_SCALES_JSON));
      if (!r.ok) throw new Error(`HTTP ${r.status} for ${NDVI_BOUNDS_SCALES_JSON}`);
      const meta = await r.json();

      ndviUI.west = Number(meta.west);
      ndviUI.south = Number(meta.south);
      ndviUI.east = Number(meta.east);
      ndviUI.north = Number(meta.north);
      ndviUI.width = Number(meta.width);
      ndviUI.height = Number(meta.height);

      const scales = meta.scales || {};
      // baseline/recent/delta scales must exist
      if (!scales.baseline || !scales.recent || !scales.delta) {
        console.warn('NDVI bounds JSON missing expected scales (baseline/recent/delta).', scales);
      }

      const setScale = (mode, key) => {
        const s = scales[key];
        if (!s) return;
        ndviUI.datasets[mode].vmin = Number(s.vmin);
        ndviUI.datasets[mode].vmax = Number(s.vmax);
      };

      setScale('baseline', 'baseline');
      setScale('recent', 'recent');
      setScale('delta', 'delta');

      ndviUI.metaLoaded = true;
      return true;
    })().catch(e => {
      console.error('NDVI meta load failed:', e);
      ndviUI.metaPromise = null;
      return false;
    });

    return ndviUI.metaPromise;
  }

  async function ensureNdviDatasetLoaded(mode) {
    const ds = ndviUI.datasets[mode];
    if (!ds) return false;
    if (ds.ready) return true;
    if (ds.promise) return ds.promise;

    ds.promise = (async () => {
      const ok = await loadNdviMetaOnce();
      if (!ok) return false;

      return await new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          try {
            const c = document.createElement('canvas');
            c.width = ndviUI.width;
            c.height = ndviUI.height;

            const ctx = c.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, c.width, c.height);

            ds.canvas = c;
            ds.ctx = ctx;
            ds.img = img;
            ds.ready = true;
            resolve(true);
          } catch (e) {
            console.error('NDVI canvas prep failed:', e);
            resolve(false);
          }
        };
        img.onerror = () => {
          console.error('NDVI PNG failed to load:', ds.png);
          resolve(false);
        };
        img.src = withCacheBust(ds.png);
      });
    })().finally(() => {
      // allow retry if failed
      if (!ds.ready) ds.promise = null;
    });

    return ds.promise;
  }

  function setNdviMode(mode, checked) {
    // ids expected in DOM
    const b = document.getElementById('ndviBaselineChk');
    const r = document.getElementById('ndviRecentChk');
    const d = document.getElementById('ndviDeltaChk');

    if (!checked) {
      // turning off
      if (ndviUI.activeMode === mode) {
        ndviUI.activeMode = null;
        hideNdviTooltip();
        // hide overlay when turning off
        updateNdviOverlay();
      }
      return;
    }

    // Only one ON at a time (recommended)
    if (b && mode !== 'baseline') b.checked = false;
    if (r && mode !== 'recent')   r.checked = false;
    if (d && mode !== 'delta')    d.checked = false;

    ndviUI.activeMode = mode;

    // Preload the dataset to make clicks smooth
    ensureNdviDatasetLoaded(mode);
    // Update overlay visibility: show only the selected NDVI colour overlay
    updateNdviOverlay();
  }

  // Default = ALL OFF (user selects one)
  ndviUI.activeMode = null;

  // ============================
  // UI helpers for NDVI panel toggling
  // ============================
  function toggleNdviPanel() {
    const main = document.getElementById('ndviMain');
    const panel = document.getElementById('ndviPanel');
    if (!main || !panel) return;
    const isActive = main.classList.contains('active');
    if (isActive) {
      main.classList.remove('active');
      panel.style.display = 'none';
    } else {
      main.classList.add('active');
      panel.style.display = 'block';
    }
    // Expand parent layer panel height if necessary so the nested NDVI panel is visible
    const layerPanel = main.closest('.layer-panel');
    if (layerPanel && layerPanel.style.maxHeight) {
      // Recalculate based on new scroll height
      layerPanel.style.maxHeight = layerPanel.scrollHeight + 'px';
    }
  }

  function toggleInfo(id) {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.display = (el.style.display === 'block') ? 'none' : 'block';
    // After toggling info visibility, adjust the parent panel height so content is not clipped
    const layerPanel = el.closest('.layer-panel');
    if (layerPanel && layerPanel.style.maxHeight) {
      layerPanel.style.maxHeight = layerPanel.scrollHeight + 'px';
    }
  }

  // Wrapper for NDVI info icon clicks.
  // This helper stops the click event from bubbling up to the NDVI header (which would
  // collapse/expand the panel) and then toggles the corresponding info box.
  function ndviInfoClick(event, id) {
    if (event) {
      // Prevent the click from triggering parent handlers (like toggleNdviPanel)
      event.stopPropagation();
    }
    toggleInfo(id);
  }


  // ============================
  // DATA / STATE
  // ============================
  let scenarioData = null;
  // Reference for CRS/order auto-fixing: once basin is loaded, we use its bbox center as
  // the target so subbasins (and other layers) are automatically transformed to match it.
  let basinRefCenter = null;
  let basinRefBbox = null;
  let subbasinsRefCenter = null;
  let alignmentRetryDone = false;
  let currentSubbasinId = null;
  let selectedSubbasinEntity = null; // label shown only for the selected sub-basin
  let myChart = null;

  // Climate (ERA5) panel state
  let activeChartTab = 'hydrology';
  let era5ClimateCache = null;
  let era5ClimatePromise = null;
  let climateChart = null;

  // Soil moisture (ERA5-Land) panel state
  let soilDataCache = null;
  let soilDataPromise = null;
  let soilChart = null;
  // Soil moisture view mode: 'compare' shows baseline vs recent monthly means; 'anomaly' shows deviation from baseline with optional smoothing
  let soilMode = 'compare'; // 'compare' | 'anomaly'
  let soilSourceUsed = null;

  // Weather (Open-Meteo) panel state
  let weatherChart = null;
  let weatherSelectedLocation = null;  // {lat, lon, label}
  let weatherKeyDams = { wala: null, mujib: null }; // filled from dam layer when available


  // Subbasin info (ALL 429): lat/lon + optional nearest place/admin name (loaded once)
  let SUB_LOC = null;
  let SUB_PLACE = null;

  async function loadSubLocations() {
    if (SUB_LOC) return SUB_LOC;
    const r = await fetch(withCacheBust(SUBBASIN_LOC_JSON));
    SUB_LOC = await r.json();
    console.log("‚úÖ Subbasin locations loaded:", Object.keys(SUB_LOC).length);
    return SUB_LOC;
  }

  async function loadSubPlacesOptional() {
    if (SUB_PLACE) return SUB_PLACE;
    try {
      const r = await fetch(withCacheBust(SUBBASIN_PLACE_JSON));
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      SUB_PLACE = await r.json();
      console.log("‚úÖ Subbasin places loaded:", Object.keys(SUB_PLACE).length);
    } catch (e) {
      // Optional file: safe to ignore
      SUB_PLACE = null;
      console.warn("‚ÑπÔ∏è Subbasin places file not found (optional):", SUBBASIN_PLACE_JSON);
    }
    return SUB_PLACE;
  }


  // Map state
  let heatmapOn = false;
  let isDeltaMode = false;        // Œî vs baseline (numeric metrics)
  let isPercentMode = false;      // %Œî vs baseline (numeric metrics)
  let hoverHandlerInstalled = false;
  let lastHover = null;

  // ============================
  // LOAD SCENARIOS
  // ============================
  async function loadScenarioData() {
    try {
      const res = await fetch(withCacheBust(SCENARIO_JSON));
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${SCENARIO_JSON}`);
      scenarioData = await res.json();

      const keys = Object.keys(scenarioData || {});
      // Expect 71 subbasins (Subbasin_1..Subbasin_71) in the rebuilt JSON.
      const ok = (keys.length === 71 && scenarioData["Subbasin_1"] && scenarioData["Subbasin_71"]);
      jsonStatus.textContent = `loaded (${keys.length} keys) ${ok ? '‚úÖ' : '‚ö†Ô∏è'}`;
      jsonStatus.className = ok ? 'ok' : 'warn';

      setupWhatifDropdown();
      console.log("‚úÖ scenarios loaded:", keys.slice(0,5), "‚Ä¶");

    } catch (err) {
      console.error("‚ùå Scenario JSON load failed:", err);
      jsonStatus.textContent = 'FAILED ‚ùå';
      jsonStatus.className = 'bad';
      alert(`Could not load ${SCENARIO_JSON}. Put it next to index.html and run with Live Server (not file://).`);
    }
  }

  function setupWhatifDropdown() {
    whatifSelect.innerHTML = `<option value="auto">What-if (auto)</option>`;

    const s1 = scenarioData?.["Subbasin_1"];
    const whatifs = s1?.whatifs ? Object.keys(s1.whatifs) : [];
    if (whatifs.length === 0) {
      const opt = document.createElement("option");
      opt.value = "dP0_dT0";
      opt.textContent = "dP0_dT0 (fallback)";
      whatifSelect.appendChild(opt);
      whatifSelect.value = "auto";
      return;
    }

    const def = s1.default_whatif || whatifs[0];
    const ordered = [def, ...whatifs.filter(x => x !== def)];
    ordered.forEach(k => {
      const opt = document.createElement("option");
      opt.value = k;
      opt.textContent = k;
      whatifSelect.appendChild(opt);
    });

    whatifSelect.value = "auto";
  }

  function getActiveWhatifKey(subId) {
    const selected = whatifSelect.value;
    if (selected !== "auto") return selected;
    const s = scenarioData?.[`Subbasin_${subId}`] || scenarioData?.["Subbasin_1"];
    return (s?.default_whatif) || "dP0_dT0";
  }

  function getWhatifObject(subId) {
    const node = scenarioData?.[`Subbasin_${subId}`];
    if (!node) return null;
    const wKey = getActiveWhatifKey(subId);
    const wObj = node.whatifs?.[wKey];
    return { node, wKey, wObj };
  }

  // ============================
  // METRIC GETTERS
  // ============================
  function getAnnualValue(subId, scenarioName, metricName) {
    const pack = getWhatifObject(subId);
    if (!pack) return null;

    const { node, wObj } = pack;

    let v = wObj?.annual?.[scenarioName]?.[metricName];
    if (Number.isFinite(v)) return v;

    v = wObj?.annual_by_scenario?.[metricName]?.[scenarioName];
    if (Number.isFinite(v)) return v;

    if (metricName === "runoff") {
      v = wObj?.annual_runoff_by_scenario?.[scenarioName];
      if (Number.isFinite(v)) return v;
      v = node?.annual_runoff_by_scenario?.[scenarioName];
      if (Number.isFinite(v)) return v;
      v = node?.annual_runoff_mm;
      if (Number.isFinite(v)) return v;
    }

    v = node?.[`annual_${metricName}_by_scenario`]?.[scenarioName];
    if (Number.isFinite(v)) return v;

    v = node?.[`annual_${metricName}`];
    if (Number.isFinite(v)) return v;

    return null;
  }

  function getDeltaAnnual(subId, scenarioName, metricName) {
    const base = getAnnualValue(subId, "baseline", metricName);
    const sel  = getAnnualValue(subId, scenarioName, metricName);
    if (!Number.isFinite(base) || !Number.isFinite(sel)) return null;
    return sel - base;
  }


  function getPctDeltaAnnual(subId, scenarioName, metricName) {
    const base = getAnnualValue(subId, "baseline", metricName);
    const sel  = getAnnualValue(subId, scenarioName, metricName);
    if (!Number.isFinite(base) || !Number.isFinite(sel)) return null;
    const b = Number(base);
    if (Math.abs(b) < 1e-9) return null; // avoid division by zero
    return ((Number(sel) - b) / b) * 100.0;
  }

  function getScenarioMetricValue(subId, scenarioName, metricName) {
    const vm = (document.getElementById("viewModeSelect")?.value) || "absolute";
    if (vm === "absolute") return getAnnualValue(subId, scenarioName, metricName);
    if (vm === "pct") return getPctDeltaAnnual(subId, scenarioName, metricName);
    return getDeltaAnnual(subId, scenarioName, metricName);
  }

  // ============================
  // DECISION (PRIORITY) GETTERS
  // ============================
  function getPriorityPack(subId) {
    const key = `Subbasin_${subId}`;
    const node = scenarioData?.[key];
    if (!node) return null;

    const wKey = getActiveWhatifKey(subId);
    const wObj = node.whatifs?.[wKey];
    if (!wObj) return null;

    const scenarioName = scenarioSelect.value;
    const pr = wObj.priority_by_scenario?.[scenarioName] || {};
    const sum = wObj.priority_summary_by_scenario?.[scenarioName] || {};

    return { wKey, wObj, pr, sum };
  }

  function focusColor(focus) {
    if (focus === "marab")     return Cesium.Color.ORANGE;
    if (focus === "vallerani") return Cesium.Color.MEDIUMPURPLE;
    if (focus === "recharge")  return Cesium.Color.DODGERBLUE;
    if (focus === "erosion")   return Cesium.Color.DARKRED;
    return Cesium.Color.LIGHTGRAY;
  }

  function applyScoreToColor(color, score) {
    const s = Math.max(0, Math.min(1, Number(score) || 0));
    return color.withAlpha(0.25 + 0.65 * s); // 0.25..0.90
  }

  // ============================
  // COLOR RAMPS (numeric metrics)
  // ============================
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }

  function lerpColor(c1, c2, t){
    const out = new Cesium.Color();
    Cesium.Color.lerp(c1, c2, clamp01(t), out);
    return out;
  }

  const RAMP = {
    runoff:      { lo: Cesium.Color.LIGHTBLUE.withAlpha(0.60), hi: Cesium.Color.NAVY.withAlpha(0.85), legend: "linear-gradient(to right,#ccc,#81D4FA,#29B6F6,#0277BD,#0D47A1)" },
    sediment:    { lo: Cesium.Color.MISTYROSE.withAlpha(0.60), hi: Cesium.Color.DARKRED.withAlpha(0.85), legend: "linear-gradient(to right,#fee,#fbb,#f66,#c00,#6b0000)" },
    groundwater: { lo: Cesium.Color.LIGHTCYAN.withAlpha(0.60), hi: Cesium.Color.DARKSLATEBLUE.withAlpha(0.85), legend: "linear-gradient(to right,#e0ffff,#9be7ff,#4db6ff,#1565c0,#0d2a6b)" },
    vegetation:  { lo: Cesium.Color.PALEGREEN.withAlpha(0.55), hi: Cesium.Color.DARKGREEN.withAlpha(0.85), legend: "linear-gradient(to right,#e8f5e9,#a5d6a7,#66bb6a,#2e7d32,#0b3d18)" },
  };

  const DELTA = {
    neg: Cesium.Color.DARKRED.withAlpha(0.80),
    mid: Cesium.Color.WHITE.withAlpha(0.20),
    pos: Cesium.Color.DARKGREEN.withAlpha(0.80),
    legend: "linear-gradient(to right,#6b0000,#ff6b6b,#ffffff,#7ee081,#0b3d18)"
  };

  function metricLabel(metric){
    if(metric === "runoff") return "Runoff (Annual)";
    if(metric === "sediment") return "Sediment (Annual)";
    if(metric === "groundwater") return "Recharge (Annual)";
    if(metric === "vegetation") return "Vegetation / ET (Annual)";
    if(metric === "decision") return "Decision: Best Intervention";
    return metric;
  }

  function computeRange(metricName, scenarioName) {
    const a = getActiveSubbasinLayerInfo();
    if (!a.ds || !scenarioData || !isActiveSwatLayer()) return {min:0, max:1};
    const vals = [];

    a.ds.entities.values.forEach(e => {
      const id = e.subbasinId;
      if (id == null) return;
      const v = getScenarioMetricValue(id, scenarioName, metricName);
      if (Number.isFinite(v)) vals.push(v);
    });

    if (vals.length < 3) return {min:0, max:1};
    vals.sort((a,b)=>a-b);

    const p5  = vals[Math.floor(0.05*(vals.length-1))];
    const p95 = vals[Math.floor(0.95*(vals.length-1))];
    if (p5 === p95) return {min:p5-1, max:p95+1};
    return {min:p5, max:p95};
  }

  // ============================
  // MAP STYLING (metric + decision)
  // ============================
  function applyDecisionMap() {
    const a = getActiveSubbasinLayerInfo();
    if (!a.ds || !scenarioData || !isActiveSwatLayer()) {
      // Decision map relies on scenario-derived priority packs (SWAT 71 only)
      legendPanel.style.display = "block";
      legendTitle.textContent = "Decision Map";
      legendSubtitle.textContent = "Available only for SWAT 71 sub-basins";
      legendGradient.style.background = "linear-gradient(to right,#777,#777)";
      legendLabels.innerHTML = `<span>N/A</span>`;
      return;
    }

    const scenarioName = scenarioSelect.value;
    const whatifLabel = getActiveWhatifKey(1);

    legendPanel.style.display = "block";
    legendTitle.textContent = "Decision Map (Best Focus)";
    legendSubtitle.textContent = `Scenario: ${scenarioName} | What-if: ${whatifLabel}`;
    legendGradient.style.background = "linear-gradient(to right,#ff9800,#9c27b0,#2196f3,#b71c1c)";
    legendLabels.innerHTML = `<span>Marab</span><span>Vallerani</span><span>Recharge/Erosion</span>`;

    const entities = a.ds.entities.values;

    entities.forEach(e => {
      if (!e.polygon) return;
      const id = e.subbasinId;
      if (id == null) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }

      const pack = getPriorityPack(id);
      if (!pack) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }

      const focus = pack.sum?.best_focus;   // marab/vallerani/recharge/erosion
      const score = pack.sum?.best_score;   // 0..1

      const baseCol = focusColor(focus);
      e.polygon.material = applyScoreToColor(baseCol, score);

      // Keep the same subtle outline style (don't imply data meaning by outlines)
      if (e.polyline) {
        e.polyline.material = SUB_STYLE.outline;
        e.polyline.width = SUB_STYLE.outlineWidth;
      }
    });
  }

  function applyNumericMap(metricName) {
    const a = getActiveSubbasinLayerInfo();
    if (!a.ds) return;

    // Scenario styling is only meaningful for the SWAT 71 layer.
    const useScenario = !!scenarioData && isActiveSwatLayer() && scenarioSelect && metricName && scenarioSelect.value && whatifSelect;

    // Determine legend and value sources.
    let scenarioName, whatifLabel, range;
    legendPanel.style.display = 'block';

    if (useScenario) {
      scenarioName = scenarioSelect.value;
      whatifLabel = getActiveWhatifKey(1);
      range = computeRange(metricName, scenarioName);
      legendTitle.textContent = (isDeltaMode ? (isPercentMode ? `%Œî ${metricLabel(metricName)} vs Baseline` : `Œî ${metricLabel(metricName)} vs Baseline`) : metricLabel(metricName));
      legendSubtitle.textContent = `Scenario: ${scenarioName} | What-if: ${whatifLabel}`;
      if (isDeltaMode) {
        legendGradient.style.background = DELTA.legend;
        legendLabels.innerHTML = isPercentMode ? `<span>Negative %</span><span>0%</span><span>Positive %</span>` : `<span>Negative</span><span>0</span><span>Positive</span>`;
      } else {
        legendGradient.style.background = (RAMP[metricName]?.legend || RAMP.runoff.legend);
        legendLabels.innerHTML = `<span>Low</span><span>Avg</span><span>High</span>`;
      }
    } else {
      // Static annual data coloring (no scenario). MetricName must be 'runoff' or 'sediment'
      legendTitle.textContent = metricLabel(metricName);
      legendSubtitle.textContent = 'Annual values (SWAT or Proxy)';
      // Use simple blue-red gradient similar to RAMP.runoff
      legendGradient.style.background = (RAMP[metricName]?.legend || RAMP.runoff.legend);
      legendLabels.innerHTML = `<span>Low</span><span>Avg</span><span>High</span>`;
      // Set range from precomputed subMetricRanges
      const rr = getActiveSubMetricRanges();
      if (metricName === 'runoff' && rr.runoff?.min != null) {
        range = { min: rr.runoff.min, max: rr.runoff.max };
      } else if (metricName === 'sediment' && rr.sediment?.min != null) {
        range = { min: rr.sediment.min, max: rr.sediment.max };
      } else {
        range = { min: 0, max: 1 };
      }
    }

    const entities = a.ds.entities.values;

    entities.forEach(e => {
      if (!e.polygon) return;
      let v;

      if (useScenario) {
        const id = e.subbasinId;
        if (id == null) { e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25); return; }
        v = getScenarioMetricValue(id, scenarioName, metricName);
      } else {
        // Pull values directly from entity properties for static annual dataset
        if (metricName === 'runoff') {
          v = propVal(e.properties, 'runoff_y');
        } else if (metricName === 'sediment') {
          v = propVal(e.properties, 'sed_y');
        } else {
          v = null;
        }
      }

      if (!Number.isFinite(Number(v))) {
        e.polygon.material = Cesium.Color.BLACK.withAlpha(0.25);
        return;
      }

      v = Number(v);

      if (useScenario && isDeltaMode) {
        const span = Math.max(Math.abs(range.min), Math.abs(range.max), 1e-6);
        const t = clamp01((v + span) / (2 * span));
        let col;
        if (t < 0.5) col = lerpColor(DELTA.neg, DELTA.mid, t / 0.5);
        else         col = lerpColor(DELTA.mid, DELTA.pos, (t - 0.5) / 0.5);
        e.polygon.material = col;
      } else {
        const denom = (range.max - range.min);
        const t = denom > 0 ? clamp01((v - range.min) / denom) : 0.5;
        const ramp = RAMP[metricName] || RAMP.runoff;
        e.polygon.material = lerpColor(ramp.lo, ramp.hi, t);
      }

      // Outline via clamped polyline (constant pixel width; subtle dark gray)
      if (e.polyline) {
        e.polyline.material = SUB_STYLE.outline;
        e.polyline.width = SUB_STYLE.outlineWidth;
      }
    });
  }

  function applyMapStyle() {
    const metricName = metricSelect.value;

    if (metricName === "decision") {
      applyDecisionMap();
      return;
    }

    applyNumericMap(metricName);
  }

  function resetSubbasinColors() {
    const a = getActiveSubbasinLayerInfo();
    if (!a.ds) return;
    a.ds.entities.values.forEach(e => {
      if (e.polygon && e.originalColor) {
        e.polygon.material = e.originalColor;
      }
      // Restore subtle default outlines (in case heatmap/decision map changed them).
      if (e.polyline && e._outlineDefaultMaterial) {
        e.polyline.material = e._outlineDefaultMaterial;
        e.polyline.width = e._outlineDefaultWidth || SUB_STYLE.outlineWidth;
      }
    });
    legendPanel.style.display = "none";
  }

  // ============================
  // LAYERS
  // ============================
  const layers = {};

  // ============================
  // SUBBASINS (SWAT 71 vs ALL 429)
  // ============================
  let subbasinsRawCache = null;   // raw GeoJSON from disk
  let subbasinsNormCache = null;  // normalized (WGS84 + fixed axis/order)
  let subbasinsNormKey = null;    // key for the reference center used

  const subMetricRangesByLayer = {
    swatSubbasins: { runoff: { min: null, max: null }, sediment: { min: null, max: null } },
    allSubbasins:  { runoff: { min: null, max: null }, sediment: { min: null, max: null } }
  };

  function refKey(ref) {
    if (!ref) return "expected";
    const lon = Number(ref.lon); const lat = Number(ref.lat);
    if (!Number.isFinite(lon) || !Number.isFinite(lat)) return "expected";
    return `${lon.toFixed(5)},${lat.toFixed(5)}`;
  }

  function getActiveSubbasinLayerInfo() {
    if (layers['swatSubbasins'] && layers['swatSubbasins'].show) return { id: 'swatSubbasins', ds: layers['swatSubbasins'] };
    if (layers['allSubbasins'] && layers['allSubbasins'].show)  return { id: 'allSubbasins',  ds: layers['allSubbasins'] };
    // legacy (older HTMLs)
    if (layers['subbasins'] && layers['subbasins'].show) return { id: 'subbasins', ds: layers['subbasins'] };
    return { id: null, ds: null };
  }

  function isActiveSwatLayer() {
    const a = getActiveSubbasinLayerInfo();
    return a.id === 'swatSubbasins' || a.id === 'subbasins';
  }

  function getActiveSubMetricRanges() {
    const a = getActiveSubbasinLayerInfo();
    if (!a.id) return subMetricRanges;
    return subMetricRangesByLayer[a.id] || subMetricRanges;
  }

  async function toggleSubbasinMode(mode, checked) {
    const swatChk = document.getElementById('swatSubChk');
    const allChk  = document.getElementById('allSubChk');

    // Allow both checkboxes to be turned off so the raw terrain, imagery or buildings can be viewed without subbasin polygons.
    // Layers remain mutually exclusive only when enabling one.

    if (mode === 'swat') {
      if (checked) {
        // Turning SWAT ON -> force ALL OFF
        if (allChk) allChk.checked = false;
        await toggleLayer('allSubbasins', false);
        await toggleLayer('swatSubbasins', true);
      } else {
        // Turning SWAT OFF -> allow both OFF
        await toggleLayer('swatSubbasins', false);
      }
    } else if (mode === 'all') {
      if (checked) {
        // Turning ALL ON -> force SWAT OFF
        if (swatChk) swatChk.checked = false;
        await toggleLayer('swatSubbasins', false);
        await toggleLayer('allSubbasins', true);
      } else {
        // Turning ALL OFF -> allow both OFF
        await toggleLayer('allSubbasins', false);
      }
    }

    // If both are OFF, hide the legend + disable heatmap styling.
    const anyOn = (swatChk && swatChk.checked) || (allChk && allChk.checked);
    if (!anyOn) {
      try { legendPanel.style.display = 'none'; } catch(_) {}
      heatmapOn = false;
      subStatus.textContent = 'off';
      subStatus.className = 'warn';
    } else {
      // Keep the status line consistent when toggling back on.
      subStatus.textContent = (swatChk && swatChk.checked) ? 'SWAT 71 ‚úÖ' : 'ALL 429 ‚úÖ';
      subStatus.className = 'ok';
    }
  }


  function flyToBasinOverview() {
    try {
      if (basinRefBbox && Number.isFinite(basinRefBbox.minx) && Number.isFinite(basinRefBbox.miny) &&
          Number.isFinite(basinRefBbox.maxx) && Number.isFinite(basinRefBbox.maxy)) {

        const w = Math.max(0.001, basinRefBbox.maxx - basinRefBbox.minx);
        const h = Math.max(0.001, basinRefBbox.maxy - basinRefBbox.miny);
        const padLon = w * 0.08;
        const padLat = h * 0.08;

        const rect = Cesium.Rectangle.fromDegrees(
          basinRefBbox.minx - padLon,
          basinRefBbox.miny - padLat,
          basinRefBbox.maxx + padLon,
          basinRefBbox.maxy + padLat
        );

        viewer.camera.flyTo({
          destination: rect,
          duration: 0.0,
          complete: () => { if (!__homeViewCaptured) captureHomeView(); }
        });
        return;
      }

      if (layers['basin']) {
        const p = viewer.flyTo(layers['basin'], { duration: 0.0 });
        if (p && typeof p.then === 'function') {
          p.then(() => { if (!__homeViewCaptured) captureHomeView(); }).catch(() => {});
        }
      }
    } catch (e) {
      console.warn('flyToBasinOverview failed:', e);
    }
  }

  async function toggleLayer(id, isVisible) {
    // Backward-compatibility: old UI used 'subbasins'. Treat it as SWAT 71.
    const targetId = (id === 'subbasins') ? 'swatSubbasins' : id;

    // Do not lazy-load a layer when simply hiding it.
    if (!isVisible) {
      if (layers[targetId]) layers[targetId].show = false;
      return;
    }

    // Keep track of whether this layer is being loaded for the first time.
    const wasNew = !layers[targetId];
    if (!layers[targetId]) {
      if (targetId === 'basin') await loadBasinLayer();
      else if (targetId === 'rivers') await loadRiverLayer();
      else if (targetId === 'dams') await loadDamsLayer();
      else if (targetId === 'sites') await loadSitesLayer();
      else if (targetId === 'swatSubbasins') await loadSwatSubbasinsLayer();
      else if (targetId === 'allSubbasins') await loadAllSubbasinsLayer();
      else if (targetId === 'buildings') await loadBuildingsLayer();
      else if (targetId === 'floodStations') await loadFloodStationsLayer();
    }

    if (layers[targetId]) layers[targetId].show = true;
    // Only fly to the basin layer when it is first loaded.  This prevents the map
    // from zooming to the eastern corner on subsequent toggles.
    if (targetId === 'basin' && wasNew && layers[targetId]) {
      flyToBasinOverview();
    }
  }

  async function reloadLayersForNewReference(layerIds) {
    // When we detect a CRS/order issue and re-normalize the basin, other layers
    // must be reloaded using the updated basinRefCenter so everything stays aligned.
    for (const id of layerIds) {
      const targetId = (id === 'subbasins') ? 'swatSubbasins' : id;
      if (!layers[targetId]) continue;
      const wasVisible = !!layers[targetId].show;
      try { viewer.dataSources.remove(layers[targetId], true); } catch (_) {}
      layers[targetId] = null;
      if (wasVisible) {
        await toggleLayer(targetId, true);
      }
    }
  }

  function getFeatureSource(f) {
    const s = (f && f.properties) ? (f.properties.source ?? f.properties.Source ?? f.properties.SOURCE) : null;
    const txt = String(s ?? '').trim().toUpperCase();
    return txt;
  }

  function guessSubIdFromFeature(f) {
    const p = f?.properties || {};
    const raw = p.subbasinId ?? p.SUB ?? p.Subbasin ?? p.subbasin ?? p.sub_id ?? p.SUB_ID;
    const n = Number(raw);
    return Number.isFinite(n) ? Math.round(n) : null;
  }

  function isSwatFeature(f) {
    const src = getFeatureSource(f);
    if (src) return src === 'SWAT';
    // Fallback: if the export forgot the source field, approximate SWAT by SUB id <= 71
    const id = guessSubIdFromFeature(f);
    return Number.isFinite(id) ? (id <= 71) : false;
  }

  async function getNormalizedFullSubbasins() {
    const key = refKey(basinRefCenter || EXPECTED_CENTER);
    if (subbasinsNormCache && subbasinsNormKey === key) return subbasinsNormCache;

    if (!subbasinsRawCache) {
      const url = withCacheBust(SUBBASINS_FULL_GEOJSON);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      subbasinsRawCache = await resp.json();
    }

    subbasinsNormCache = normalizeGeoJSON(subbasinsRawCache, "subbasins", basinRefCenter || EXPECTED_CENTER);
    subbasinsNormKey = key;
    return subbasinsNormCache;
  }

  function buildSubbasinsFeatureCollection(normObj, filterFn) {
    if (!filterFn) return normObj;
    const feats = (normObj?.features || []).filter(filterFn);
    // Clone only the subset to keep memory/cpu low (SWAT layer is small).
    return { type: "FeatureCollection", features: JSON.parse(JSON.stringify(feats)) };
  }

  // Sub-basin styling when colors are NOT used to encode a metric.
  // - SWAT 71: neutral light fill
  // - ALL 429: two-tone (SWAT vs PROXY)
  // - Subtle thin dark-gray outline (constant pixel width)
  const SUB_STYLE = {
    outline: Cesium.Color.fromCssColorString('#4a4a4a').withAlpha(0.55),
    outlineWidth: 1,
    swatFill: Cesium.Color.fromCssColorString('#cfd8dc').withAlpha(0.18),
    allSwatFill: Cesium.Color.fromCssColorString('#b2dfdb').withAlpha(0.18),
    allProxyFill: Cesium.Color.fromCssColorString('#cfd8dc').withAlpha(0.12),
    hoverOutline: Cesium.Color.YELLOW.withAlpha(0.95),
    hoverWidth: 3
  };

  async function loadSubbasinsFilteredLayer(layerId, filterFn, labelForStatus) {
    try {
      // Ensure basin loads first so it provides a stable reference center for normalization.
      if (!basinRefCenter && !layers['basin']) {
        await loadBasinLayer();
      }

      const norm = await getNormalizedFullSubbasins();
      subbasinsRefCenter = norm.center || bboxCenter(norm.bbox || geojsonBbox(norm.obj));

      const fc = buildSubbasinsFeatureCollection(norm.obj, filterFn);
      const resource = await Cesium.GeoJsonDataSource.load(fc, {
        // We draw our own subtle outlines with PolylineGraphics (below), so keep GeoJSON strokes off.
        stroke: Cesium.Color.TRANSPARENT,
        strokeWidth: 1,
        fill: Cesium.Color.TRANSPARENT,
        clampToGround: true
      });

      const entities = resource.entities.values;
      let valid = 0;
      const unique = new Set();

      let _minRun = Infinity;
      let _maxRun = -Infinity;
      let _minSed = Infinity;
      let _maxSed = -Infinity;

      function normalizeSubId(x) {
        if (x == null) return null;
        const n = Number(x);
        if (Number.isFinite(n)) return String(Math.round(n));
        const s = String(x).trim();
        return s ? s : null;
      }

      const now = Cesium.JulianDate.now();
      entities.forEach((entity) => {
        if (!entity.polygon) return;

        if (entity.properties && entity.properties.subbasinId) {
          entity.subbasinId = entity.properties.subbasinId.getValue();
        } else if (entity.properties && entity.properties.SUB) {
          entity.subbasinId = entity.properties.SUB.getValue();
        } else if (entity.properties && entity.properties.Subbasin) {
          entity.subbasinId = entity.properties.Subbasin.getValue();
        } else {
          entity.subbasinId = null;
        }

        entity.subbasinId = normalizeSubId(entity.subbasinId);
        if (entity.subbasinId != null) valid += 1;

        const id = entity.subbasinId;
        if (id != null && id !== "") unique.add(String(id));

        // Neutral styling (no implied data meaning)
        // - SWAT layer: one neutral fill
        // - ALL layer: two-tone based on properties.source (SWAT vs PROXY)
        const src = String(propVal(entity.properties, 'source') || '').trim().toUpperCase();
        const idNum = Number(id);
        const isSwat = (src === 'SWAT') || (!src && Number.isFinite(idNum) && idNum <= 71);
        let fillCol;
        if (layerId === 'allSubbasins') {
          fillCol = isSwat ? SUB_STYLE.allSwatFill : SUB_STYLE.allProxyFill;
        } else {
          fillCol = SUB_STYLE.swatFill;
        }
        entity.originalColor = fillCol;

        entity.polygon.material = entity.originalColor;
        entity.polygon.outline = false;

        // Draw a clamped outline polyline (constant pixel width; avoids Cesium terrain outline warnings)
        try {
          const h = entity.polygon.hierarchy?.getValue?.(now);
          const positions = h?.positions;
          if (positions && positions.length) {
            // Close the ring so the outline is continuous
            const closed = positions.slice();
            if (closed.length > 1) {
              const first = closed[0];
              const last = closed[closed.length - 1];
              if (!Cesium.Cartesian3.equals(first, last)) closed.push(first);
            }
            entity.polyline = new Cesium.PolylineGraphics({
              positions: closed,
              width: SUB_STYLE.outlineWidth,
              material: SUB_STYLE.outline,
              clampToGround: true
            });
            entity._outlineDefaultMaterial = SUB_STYLE.outline;
            entity._outlineDefaultWidth = SUB_STYLE.outlineWidth;
          }
        } catch (_) {}

        entity.label = new Cesium.LabelGraphics({
          text: id != null ? `SUB ${id}` : "SUB ?",
          show: false,
          font: "14px sans-serif",
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 4,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          pixelOffset: new Cesium.Cartesian2(0, -12),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        // Track annual ranges from properties (works for SWAT and PROXY)
        const props = entity.properties || {};

        let r = props.runoff_y;
        if (r && typeof r.getValue === 'function') r = r.getValue(now);
        r = Number(r);
        if (Number.isFinite(r)) {
          if (r < _minRun) _minRun = r;
          if (r > _maxRun) _maxRun = r;
        }

        let s = props.sed_y;
        if (s && typeof s.getValue === 'function') s = s.getValue(now);
        s = Number(s);
        if (Number.isFinite(s)) {
          if (s < _minSed) _minSed = s;
          if (s > _maxSed) _maxSed = s;
        }
      });

      if (Number.isFinite(_minRun) && Number.isFinite(_maxRun)) {
        subMetricRangesByLayer[layerId] = subMetricRangesByLayer[layerId] || { runoff: {}, sediment: {} };
        subMetricRangesByLayer[layerId].runoff = { min: _minRun, max: _maxRun };
      }
      if (Number.isFinite(_minSed) && Number.isFinite(_maxSed)) {
        subMetricRangesByLayer[layerId] = subMetricRangesByLayer[layerId] || { runoff: {}, sediment: {} };
        subMetricRangesByLayer[layerId].sediment = { min: _minSed, max: _maxSed };
      }

      viewer.dataSources.add(resource);
      layers[layerId] = resource;

      const distTxt = (basinRefCenter && Number.isFinite(norm.distKmToRef)) ? `, Œî‚âà${norm.distKmToRef.toFixed(1)}km` : '';
      subStatus.textContent = `loaded (${labelForStatus}: ${entities.length} features${distTxt})`;
      const aligned = (!basinRefCenter || !Number.isFinite(norm.distKmToRef) || norm.distKmToRef < 25);
      subStatus.className = aligned ? 'ok' : 'warn';

      // If still far apart, the basin layer may be the one with wrong CRS/order.
      if (basinRefCenter && subbasinsRefCenter && Number.isFinite(norm.distKmToRef) && norm.distKmToRef > 25 && !alignmentRetryDone) {
        alignmentRetryDone = true;
        console.warn(`‚ö†Ô∏è Basin/subbasins look misaligned (Œî‚âà${norm.distKmToRef.toFixed(1)} km). Retrying basin normalization using subbasins as reference...`);
        await reloadBasinWithReference(subbasinsRefCenter);
        // Re-normalize other layers using the updated basin reference so points/lines align.
        await reloadLayersForNewReference(['rivers','dams','sites','floodStations','buildings']);
      }

      if (!hoverHandlerInstalled) {
        installHoverHandler();
        hoverHandlerInstalled = true;
      }

      // If heatmap is already enabled, re-apply styling to the active subbasins layer.
      if (heatmapOn) applyMapStyle();

      // Only fly-to on first load to avoid constant camera jumps.
      if (layerId === 'swatSubbasins' && !viewer.camera._subbasinsFlyDone) {
        viewer.camera._subbasinsFlyDone = true;
        viewer.flyTo(resource);
      }
    } catch (e) {
      console.error("Error loading subbasins", e);
      subStatus.textContent = 'FAILED ‚ùå';
      subStatus.className = 'bad';
      alert(`Failed to load ${SUBBASINS_FULL_GEOJSON}. Put it next to index.html and run with Live Server.`);
    }
  }

  async function loadSwatSubbasinsLayer() {
    console.log("‚è≥ Loading SWAT subbasins from:", SUBBASINS_FULL_GEOJSON);
    await loadSubbasinsFilteredLayer('swatSubbasins', isSwatFeature, 'SWAT 71');
  }

  async function loadAllSubbasinsLayer() {
    console.log("‚è≥ Loading ALL subbasins (429) from:", SUBBASINS_FULL_GEOJSON);
    await loadSubbasinsFilteredLayer('allSubbasins', null, 'All 429');
  }

  // Legacy name (older sidebar checkbox)
  async function loadSubbasinsLayer() {
    await loadSwatSubbasinsLayer();
  }

  function installHoverHandler() {
    viewer.screenSpaceEventHandler.setInputAction(function(movement) {
      const picked = viewer.scene.pick(movement.endPosition);

      // Reset previous hover styling
      if (lastHover && lastHover.subbasinId != null) {
        if (lastHover.polyline && lastHover._outlineDefaultMaterial) {
          lastHover.polyline.material = lastHover._outlineDefaultMaterial;
          lastHover.polyline.width = lastHover._outlineDefaultWidth || SUB_STYLE.outlineWidth;
        }
        // Labels are shown only for the *selected* sub-basin (click), not on hover.
        if (lastHover.label && lastHover !== selectedSubbasinEntity) lastHover.label.show = false;
      } else if (lastHover && lastHover.label) {
        // Non-subbasin hover labels (e.g., desert dams)
        lastHover.label.show = false;
      }

      if (Cesium.defined(picked) && picked.id) {
        const e = picked.id;

        // Subbasins hover
        if (e.subbasinId != null) {
          hoverStatus.textContent = `SUB ${e.subbasinId}`;
          hoverStatus.className = 'ok';

          if (e.polyline) {
            e.polyline.material = SUB_STYLE.hoverOutline;
            e.polyline.width = SUB_STYLE.hoverWidth;
          }
          lastHover = e;
          return;
        }

        // Desert dam hover
        if (e.assetType === 'desert_dam') {
          hoverStatus.textContent = `Desert Dam`;
          hoverStatus.className = 'ok';
          if (e.label) e.label.show = true;
          lastHover = e;
          return;
        }
      }

      // Nothing found
      hoverStatus.textContent = 'none';
      hoverStatus.className = 'warn';
      lastHover = null;

    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
  }

  async function loadBasinLayer() {
    try {
      // Load the official Mujib basin boundary instead of the SWAT-dissolved boundary.
      const url = withCacheBust('basin_OFFICIAL.geojson');
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      const raw = await resp.json();
      const norm = normalizeGeoJSON(raw, "basin");
      basinRefCenter = norm.center || bboxCenter(norm.bbox || geojsonBbox(norm.obj));
      basinRefBbox = norm.bbox || geojsonBbox(norm.obj);
      const res = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });
      res.entities.values.forEach(e => {
        if (e.polygon) {
          const now = Cesium.JulianDate.now();
          const h = e.polygon.hierarchy?.getValue?.(now);
          const positions = h?.positions;
          if (positions && positions.length) {
            const closed = positions.slice();
            if (closed.length > 1) {
              const first = closed[0];
              const last = closed[closed.length - 1];
              if (!Cesium.Cartesian3.equals(first, last)) closed.push(first);
            }
            // Constant pixel width basin boundary (doesn't grow when zooming)
            e.polyline = new Cesium.PolylineGraphics({
              positions: closed,
              width: 2,
              material: Cesium.Color.DARKORANGE.withAlpha(0.95),
              clampToGround: true
            });
          }
          // Keep polygon invisible (boundary is shown via polyline above)
          e.polygon.material = Cesium.Color.TRANSPARENT;
          e.polygon.outline = false;
        }
      });
      console.log(`‚úÖ Basin boundary loaded; normalize: ${norm.note}`);
      if (basinRefCenter) {
        console.log(`üìå Basin reference center: lon=${basinRefCenter.lon.toFixed(5)}, lat=${basinRefCenter.lat.toFixed(5)}`);
      }
      viewer.dataSources.add(res); layers['basin'] = res;
    } catch (e) { console.error("Basin load error", e); }
  }

  async function reloadBasinWithReference(refCenter) {
    // If basin/subbasins look far apart, try re-normalizing the basin using subbasins as reference.
    try {
      if (layers['basin']) {
        try { viewer.dataSources.remove(layers['basin'], true); } catch (_) {}
        layers['basin'] = null;
      }

      const url = withCacheBust('basin_OFFICIAL.geojson');
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      const raw = await resp.json();
      const norm = normalizeGeoJSON(raw, "basin", refCenter || null);
      basinRefCenter = norm.center || bboxCenter(norm.bbox || geojsonBbox(norm.obj));
      basinRefBbox = norm.bbox || geojsonBbox(norm.obj);

      const res = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });
      res.entities.values.forEach(e => {
        if (e.polygon) {
          const now = Cesium.JulianDate.now();
          const h = e.polygon.hierarchy?.getValue?.(now);
          const positions = h?.positions;
          if (positions && positions.length) {
            const closed = positions.slice();
            if (closed.length > 1) {
              const first = closed[0];
              const last = closed[closed.length - 1];
              if (!Cesium.Cartesian3.equals(first, last)) closed.push(first);
            }
            e.polyline = new Cesium.PolylineGraphics({
              positions: closed,
              width: 2,
              material: Cesium.Color.DARKORANGE.withAlpha(0.95),
              clampToGround: true
            });
          }
          e.polygon.material = Cesium.Color.TRANSPARENT;
          e.polygon.outline = false;
        }
      });
      viewer.dataSources.add(res);
      layers['basin'] = res;
      console.log(`üîÅ Basin reloaded using reference; normalize: ${norm.note}`);
      if (basinRefCenter) {
        console.log(`üìå Basin reference center (after reload): lon=${basinRefCenter.lon.toFixed(5)}, lat=${basinRefCenter.lat.toFixed(5)}`);
      }
    } catch (e) {
      console.warn('Basin reload attempt failed:', e);
    }
  }

  async function loadRiverLayer() {
    try {
      const url = withCacheBust('rivers.json');
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      const raw = await resp.json();
      const norm = normalizeGeoJSON(raw, "rivers", basinRefCenter || EXPECTED_CENTER);
      const res = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });

      // Render rivers with constant pixel width (PolylineGraphics), so width does NOT grow/shrink with zoom.
      res.entities.values.forEach(e => {
        if (e.polyline) {
          e.polyline.material = Cesium.Color.CYAN.withAlpha(0.8);
          e.polyline.width = 2; // constant pixels
          e.polyline.clampToGround = true;
        }
        // If any corridors exist in the source style, remove them.
        if (e.corridor) e.corridor = undefined;
      });
      console.log(`‚úÖ River network loaded; normalize: ${norm.note}`);
      viewer.dataSources.add(res); layers['rivers'] = res;
    } catch (e) { console.error("Rivers load error", e); }
  }
  // ============================
  // FLOOD STATIONS (GeoJSON)
  // ============================
  async function loadFloodStationsLayer() {
    try {
      const url = withCacheBust(FLOOD_STATIONS_GEOJSON);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      const raw = await resp.json();
      const norm = normalizeGeoJSON(raw, "floodStations", basinRefCenter || EXPECTED_CENTER);
      const res = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });

      res.entities.values.forEach(e => {
        // Style point features
        if (e.position) {
          e.billboard = undefined;
          e.point = {
            pixelSize: 10,
            color: Cesium.Color.RED.withAlpha(0.9),
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          };
        }

        // Optional label (hidden by default)
        const p = e.properties;
        const name =
          (p?.Station?.getValue?.() ?? p?.station?.getValue?.() ??
           p?.Name?.getValue?.() ?? p?.name?.getValue?.() ??
           p?.ID?.getValue?.() ?? p?.id?.getValue?.() ?? "Flood Station");

        e.label = new Cesium.LabelGraphics({
          text: String(name),
          show: false,
          font: "12px sans-serif",
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 3,
          pixelOffset: new Cesium.Cartesian2(0, -14),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        // ‚úÖ Tag for click-details panel
        e.assetType = "flood_station";
        e.assetId = (p?.Station_Id?.getValue?.() ?? p?.Station_ID?.getValue?.() ?? p?.ID?.getValue?.() ?? null);
        e.assetName = (p?.Station_Na?.getValue?.() ?? p?.Station_Name?.getValue?.() ?? p?.Name?.getValue?.() ?? "Flood Station");
      });

      viewer.dataSources.add(res);
      layers['floodStations'] = res;

      console.log("‚úÖ Flood Stations loaded:", res.entities.values.length);
    } catch (e) {
      console.error("‚ùå Flood Stations load error", e);
      alert(`Failed to load ${FLOOD_STATIONS_GEOJSON}. Put it next to index.html and run with Live Server.`);
    }
  }

  // ============================
// DAMS (GeoJSON)
// ============================
async function loadDamsLayer() {
  try {
    const url = withCacheBust(DAMS_GEOJSON);
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
    const raw = await resp.json();
    const norm = normalizeGeoJSON(raw, "dams", basinRefCenter || EXPECTED_CENTER);
    const res = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });

    // Solid, readable styling on satellite imagery
    // Earth-tone styling (dark brown fill + light brown highlight)
    const DAM_FILL = Cesium.Color.fromCssColorString("#5D4037");     // dark brown
    const DAM_OUTLINE = Cesium.Color.fromCssColorString("#5D4037");  // match fill (no border)

    res.entities.values.forEach(e => {
      // Points
      if (e.position) {
        e.billboard = undefined;
        e.point = {
          pixelSize: 10,
          color: DAM_FILL.withAlpha(1.0),
          outlineColor: DAM_OUTLINE.withAlpha(1.0),
          outlineWidth: 0,
          heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
        };
      }

      // Polygons
      if (e.polygon) {
        e.polygon.material = DAM_FILL.withAlpha(0.98);
        // Avoid Cesium terrain-outline warnings; draw a clamped polyline outline instead
        e.polygon.outline = false;
        try {
          const now = Cesium.JulianDate.now();
          const h = e.polygon.hierarchy?.getValue?.(now);
          const positions = h?.positions;
          if (positions && positions.length) {
            e.polyline = new Cesium.PolylineGraphics({
              positions,
              width: 3,
              material: DAM_OUTLINE.withAlpha(0.98),
              clampToGround: true
            });
          }
        } catch (err) { /* ignore */ }
      }

      // Polylines
      if (e.polyline) {
        e.polyline.material = DAM_OUTLINE.withAlpha(0.98);
        e.polyline.width = 0;
        e.polyline.clampToGround = true;
        e.polyline.show = false; // remove border
      }

      // ‚úÖ Tag for click-details panel
      e.assetType = "dam";
      const p = e.properties;

      e.assetId = (p?.NODE_ID?.getValue?.() ?? p?.Node_ID?.getValue?.() ?? p?.ID?.getValue?.() ?? null);

      // --- Name extraction + override (Wala Dam) ---
      const rawEn = (p?.En_name?.getValue?.() ?? p?.EN_NAME?.getValue?.() ?? "");
      const rawAr = (p?.Ar_Name?.getValue?.() ?? p?.AR_NAME?.getValue?.() ?? "");
      const rawNm = (p?.Name?.getValue?.() ?? p?.NAME?.getValue?.() ?? "");

      const en = String(rawEn || "").trim();
      const ar = String(rawAr || "").trim();
      const nm = String(rawNm || "").trim();

      // Normalize Arabic (remove spaces + tatweel + diacritics)
      const arNorm = String(ar || nm).replace(/[\s\u0640\u064B-\u065F\u0670]/g, "");

      // Prefer English names (decision-makers); keep Arabic available for details
      function isArabicString(s){ return /[\u0600-\u06FF]/.test(String(s||"")); }

      let englishName = en;

      // Wala special-case (handles different Arabic spellings)
      if (!englishName && (
        arNorm.includes("ÿ≥ÿØÿßŸÑŸàÿßŸÑŸá") || arNorm.includes("ÿ≥ÿØÿßŸÑŸàÿßŸÑÿ©") ||
        arNorm.includes("ÿßŸÑŸàÿßŸÑŸá")   || arNorm.includes("ÿßŸÑŸàÿßŸÑÿ©")
      )) {
        englishName = "Wala Dam";
      }

      // Explicit override map (Arabic -> English)
      if (!englishName && ar && DAM_EN_NAME_OVERRIDE[ar]) {
        englishName = DAM_EN_NAME_OVERRIDE[ar];
      }

      // If "Name" is already Latin (not Arabic), use it
      if (!englishName && nm && !isArabicString(nm)) {
        englishName = nm;
      }

      // Fallback: English generic label
      if (!englishName) {
        englishName = e.assetId ? `Dam ${e.assetId}` : "Dam";
      }

      e.assetName = englishName;
      e.assetNameAr = (ar && isArabicString(ar)) ? ar : (isArabicString(nm) ? nm : "");
    });

    viewer.dataSources.add(res);
    layers["dams"] = res;

    // Initialize weather key locations (Wala/Mujib) from the dam layer
    initWeatherKeyDamsFromLayer(res);

    console.log("‚úÖ Dams loaded:", res.entities.values.length, `normalize: ${norm.note}`);
  } catch (e) {
    console.error("‚ùå Dams load error", e);
    alert(`Failed to load ${DAMS_GEOJSON}. Put it next to index.html and run with Live Server.`);
  }
}

  
  // ============================
  // DESERT DAMS INVENTORY (GeoJSON points)
  // ============================
  async function loadSitesLayer() {
    try {
      const url = withCacheBust(DESERT_DAMS_GEOJSON);
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(`HTTP ${resp.status} for ${url}`);
      const raw = await resp.json();
      const norm = normalizeGeoJSON(raw, "desertDams", basinRefCenter || EXPECTED_CENTER);
      const res = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });

      res.entities.values.forEach(e => {
        // Style points (gold)
        if (e.position) {
          e.billboard = undefined;
          e.point = {
            pixelSize: 11,
            color: Cesium.Color.GOLD.withAlpha(0.95),
            outlineColor: Cesium.Color.BLACK.withAlpha(0.85),
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          };
        }

        // Hidden label (optional)
        const p = e.properties;
        const nm = (p?.Dam_Name?.getValue?.() ?? p?.DAM_NAME?.getValue?.() ?? p?.Name?.getValue?.() ?? p?.NAME?.getValue?.() ?? 'Desert Dam');

        e.label = new Cesium.LabelGraphics({
          text: String(nm),
          show: false,
          font: '12px sans-serif',
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 3,
          pixelOffset: new Cesium.Cartesian2(0, -14),
          disableDepthTestDistance: Number.POSITIVE_INFINITY
        });

        // ‚úÖ Tag for click-details panel
        e.assetType = 'desert_dam';
        e.assetId = (p?.WH_No?.getValue?.() ?? p?.WH_NO?.getValue?.() ?? p?.ID?.getValue?.() ?? null);
        e.assetName = String(nm);
      });

      viewer.dataSources.add(res);
      layers['sites'] = res;

      console.log('‚úÖ Desert Dams (Inventory) loaded:', res.entities.values.length);
    } catch (e) {
      console.error('‚ùå Desert Dams load error', e);
      alert(`Failed to load ${DESERT_DAMS_GEOJSON}. Put it next to index.html and run with Live Server.`);
    }
  }

// ============================
  // LOD1 BUILDINGS (GeoJSON -> 3D extrusion)
  // ============================
  async function loadBuildingsLayer() {
    // Load LoD1 buildings from Cesium ion only (GeoJSON asset).
    // This reduces local I/O and improves loading performance for large building datasets.

    // Unique asset ID for the Mujib LoD1 building GeoJSON uploaded to Cesium ion.
    // See https://community.cesium.com/t/sand-castle-load-geojson-and-extrude-code-snippet/29559 for
    // an example of using Cesium.IonResource.fromAssetId() to load a GeoJSON asset„Äê649233657762722‚Ä†L108-L121„Äë.
    const ION_BUILDINGS_ASSET_ID = 4472713;

    // Load the GeoJSON directly from Cesium ion (no local fallback).
    let raw = null;
    try {
      const ionResource = await Cesium.IonResource.fromAssetId(ION_BUILDINGS_ASSET_ID);
      raw = await ionResource.fetchJson();
    } catch (err) {
      console.error('‚ùå Ion loading for LoD1 buildings failed:', err);
    }

    console.log(`‚è≥ Loading LoD1 buildings: ion asset ${ION_BUILDINGS_ASSET_ID}`);


    try {
      if (!raw) {
        throw new Error(`No buildings GeoJSON returned from Cesium ion (asset ${ION_BUILDINGS_ASSET_ID})`);
      }

      const norm = normalizeGeoJSON(raw, "buildings", basinRefCenter || EXPECTED_CENTER);
      const ds = await Cesium.GeoJsonDataSource.load(norm.obj, { clampToGround: true });

      const entities = ds.entities.values;

      function getPropNumber(props, key) {
        if (!props || !props[key]) return null;
        const v = props[key];
        const x = (typeof v.getValue === "function")
          ? v.getValue(Cesium.JulianDate.now())
          : v;
        const n = Number(x);
        return Number.isFinite(n) ? n : null;
      }

      function getFirstPropNumber(props, keys) {
        for (const k of keys) {
          const n = getPropNumber(props, k);
          if (Number.isFinite(n)) return { n, key: k };
        }
        return { n: null, key: null };
      }

      let extruded = 0;

      for (const e of entities) {
        if (!e.polygon) continue;

        const props = e.properties;

        // Height defaults: prefer explicit height, else derive from levels, else fallback.
        let h = null;
        let hSrc = null;

        const hh = getFirstPropNumber(props, [
          'height','Height','HEIGHT','building_height','Building_Height','bldg_h','bldgHeight'
        ]);
        if (Number.isFinite(hh.n)) {
          h = hh.n;
          hSrc = hh.key;
        }

        if (!Number.isFinite(h)) {
          const lv = getFirstPropNumber(props, [
            'levels','Levels','LEVELS','building:levels','BUILDING_LEVELS','floors','Floors','FLOORS','num_levels','NUM_LEVELS'
          ]);
          if (Number.isFinite(lv.n)) {
            // Typical storey height ~3m
            h = Math.max(3, lv.n * 3.0);
            hSrc = `${lv.key}√ó3m`;
          }
        }

        if (!Number.isFinite(h)) { h = 10; hSrc = "default (10m)"; }

        const now = Cesium.JulianDate.now();

        function flattenHierarchy(h) {
          if (!h || !h.positions) return h;
          const flatPositions = h.positions.map((p) => {
            const c = Cesium.Cartographic.fromCartesian(p);
            return Cesium.Cartesian3.fromRadians(c.longitude, c.latitude, 0.0);
          });
          const flatHoles = (h.holes || []).map((hole) => flattenHierarchy(hole));
          return new Cesium.PolygonHierarchy(flatPositions, flatHoles);
        }

        try {
          const hierarchy = e.polygon.hierarchy && e.polygon.hierarchy.getValue
            ? e.polygon.hierarchy.getValue(now)
            : e.polygon.hierarchy;
          if (hierarchy && hierarchy.positions && hierarchy.positions.length) {
            e.polygon.hierarchy = flattenHierarchy(hierarchy);
          }
        } catch (err) {}

        e.polygon.perPositionHeight = false;

        e.polygon.height = 0.0;
        e.polygon.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;

        e.polygon.extrudedHeight = h;
        e.polygon.extrudedHeightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;

        e.polygon.outline = false;
        e.polygon.material = Cesium.Color.LIGHTGRAY.withAlpha(0.75);

        // ‚úÖ Tag for click-details panel (show building height)
        e.assetType = "building";
        e.buildingHeight = h;
        e.heightSource = hSrc;
        e.assetId = propAny(props, ["id","ID","identificatie","Identificatie","bag_id","BAG_ID","pand_id","Pand_ID","pandid","PANDID","building_id","Building_ID"]);
        const bName = propAny(props, ["name","Name","building_name","Building_Name","pandnaam","PandNaam"]);
        e.assetName = bName || (e.assetId ? ("Building " + e.assetId) : "Building");


        extruded += 1;
      }

      viewer.dataSources.add(ds);
      layers["buildings"] = ds;

      console.log(`‚úÖ LoD1 buildings loaded: ${entities.length} entities (${extruded} extruded)`);

      viewer.scene.globe.depthTestAgainstTerrain = false;

      // Do not auto-fly to the buildings layer; keep the camera in the same
      // position to avoid jumping to unintended locations.  Users can still
      // manually zoom to buildings using the asset panel or other controls.
      // await viewer.flyTo(ds, { offset: new Cesium.HeadingPitchRange(0, -0.55, 9000) });

    } catch (e) {
      console.error("Buildings load error", e);
      alert(
        "Failed to load LoD1 buildings from Cesium ion.\n" +
        ("Ion asset ID: " + ION_BUILDINGS_ASSET_ID + "\n") +
        "Check that your access token has permission to this asset and that the asset has finished processing in Cesium ion."
      );
    }
  }

  // ============================
  // MAP TOGGLE (Œî alternates for numeric metrics only)
  // ============================
  function toggleHeatmap() {
    const a = getActiveSubbasinLayerInfo();
    if (!a.ds) { alert("Subbasins are still loading..."); return; }

    heatmapOn = !heatmapOn;

    if (heatmapOn) {
      // Delta mode only makes sense for SWAT 71 + scenario JSON.
      const canDelta = !!scenarioData && isActiveSwatLayer() && (metricSelect.value !== "decision");
      isDeltaMode = canDelta ? !isDeltaMode : false;
      applyMapStyle();
    } else {
      resetSubbasinColors();
    }
  }

  // ============================
  // CHART + CONTROLS
  // ============================
  function refreshAll() {
    if (currentSubbasinId != null) {
      updateSubInfoLine(currentSubbasinId);

      // Update weather selected location using representative point (ALL429 locations JSON)
      (async function(){
        try {
          await loadSubLocations().catch(()=>{});
          const key = String(currentSubbasinId);
          const loc = (typeof SUB_LOC === "object" && SUB_LOC && SUB_LOC[key]) ? SUB_LOC[key] : null;
          if (loc) {
            const lat = Number(loc.lat), lon = Number(loc.lon);
            if (Number.isFinite(lat) && Number.isFinite(lon)) setWeatherSelectedLocation(lat, lon, `Subbasin ${currentSubbasinId}`);
          }
          if (activeChartTab === "weather") showWeatherPanel();
        } catch (e) {}
      })();

      updateKpisForSubbasin(currentSubbasinId);
      updateRankLists();

      if (activeChartTab === "climate") {
        showClimateForSubbasin(currentSubbasinId);
      } else {
        updateChart(currentSubbasinId);
      }
    }
    if (heatmapOn) {
      const vm = (document.getElementById("viewModeSelect")?.value) || "absolute";
      isDeltaMode = (vm !== "absolute");
      isPercentMode = (vm === "pct");
      if (metricSelect.value === "decision") { isDeltaMode = false; isPercentMode = false; }
      applyMapStyle();
    }
  }

  
  // ============================
  // SUBBASIN INFO + KPI + RANKING (Decision-support)
  // ============================
  function getViewMode() {
    return (document.getElementById("viewModeSelect")?.value) || "absolute";
  }

  function fmtSigned(x, digits=1) {
    if (!Number.isFinite(x)) return "‚Äî";
    const s = (x > 0) ? "+" : (x < 0 ? "‚àí" : "");
    const v = Math.abs(x).toFixed(digits);
    return s + v;
  }

  async function updateSubInfoLine(subId) {
    const el = document.getElementById("subInfoLine");
    if (!el) return;

    await loadSubLocations().catch(()=>{});
    await loadSubPlacesOptional().catch(()=>{});

    const loc = SUB_LOC ? SUB_LOC[String(subId)] : null;
    const latlon = loc ? `${Number(loc.lat).toFixed(5)}, ${Number(loc.lon).toFixed(5)}` : "‚Äî";

    // Optional place/admin
    const pl = (SUB_PLACE && SUB_PLACE[String(subId)]) ? SUB_PLACE[String(subId)] : null;
    const place = pl?.place || pl?.name || null;
    const admin = pl?.admin || pl?.governorate || pl?.district || null;

    const parts = [
      `Subbasin ${subId}`,
      `Lat/Lon: ${latlon}`
    ];
    if (place) parts.push(`Near: ${place}`);
    if (admin) parts.push(`${admin}`);

    el.textContent = parts.join(" ‚Ä¢ ");
  }

  function updateKpisForSubbasin(subId) {
    const row = document.getElementById("kpiRow");
    const kR = document.getElementById("kpiRunoff");
    const kS = document.getElementById("kpiSediment");
    const kG = document.getElementById("kpiRecharge");
    if (!row || !kR || !kS || !kG) return;

    const hasHydro = !!(scenarioData && scenarioData[`Subbasin_${subId}`]);
    if (!hasHydro) { row.style.display = "none"; return; }

    const vm = getViewMode();
    const sc = scenarioSelect.value;

    const baseRun = getAnnualValue(subId, "baseline", "runoff");
    const baseSed = getAnnualValue(subId, "baseline", "sediment");
    const baseGwd = getAnnualValue(subId, "baseline", "groundwater");

    const selRun = getAnnualValue(subId, sc, "runoff");
    const selSed = getAnnualValue(subId, sc, "sediment");
    const selGwd = getAnnualValue(subId, sc, "groundwater");

    function changeText(base, sel, label, unit, digitsAbs=1, digitsPct=1) {
      if (!Number.isFinite(base) || !Number.isFinite(sel)) return `${label}: ‚Äî`;
      if (vm === "absolute") return `${label}: ${Number(sel).toFixed(digitsAbs)}${unit}`;
      const d = Number(sel) - Number(base);
      if (vm === "delta") return `${label}: ${fmtSigned(d, digitsAbs)}${unit}`;
      if (Math.abs(Number(base)) < 1e-9) return `${label}: ‚Äî`;
      const p = (d / Number(base)) * 100.0;
      return `${label}: ${fmtSigned(p, digitsPct)}%`;
    }

    kR.textContent = changeText(baseRun, selRun, "Runoff", " mm", 1, 1);
    kS.textContent = changeText(baseSed, selSed, "Sediment", " t/ha", 2, 1);
    kG.textContent = changeText(baseGwd, selGwd, "Recharge", " mm", 1, 1);

    row.style.display = "flex";
  }

  function updateRankLists() {
    const rankPanel = document.getElementById("rankPanel");
    const winEl = document.getElementById("topWinners");
    const loseEl = document.getElementById("topLosers");
    if (!rankPanel || !winEl || !loseEl) return;

    const vm = getViewMode();
    const metric = metricSelect.value;

    // Only meaningful for scenario-enabled metrics
    if (vm === "absolute" || metric === "decision" || !scenarioData) {
      rankPanel.style.display = "none";
      winEl.innerHTML = "";
      loseEl.innerHTML = "";
      return;
    }

    const sc = scenarioSelect.value;

    // Build list from scenarioData keys (SWAT 71 only)
    const ids = Object.keys(scenarioData || {})
      .filter(k => k.startsWith("Subbasin_"))
      .map(k => Number(k.replace("Subbasin_", "")))
      .filter(n => Number.isFinite(n));

    const vals = [];
    for (const id of ids) {
      const v = getScenarioMetricValue(id, sc, metric);
      if (Number.isFinite(v)) vals.push({ id, v: Number(v) });
    }

    if (vals.length < 3) {
      rankPanel.style.display = "none";
      winEl.innerHTML = "";
      loseEl.innerHTML = "";
      return;
    }

    vals.sort((a,b)=>a.v-b.v);
    const losers = vals.slice(0, 10);
    const winners = vals.slice(-10).reverse();

    const unit = (vm === "pct") ? "%" : (metric === "sediment" ? " t/ha" : " mm");

    function li(x){
      const vtxt = (vm === "pct") ? `${fmtSigned(x.v, 1)}%` : `${fmtSigned(x.v, (metric === "sediment" ? 2 : 1))}${unit}`;
      return `<li>SUB ${x.id}: <span style="color:#fff; font-weight:700;">${vtxt}</span></li>`;
    }

    winEl.innerHTML = winners.map(li).join("");
    loseEl.innerHTML = losers.map(li).join("");

    rankPanel.style.display = "block";
  }


  // ============================
  // CLIMATE (ERA5) PANEL
  // ============================

  function setChartTab(tabName) {
    // Weather is handled as a lightweight modal + top widget (no charts).
    if (tabName === "weather") {
      openWeatherModal();
      return;
    }

    activeChartTab = tabName;

    const hydroBtn = document.getElementById("tabHydrology");
    const climBtn  = document.getElementById("tabClimate");
    const soilBtn  = document.getElementById("tabSoil");
    const weatBtn  = document.getElementById("tabWeather");

    const hydroTab = document.getElementById("hydrologyTab");
    const climTab  = document.getElementById("climateTab");
    const soilTab  = document.getElementById("soilTab");
    const weatTab  = document.getElementById("weatherTab");

    // Reset visibility
    if (hydroTab) hydroTab.style.display = "none";
    if (climTab)  climTab.style.display  = "none";
    if (soilTab)  soilTab.style.display  = "none";
    if (weatTab)  weatTab.style.display  = "none";

    // Reset active states
    if (hydroBtn) hydroBtn.classList.remove("active");
    if (climBtn)  climBtn.classList.remove("active");
    if (soilBtn)  soilBtn.classList.remove("active");
    if (weatBtn)  weatBtn.classList.remove("active");

    if (tabName === "climate") {
      if (climBtn) climBtn.classList.add("active");
      if (climTab) climTab.style.display = "block";
      if (currentSubbasinId != null) showClimateForSubbasin(currentSubbasinId);
      return;
    }

    if (tabName === "soil") {
      if (soilBtn) soilBtn.classList.add("active");
      if (soilTab) soilTab.style.display = "block";
      showSoilPanel();
      return;
    }

    // Default: hydrology
    if (hydroBtn) hydroBtn.classList.add("active");
    if (hydroTab) hydroTab.style.display = "block";
  }

  async function loadERA5Climate() {
    if (era5ClimateCache) return era5ClimateCache;
    if (era5ClimatePromise) return era5ClimatePromise;

    era5ClimatePromise = (async () => {
      const url = withCacheBust(ERA5_CLIMATE_JSON);
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      era5ClimateCache = await res.json();
      console.log("‚úÖ ERA5 climate JSON loaded:", Object.keys(era5ClimateCache || {}).length, "subbasins");
      return era5ClimateCache;
    })();

    return era5ClimatePromise;
  }

  function climateClassFromPct(pct) {
    const p = Number(pct);
    if (!Number.isFinite(p)) return { label: "‚Äî", tone: "neutral" };
    if (p >= 90) return { label: "Very wet", tone: "wet" };
    if (p >= 80) return { label: "Wet", tone: "wet" };
    if (p <= 10) return { label: "Very dry", tone: "dry" };
    if (p <= 20) return { label: "Dry", tone: "dry" };
    return { label: "Near normal", tone: "neutral" };
  }

  function pill(text, tone="neutral") {
    const el = document.createElement("div");
    el.className = "climatePill";
    el.textContent = text;

    // Professional, subtle tints (no loud colors)
    if (tone === "wet") {
      el.style.borderColor = "rgba(102,252,241,0.45)";
      el.style.color = "#66fcf1";
      el.style.background = "rgba(102,252,241,0.10)";
    } else if (tone === "dry") {
      el.style.borderColor = "rgba(255,204,128,0.55)";
      el.style.color = "#ffcc80";
      el.style.background = "rgba(255,204,128,0.10)";
    }
    return el;
  }

  function destroyClimateChart() {
    try { if (climateChart) climateChart.destroy(); } catch(_) {}
    climateChart = null;
  }

function updateClimateChart(months, p, clim, anom) {
    const ctx = document.getElementById("climateChart").getContext("2d");

    // Keep charts readable: show last ~10 years (120 months) if available
    const n = months.length;
    const k = Math.max(0, n - 120);

    const x = months.slice(k);
    const pS = p.slice(k);
    const cS = clim.slice(k);
    const aS = anom.slice(k);

    destroyClimateChart();

    climateChart = new Chart(ctx, {
      data: {
        labels: x,
        datasets: [
          {
            type: "bar",
            label: "Monthly P (mm)",
            data: pS,
            backgroundColor: "rgba(102,252,241,0.22)",
            borderColor: "rgba(102,252,241,0.65)",
            borderWidth: 1,
            yAxisID: "yP"
          },
          {
            type: "line",
            label: "Climatology (mm)",
            data: cS,
            borderColor: "rgba(197,198,199,0.85)",
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.25,
            yAxisID: "yP"
          },
          {
            type: "line",
            label: "Anomaly (mm)",
            data: aS,
            borderColor: "rgba(255,204,128,0.85)",
            borderWidth: 2,
            pointRadius: 0,
            tension: 0.25,
            yAxisID: "yA"
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            labels: { color: "#c5c6c7" }
          },
          tooltip: {
            mode: "index",
            intersect: false
          }
        },
        interaction: { mode: "index", intersect: false },
        scales: {
          x: {
            ticks: { color: "#aab", maxRotation: 0, autoSkip: true, maxTicksLimit: 12 },
            grid: { color: "rgba(255,255,255,0.06)" }
          },
          yP: {
            position: "left",
            title: { display: true, text: "Rainfall (mm/month)", color: "#c5c6c7" },
            ticks: { color: "#c5c6c7" },
            grid: { color: "rgba(255,255,255,0.06)" }
          },
          yA: {
            position: "right",
            title: { display: true, text: "Anomaly (mm)", color: "#c5c6c7" },
            ticks: { color: "#c5c6c7" },
            grid: { drawOnChartArea: false }
          }
        }
      }
    });
  }

async function showClimateForSubbasin(subId) {
    const statusEl = document.getElementById("climateStatus");
    const pillsEl = document.getElementById("climatePills");

    // Clear pills
    if (pillsEl) pillsEl.innerHTML = "";

    try {
      const data = await loadERA5Climate();

      // Add lat/lon context (ALL 429)
      await loadSubLocations().catch(()=>{});
      const loc = SUB_LOC ? SUB_LOC[String(subId)] : null;
      const locTxt = loc ? `Lat/Lon: ${Number(loc.lat).toFixed(5)}, ${Number(loc.lon).toFixed(5)} ‚Ä¢ ` : "";
      const key = String(subId);
      const d = data?.[key];

      if (!d || !d.month || !d.month.length) {
        destroyClimateChart();
        if (statusEl) statusEl.textContent = `ERA5 climate is not available for sub-basin ${subId} (no grid overlap in the processed mosaic).`;
        if (pillsEl) pillsEl.appendChild(pill(`SUB ${subId}`));
        return;
      }

      const n = d.month.length - 1;
      const latestMonth = d.month[n];
      const latestP = d.p?.[n];
      const latestAnom = d.anom?.[n];
      const latestPct = d.pct?.[n];

      const cls = climateClassFromPct(latestPct);

      if (statusEl) {
        const pTxt = Number.isFinite(Number(latestP)) ? `${Number(latestP).toFixed(1)} mm` : "‚Äî";
        const aVal = Number(latestAnom);
        const aTxt = Number.isFinite(aVal) ? `${aVal >= 0 ? "+" : ""}${aVal.toFixed(1)} mm` : "‚Äî";
        const pctVal = Number(latestPct);
        const pctTxt = Number.isFinite(pctVal) ? `${pctVal.toFixed(0)}th pct` : "‚Äî";
        statusEl.textContent = `Latest: ${latestMonth} ‚Ä¢ P ${pTxt} ‚Ä¢ Anom ${aTxt} ‚Ä¢ ${pctTxt}`;
      }

      if (pillsEl) {
        pillsEl.appendChild(pill(`SUB ${subId}`));
        pillsEl.appendChild(pill(cls.label, cls.tone));
        pillsEl.appendChild(pill("Source: ERA5"));
        pillsEl.appendChild(pill("View: last 10 years"));
      }

      updateClimateChart(d.month, d.p || [], d.clim || [], d.anom || []);
    } catch (err) {
      console.error("ERA5 climate error:", err);
      destroyClimateChart();
      if (statusEl) statusEl.textContent = "Could not load ERA5 climate JSON. Ensure 'era5_precip_monthly_ALL429_compact.json' is next to this HTML file and served via Live Server.";
      if (pillsEl) pillsEl.appendChild(pill(`SUB ${subId}`));
    }
  }

  // ============================
  // SOIL MOISTURE (ERA5-Land) PANEL
  // ============================

  function parseMonthStringToDate(s) {
    if (!s) return null;
    const m = String(s).match(/^(\d{4})-(\d{2})/);
    if (!m) return null;
    const y = Number(m[1]);
    const mo = Number(m[2]);
    if (!Number.isFinite(y) || !Number.isFinite(mo) || mo < 1 || mo > 12) return null;
    return new Date(y, mo - 1, 1);
  }

  function meanOf(nums) {
    const a = (nums || []).filter(v => Number.isFinite(Number(v))).map(Number);
    if (!a.length) return NaN;
    return a.reduce((s, v) => s + v, 0) / a.length;
  }

  function quantileSorted(sorted, q) {
    if (!sorted || !sorted.length) return NaN;
    const qq = Math.min(1, Math.max(0, Number(q)));
    const pos = (sorted.length - 1) * qq;
    const base = Math.floor(pos);
    const rest = pos - base;
    const a = sorted[base];
    const b = sorted[Math.min(sorted.length - 1, base + 1)];
    return a + rest * (b - a);
  }

  function rollingMean(arr, win = 3) {
    const out = new Array(arr.length).fill(null);
    const w = Math.max(1, Number(win) || 3);
    for (let i = 0; i < arr.length; i++) {
      if (i < w - 1) continue;
      const slice = arr.slice(i - (w - 1), i + 1).filter(v => Number.isFinite(Number(v))).map(Number);
      out[i] = slice.length ? (slice.reduce((s, v) => s + v, 0) / slice.length) : null;
    }
    return out;
  }

  async function loadSoilMoistureSeries() {
    if (soilDataCache) return soilDataCache;
    if (soilDataPromise) return soilDataPromise;

    soilDataPromise = (async () => {
      const candidates = [SOIL_MOISTURE_CSV, SOIL_MOISTURE_FALLBACK_CSV];
      let lastErr = null;

      for (const path of candidates) {
        try {
          const url = withCacheBust(path);
          const res = await fetch(url);
          if (!res.ok) throw new Error(`HTTP ${res.status} for ${path}`);
          const text = await res.text();

          let rows = [];
          if (window.Papa) {
            const parsed = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
            const data = parsed?.data || [];
            rows = data.map(r => {
              const ds = r?.date ?? r?.Date ?? r?.month ?? r?.time;
              const sm = Number(r?.sm_0_28_mean ?? r?.sm ?? r?.soil_moisture ?? r?.SM);
              const dt = parseMonthStringToDate(ds);
              return (dt && Number.isFinite(sm)) ? { ym: String(ds), date: dt, sm } : null;
            }).filter(Boolean);
          } else {
            // Fallback parser: expects the simplified 2-column CSV.
            const lines = text.split(/\r?\n/).filter(Boolean);
            const header = (lines.shift() || '').split(',');
            const iDate = header.indexOf('date');
            const iSm = header.indexOf('sm_0_28_mean');
            for (const line of lines) {
              const parts = line.split(',');
              const ds = parts[iDate];
              const sm = Number(parts[iSm]);
              const dt = parseMonthStringToDate(ds);
              if (dt && Number.isFinite(sm)) rows.push({ ym: String(ds), date: dt, sm });
            }
          }

          if (!rows.length) throw new Error(`No valid rows parsed from ${path}`);
          rows.sort((a, b) => a.date - b.date);
          soilSourceUsed = path;
          soilDataCache = rows;
          console.log("‚úÖ Soil moisture loaded:", rows.length, "months from", path);
          return soilDataCache;
        } catch (err) {
          lastErr = err;
        }
      }

      throw lastErr || new Error("Could not load soil moisture CSV.");
    })();

    return soilDataPromise;
  }

  function computeSoilSummary(rows) {
    const baselineStart = 2015, baselineEnd = 2017;
    const recentStart = 2023, recentEnd = 2025;

    const vals = rows.map(r => r.sm);
    const roll3 = rollingMean(vals, 3);

    // Baseline monthly climatology (2015‚Äì2017)
    const mBuckets = Array.from({ length: 12 }, () => []);
    rows.forEach(r => {
      const y = r.date.getFullYear();
      if (y >= baselineStart && y <= baselineEnd) {
        mBuckets[r.date.getMonth()].push(r.sm);
      }
    });
    const clim = mBuckets.map(b => meanOf(b));
    const anom = rows.map(r => {
      const c = clim[r.date.getMonth()];
      return Number.isFinite(c) ? (r.sm - c) : null;
    });
    const anomRoll3 = rollingMean(anom, 3);

    // Baseline vs recent means
    const baseMean = meanOf(rows.filter(r => {
      const y = r.date.getFullYear();
      return y >= baselineStart && y <= baselineEnd;
    }).map(r => r.sm));

    const recentMean = meanOf(rows.filter(r => {
      const y = r.date.getFullYear();
      return y >= recentStart && y <= recentEnd;
    }).map(r => r.sm));

    const pctChange = (Number.isFinite(baseMean) && Math.abs(baseMean) > 1e-12 && Number.isFinite(recentMean))
      ? ((recentMean - baseMean) / baseMean) * 100.0
      : NaN;

    // Baseline vs recent monthly means (per calendar month)
    const baseMonthly = Array.from({ length: 12 }, (_, m) => {
      const arr = rows.filter(r => {
        const y = r.date.getFullYear();
        return y >= baselineStart && y <= baselineEnd && r.date.getMonth() === m;
      }).map(r => r.sm);
      return meanOf(arr);
    });
    const recentMonthly = Array.from({ length: 12 }, (_, m) => {
      const arr = rows.filter(r => {
        const y = r.date.getFullYear();
        return y >= recentStart && y <= recentEnd && r.date.getMonth() === m;
      }).map(r => r.sm);
      return meanOf(arr);
    });

    // Last 10 years window (120 months)
    const latest = rows[rows.length - 1]?.date;
    const start10 = latest ? new Date(latest.getFullYear(), latest.getMonth(), 1) : null;
    if (start10) start10.setMonth(start10.getMonth() - 119);

    const last10 = start10 ? rows.filter(r => r.date >= start10) : rows.slice();
    const last10Vals = last10.map(r => r.sm).filter(v => Number.isFinite(v)).sort((a, b) => a - b);
    const p20 = quantileSorted(last10Vals, 0.2);
    const p80 = quantileSorted(last10Vals, 0.8);

    // Classification for strip + dry spells
    const classed = last10.map(r => {
      let cls = "normal";
      if (Number.isFinite(p20) && r.sm <= p20) cls = "dry";
      else if (Number.isFinite(p80) && r.sm >= p80) cls = "wet";
      return { ...r, cls };
    });

    // Top driest months (last 10 years)
    const topDriest = [...classed]
      .sort((a, b) => a.sm - b.sm)
      .slice(0, 10)
      .map(r => ({ ym: r.ym, sm: r.sm }));

    // Driest year (last 10 years) by mean SM
    const byYear = {};
    classed.forEach(r => {
      const y = r.date.getFullYear();
      if (!byYear[y]) byYear[y] = [];
      byYear[y].push(r.sm);
    });
    const yearStats = Object.keys(byYear).map(y => ({
      year: Number(y),
      mean: meanOf(byYear[y])
    })).filter(o => Number.isFinite(o.mean));
    yearStats.sort((a, b) => a.mean - b.mean);
    const driestYear = yearStats.length ? yearStats[0] : null;

    // Dry spell stats (consecutive dry months)
    let longest = 0;
    let longestStart = null;
    let longestEnd = null;
    let current = 0;
    let currentStart = null;
    let dryMonths = 0;

    for (const r of classed) {
      if (r.cls === "dry") {
        dryMonths += 1;
        current += 1;
        if (!currentStart) currentStart = r.ym;
        if (current > longest) {
          longest = current;
          longestStart = currentStart;
          longestEnd = r.ym;
        }
      } else {
        current = 0;
        currentStart = null;
      }
    }

    return {
      rows,
      labels: rows.map(r => r.ym),
      sm: vals,
      roll3,
      clim,
      anom,
      anomRoll3,
      baseMean,
      recentMean,
      pctChange,
      baseMonthly,
      recentMonthly,
      last10: classed,
      p20,
      p80,
      topDriest,
      driestYear,
      dryMonths,
      longestDrySpell: { months: longest, start: longestStart, end: longestEnd },
      windowStart: start10 ? `${start10.getFullYear()}-${String(start10.getMonth() + 1).padStart(2, '0')}` : null,
      windowEnd: latest ? `${latest.getFullYear()}-${String(latest.getMonth() + 1).padStart(2, '0')}` : null
    };
  }

  function destroySoilChart() {
    if (soilChart) { soilChart.destroy(); soilChart = null; }
  }

  function renderSoilChart(summary) {
    const canvas = document.getElementById("soilChart");
    if (!canvas) return;
    const ctx = canvas.getContext("2d");

    destroySoilChart();

    const labels = summary.labels;
    const unit = "m¬≥/m¬≥";

    // Ensure the zoom plugin is registered before chart creation
    __registerZoomPluginIfNeeded();

    if (soilMode === 'anomaly') {
      // Anomaly view: display deviation from baseline and smoothed anomalies (no bars)
      soilChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: `Anomaly vs baseline (2015‚Äì2017)`,
              data: summary.anom,
              borderColor: "rgba(255,204,128,0.65)",
              backgroundColor: "rgba(255,204,128,0.20)",
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.25,
              yAxisID: "yA"
            },
            {
              label: "Smoothed (3‚Äëmonth average)",
              data: summary.anomRoll3,
              borderColor: "rgba(102,252,241,0.85)",
              backgroundColor: "rgba(102,252,241,0.25)",
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.25,
              yAxisID: "yA"
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: "#c5c6c7" } },
            tooltip: { mode: "index", intersect: false },
            zoom: {
              pan: { enabled: true, mode: 'x' },
              zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
            }
          },
          interaction: { mode: "index", intersect: false },
          scales: {
            x: {
              ticks: { color: "#aab", maxRotation: 0, autoSkip: true, maxTicksLimit: 12 },
              grid: { color: "rgba(255,255,255,0.06)" }
            },
            yA: {
              position: "left",
              title: { display: true, text: `Soil moisture anomaly (${unit})`, color: "#c5c6c7" },
              ticks: { color: "#c5c6c7" },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
      return;
    }

    // Monthly comparison view: compare baseline vs recent means for each calendar month
    const monthLabels = [
      'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
    ];
    soilChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: monthLabels,
        datasets: [
          {
            label: `Baseline (2015‚Äì2017)`,
            data: summary.baseMonthly,
            backgroundColor: 'rgba(255,204,128,0.60)',
            borderColor: 'rgba(255,204,128,0.85)',
            borderWidth: 1,
            yAxisID: 'y'
          },
          {
            label: `Recent (2023‚Äì2025)`,
            data: summary.recentMonthly,
            backgroundColor: 'rgba(102,252,241,0.60)',
            borderColor: 'rgba(102,252,241,0.85)',
            borderWidth: 1,
            yAxisID: 'y'
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { labels: { color: '#c5c6c7' } },
          tooltip: { mode: 'index', intersect: false },
          zoom: {
            pan: { enabled: true, mode: 'x' },
            zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
          }
        },
        interaction: { mode: 'index', intersect: false },
        scales: {
          x: {
            ticks: { color: '#aab', maxRotation: 0, autoSkip: false },
            grid: { color: 'rgba(255,255,255,0.06)' }
          },
          y: {
            position: 'left',
            title: { display: true, text: `Soil moisture (${unit})`, color: '#c5c6c7' },
            ticks: { color: '#c5c6c7' },
            grid: { color: 'rgba(255,255,255,0.06)' }
          }
        }
      }
    });
  }

  function updateSoilPanelUI(summary) {
    const statusEl = document.getElementById("soilStatus");
    const pillsEl = document.getElementById("soilPills");

    const fmt = (v) => (Number.isFinite(v) ? Number(v).toFixed(3) : "‚Äî");
    const fmtPct = (v) => (Number.isFinite(v) ? `${v >= 0 ? "+" : ""}${Number(v).toFixed(1)}%` : "‚Äî");

    const baseEl = document.getElementById("soilBaselineMean");
    const recEl = document.getElementById("soilRecentMean");
    const chgEl = document.getElementById("soilPctChange");
    if (baseEl) baseEl.textContent = fmt(summary.baseMean);
    if (recEl) recEl.textContent = fmt(summary.recentMean);
    if (chgEl) chgEl.textContent = fmtPct(summary.pctChange);

    // Update equivalent water depth (mm) values beneath the means
    const baseMMEl = document.getElementById("soilBaselineMM");
    const recMMEl = document.getElementById("soilRecentMM");
    if (baseMMEl) baseMMEl.textContent = (Number.isFinite(summary.baseMean) ? (summary.baseMean * 280).toFixed(1) : "‚Äî");
    if (recMMEl) recMMEl.textContent = (Number.isFinite(summary.recentMean) ? (summary.recentMean * 280).toFixed(1) : "‚Äî");

    // Status line: show data source, analysis window and baseline/recent ranges clearly
    if (statusEl) {
      if (summary.windowStart && summary.windowEnd) {
        statusEl.textContent = `Data: ERA5‚ÄëLand monthly mean, 0‚Äì28 cm ‚Ä¢ Analysis window: ${summary.windowStart} to ${summary.windowEnd} ‚Ä¢ Baseline: 2015‚Äì2017 | Recent: 2023‚Äì2025`;
      } else {
        statusEl.textContent = `Data: ERA5‚ÄëLand monthly mean, 0‚Äì28 cm`;
      }
    }

    // Pills
    if (pillsEl) {
      pillsEl.innerHTML = "";
      pillsEl.appendChild(pill("Source: ERA5-Land"));
      pillsEl.appendChild(pill(`Mode: ${soilMode === 'anomaly' ? 'anomaly' : 'monthly comparison'}`));
      if (Number.isFinite(summary.p20) && Number.isFinite(summary.p80)) {
        pillsEl.appendChild(pill(`Dry threshold (bottom 20%): ${Number(summary.p20).toFixed(3)}`, "dry"));
        pillsEl.appendChild(pill(`Wet threshold (top 20%): ${Number(summary.p80).toFixed(3)}`, "wet"));
      }
    }

    // Top driest months list
    const list = document.getElementById("soilTopDriestMonths");
    if (list) {
      list.innerHTML = summary.topDriest.map(o => `<li>${o.ym}: <span style="color:#fff; font-weight:700;">${Number(o.sm).toFixed(3)}</span></li>`).join("");
    }

    // Driest year + dry spell
    const yearEl = document.getElementById("soilDriestYear");
    if (yearEl) {
      if (summary.driestYear) {
        yearEl.textContent = `${summary.driestYear.year} (mean ${Number(summary.driestYear.mean).toFixed(3)})`;
      } else {
        yearEl.textContent = "‚Äî";
      }
    }

    const spellEl = document.getElementById("soilDrySpell");
    if (spellEl) {
      const L = summary.longestDrySpell?.months || 0;
      if (L > 0) {
        spellEl.textContent = `Dry months: ${summary.dryMonths} ‚Ä¢ Longest dry spell: ${L} months (${summary.longestDrySpell.start} ‚Üí ${summary.longestDrySpell.end})`;
      } else {
        spellEl.textContent = `Dry months: ${summary.dryMonths} ‚Ä¢ Longest dry spell: ‚Äî`;
      }
    }

    // Dry/Normal/Wet strip
    const strip = document.getElementById("soilClassStrip");
    if (strip) {
      strip.innerHTML = "";
      for (const r of summary.last10) {
        const d = document.createElement("div");
        d.title = `${r.ym}: ${r.cls} (${Number(r.sm).toFixed(3)})`;
        if (r.cls === 'dry') d.style.background = "rgba(255,204,128,0.85)";
        else if (r.cls === 'wet') d.style.background = "rgba(102,252,241,0.75)";
        else d.style.background = "rgba(255,255,255,0.18)";
        strip.appendChild(d);
      }
    }
  }

  async function showSoilPanel() {
    const statusEl = document.getElementById("soilStatus");
    const pillsEl = document.getElementById("soilPills");
    if (pillsEl) pillsEl.innerHTML = "";

    try {
      if (statusEl) statusEl.textContent = "Loading soil moisture‚Ä¶";
      const rows = await loadSoilMoistureSeries();
      const summary = computeSoilSummary(rows);
      updateSoilPanelUI(summary);
      renderSoilChart(summary);
    } catch (err) {
      console.error("Soil moisture error:", err);
      destroySoilChart();
      if (statusEl) {
        const hint = `Could not load soil moisture CSV. Make sure the files are served by Live Server and the paths are correct.\n\nExpected (relative): ${SOIL_MOISTURE_CSV} (or fallback: ${SOIL_MOISTURE_FALLBACK_CSV})`;
        statusEl.textContent = hint;
      }
      if (pillsEl) pillsEl.appendChild(pill("Soil moisture: not loaded"));
    }
  }


  function updateChart(subbasinId) {
    if (!scenarioData) { alert("Scenario data still loading..."); return; }

    const metric = metricSelect.value;
    const chartMetric = (metric === "decision") ? "runoff" : metric;

    updateSubInfoLine(subbasinId);
    updateKpisForSubbasin(subbasinId);
    updateRankLists();

    const pack = getWhatifObject(subbasinId);
    const wKey = pack?.wKey || "dP0_dT0";
    const wObj = pack?.wObj;
    const node = pack?.node;

    const monthly = wObj?.monthly || node?.monthly;

    const sNames = ["baseline", "marab", "vallerani", "combined"];
    const colors = {
      baseline: "#FBC02D",
      marab: "#66BB6A",
      vallerani: "#29B6F6",
      combined: "#AB47BC"
    };

    const labels = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

    const datasets = sNames.map(s => ({
      label: `${s.toUpperCase()} (${wKey})`,
      data: monthly?.[s]?.[chartMetric] || [],
      borderColor: colors[s],
      backgroundColor: colors[s] + "22",
      tension: 0.35,
      fill: false
    }));

    const title = `SUB ${subbasinId} | ${chartMetric.toUpperCase()} | what-if ${wKey}`;

    const ctx = document.getElementById('swatChart').getContext('2d');
    if (myChart) myChart.destroy();

    myChart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: { display: true, text: title, color: 'white', font: { size: 14 } },
          legend: { labels: { color: 'white' } }
        },
        scales: {
          y: { ticks: { color:'#ccc' }, grid: { color:'#333' } },
          x: { ticks: { color:'#ccc' }, grid: { color:'#333' } }
        }
      }
    });
  }

  
  // ============================
  // WEATHER (Open-Meteo) ‚Äî short-term forecast
  // ============================
  function _fmt1(x){ return Number.isFinite(x) ? x.toFixed(1) : "‚Äî"; }
  function _fmt0(x){ return Number.isFinite(x) ? Math.round(x).toString() : "‚Äî"; }

  function _cartesianToLonLat(cart) {
    if (!Cesium.defined(cart)) return null;
    const c = Cesium.Cartographic.fromCartesian(cart);
    return { lon: Cesium.Math.toDegrees(c.longitude), lat: Cesium.Math.toDegrees(c.latitude) };
  }

  function _entityLonLat(entity) {
    try {
      const now = Cesium.JulianDate.now();

      // Prefer explicit position (points, labels)
      if (entity && entity.position && entity.position.getValue) {
        const cart = entity.position.getValue(now);
        const ll = _cartesianToLonLat(cart);
        if (ll) return ll;
      } else if (entity && entity.position) {
        const ll = _cartesianToLonLat(entity.position);
        if (ll) return ll;
      }

      // Polygon centroid (average of vertices ‚Äî fast approximation)
      if (entity && entity.polygon && entity.polygon.hierarchy && entity.polygon.hierarchy.getValue) {
        const h = entity.polygon.hierarchy.getValue(now);
        const positions = (h && h.positions) ? h.positions : null;
        if (positions && positions.length) {
          let sumLat = 0, sumLon = 0, n = 0;
          for (const p of positions) {
            const ll = _cartesianToLonLat(p);
            if (!ll) continue;
            sumLat += ll.lat; sumLon += ll.lon; n += 1;
          }
          if (n > 0) return { lat: sumLat / n, lon: sumLon / n };
        }
      }

      // Polyline midpoint (approx)
      if (entity && entity.polyline && entity.polyline.positions && entity.polyline.positions.getValue) {
        const pos = entity.polyline.positions.getValue(now);
        if (pos && pos.length) {
          const ll = _cartesianToLonLat(pos[Math.floor(pos.length / 2)]);
          if (ll) return ll;
        }
      }
    } catch (e) {}
    return null;
  }

  function setWeatherSelectedLocation(lat, lon, label) {
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
    weatherSelectedLocation = { lat, lon, label: label || "Selected location" };

    // Legacy weather tab meta (kept for compatibility, even though the tab is not shown)
    const meta = document.getElementById("weatherLocMeta");
    if (meta) {
      meta.textContent = `Location: ${weatherSelectedLocation.label} ‚Ä¢ ${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    }

    // Mini widget / modal meta
    const meta2 = document.getElementById("mwLocMeta");
    if (meta2 && (window.weatherMode === "selected")) {
      meta2.textContent = `${weatherSelectedLocation.label} ‚Ä¢ ${lat.toFixed(4)}, ${lon.toFixed(4)}`;
    }

    // If the current forecast mode is "selected", refresh the widget immediately.
    if (window.weatherMode === "selected") {
      try { updateMiniWeatherWidget(true); } catch (_) {}
    }
  }

  function initWeatherKeyDamsFromLayer(damsDs) {
    try {
      if (!damsDs || !damsDs.entities) return;

      const vals = damsDs.entities.values || [];
      function matchEntity(keys) {
        for (const e of vals) {
          const name = String(e.assetName || e.name || e.assetId || "").toLowerCase();
          for (const k of keys) {
            if (name.includes(k)) return e;
          }
          const p = e.properties;
          if (p) {
            const en = (p?.En_name?.getValue?.() ?? p?.EN_NAME?.getValue?.() ?? "").toLowerCase();
            const ar = (p?.Ar_Name?.getValue?.() ?? p?.AR_NAME?.getValue?.() ?? "").toLowerCase();
            for (const k of keys) {
              if (en.includes(k) || ar.includes(k)) return e;
            }
          }
        }
        return null;
      }

      const walaEnt = matchEntity(["wala"]);
      const mujibEnt = matchEntity(["mujib", "mojib", "mujeb"]);

      if (walaEnt) {
        const ll = _entityLonLat(walaEnt);
        if (ll) weatherKeyDams.wala = { lat: ll.lat, lon: ll.lon, label: "Wala Dam" };
      }
      if (mujibEnt) {
        const ll = _entityLonLat(mujibEnt);
        if (ll) weatherKeyDams.mujib = { lat: ll.lat, lon: ll.lon, label: "Mujib Dam" };
      }
      // Refresh mini weather widget once dam coordinates are available
      try { updateMiniWeatherWidget(true); } catch (_) {}
    } catch (e) {
      console.warn("Weather key dams init failed:", e);
    }
  }

  function getWeatherTargetFromUI() {
    const sel = document.getElementById("weatherLocSelect");
    const choice = sel ? sel.value : "wala";
    if (choice === "selected") return weatherSelectedLocation;
    const fallback = (basinRefCenter && Number.isFinite(basinRefCenter.lat) && Number.isFinite(basinRefCenter.lon))
      ? { lat: basinRefCenter.lat, lon: basinRefCenter.lon, label: "Basin center" }
      : null;

    if (choice === "mujib") return weatherKeyDams.mujib || weatherSelectedLocation || fallback;
    return weatherKeyDams.wala || weatherSelectedLocation || fallback;
  }

  async function fetchOpenMeteoForecast(lat, lon) {
    const tz = "Asia/Amman";
    const dailyVars = "precipitation_sum,temperature_2m_max,temperature_2m_min";
    const hourlyVars = "relative_humidity_2m";
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=${hourlyVars}&forecast_hours=1&daily=${dailyVars}&timezone=${encodeURIComponent(tz)}`;
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`Open-Meteo HTTP ${resp.status}`);
    return await resp.json();
  }

  function destroyWeatherChart() {
    try { if (weatherChart) { weatherChart.destroy(); weatherChart = null; } } catch (_) {}
  }

  function renderWeatherChart(payload) {
    const canvas = document.getElementById("weatherChart");
    if (!canvas || !payload || !payload.daily) return;

    const labels = payload.daily.time || [];
    const p = payload.daily.precipitation_sum || [];
    const tmax = payload.daily.temperature_2m_max || [];
    const tmin = payload.daily.temperature_2m_min || [];

    destroyWeatherChart();

    const ctx = canvas.getContext("2d");
    weatherChart = new Chart(ctx, {
      type: "bar",
      data: {
        labels,
        datasets: [
          { label: "Daily precipitation (mm)", data: p },
          { label: "T max (¬∞C)", type: "line", data: tmax, yAxisID: "y2", tension: 0.25, pointRadius: 0 },
          { label: "T min (¬∞C)", type: "line", data: tmin, yAxisID: "y2", tension: 0.25, pointRadius: 0 }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: "#c5c6c7", boxWidth: 12 } },
          tooltip: { mode: "index", intersect: false }
        },
        scales: {
          x: { ticks: { color: "#c5c6c7", maxRotation: 0, autoSkip: true } },
          y: { beginAtZero: true, ticks: { color: "#c5c6c7" }, title: { display: true, text: "mm/day", color: "#c5c6c7" } },
          y2: { position: "right", grid: { drawOnChartArea: false }, ticks: { color: "#c5c6c7" }, title: { display: true, text: "¬∞C", color: "#c5c6c7" } }
        }
      }
    });
  }

  function updateWeatherFlag(payload) {
    const flagEl = document.getElementById("weatherFlag");
    const thrEl = document.getElementById("weatherThreshold");
    const thr = thrEl ? Number(thrEl.value) : 10;

    if (!flagEl || !payload || !payload.daily || !Array.isArray(payload.daily.precipitation_sum)) {
      if (flagEl) { flagEl.className = "weatherFlag neutral"; flagEl.textContent = "Event flag: ‚Äî"; }
      return;
    }

    const p = payload.daily.precipitation_sum;
    let maxP = 0;
    for (let i = 0; i < Math.min(3, p.length); i++) {
      const v = Number(p[i]);
      if (Number.isFinite(v) && v > maxP) maxP = v;
    }

    if (maxP >= thr && thr > 0) {
      flagEl.className = "weatherFlag alert";
      flagEl.textContent = `Potential runoff event: max ${_fmt1(maxP)} mm/day (next 3 days)`;
    } else if (maxP >= 0.6 * thr && thr > 0) {
      flagEl.className = "weatherFlag warn";
      flagEl.textContent = `Watch: max ${_fmt1(maxP)} mm/day (next 3 days)`;
    } else {
      flagEl.className = "weatherFlag ok";
      flagEl.textContent = `No event flagged: max ${_fmt1(maxP)} mm/day (next 3 days)`;
    }
  }

  async function showWeatherPanel() {
    const statusEl = document.getElementById("weatherStatus");
    const nowEl = document.getElementById("weatherNowMeta");

    try {
      const target = getWeatherTargetFromUI();
      if (!target || !Number.isFinite(target.lat) || !Number.isFinite(target.lon)) {
        if (statusEl) statusEl.textContent = "Weather: select a location (or click on the map) to fetch forecast.";
        destroyWeatherChart();
        updateWeatherFlag(null);
        if (nowEl) nowEl.textContent = "Now: ‚Äî";
        return;
      }

      if (statusEl) statusEl.textContent = "Fetching forecast‚Ä¶";
      const payload = await fetchOpenMeteoForecast(target.lat, target.lon);

      const locMeta = document.getElementById("weatherLocMeta");
      if (locMeta) locMeta.textContent = `Location: ${target.label || "‚Äî"} ‚Ä¢ ${target.lat.toFixed(4)}, ${target.lon.toFixed(4)}`;

      if (payload && payload.current_weather && typeof payload.current_weather.temperature === "number") {
        const cw = payload.current_weather;
        if (nowEl) nowEl.textContent = `Now: ${_fmt1(cw.temperature)}¬∞C ‚Ä¢ wind ${_fmt0(cw.windspeed)} km/h`;
      } else {
        if (nowEl) nowEl.textContent = "Now: ‚Äî";
      }

      renderWeatherChart(payload);
      updateWeatherFlag(payload);
      if (statusEl) statusEl.textContent = "Forecast loaded.";
    } catch (e) {
      console.warn("Weather fetch error:", e);
      destroyWeatherChart();
      updateWeatherFlag(null);
      if (statusEl) statusEl.textContent = "Could not fetch forecast (check internet / API availability).";
      if (nowEl) nowEl.textContent = "Now: ‚Äî";
    }
  }

  // Hook weather UI events
  (function initWeatherUI() {
    try {
      const sel = document.getElementById("weatherLocSelect");
      const thr = document.getElementById("weatherThreshold");
      const btn = document.getElementById("weatherRefreshBtn");
      if (sel) sel.addEventListener("change", () => { if (activeChartTab === "weather") showWeatherPanel(); });
      if (thr) thr.addEventListener("change", () => { if (activeChartTab === "weather") showWeatherPanel(); });
      if (btn) btn.addEventListener("click", () => showWeatherPanel());
    } catch (e) {}
  })()

  // ----------------------------
  // MINI WEATHER WIDGET + MODAL (Open-Meteo) ‚Äî no charts
  // ----------------------------
  window.weatherMode = window.weatherMode || "wala"; // 'wala' | 'mujib' | 'selected'
  let _mwCache = { key: "", t: 0, payload: null };

  function _mwFmtDateShort(iso) {
    try {
      const dt = new Date(String(iso).slice(0, 10) + "T00:00:00");
      return dt.toLocaleDateString(undefined, { month: "short", day: "numeric" });
    } catch (_) {
      return iso;
    }
  }

  function getWeatherTarget(mode) {
    const m = mode || window.weatherMode || "wala";
    if (m === "mujib" && weatherKeyDams && weatherKeyDams.mujib) return weatherKeyDams.mujib;
    if (m === "wala" && weatherKeyDams && weatherKeyDams.wala) return weatherKeyDams.wala;
    if (m === "selected" && weatherSelectedLocation) return weatherSelectedLocation;

    // Fallback priority
    if (weatherKeyDams && weatherKeyDams.wala) return weatherKeyDams.wala;
    if (weatherKeyDams && weatherKeyDams.mujib) return weatherKeyDams.mujib;
    if (weatherSelectedLocation) return weatherSelectedLocation;
    return null;
  }

  function _mwNextPrecip(payload) {
    try {
      const d = payload && payload.daily;
      if (!d || !Array.isArray(d.time) || !Array.isArray(d.precipitation_sum)) return null;

      // Find the first day with meaningful precipitation
      for (let i = 0; i < Math.min(7, d.time.length); i++) {
        const p = Number(d.precipitation_sum[i] ?? 0);
        if (Number.isFinite(p) && p > 0.2) return { idx: i, date: d.time[i], mm: p };
      }

      // Otherwise return the maximum within 7 days (for a "dry week" summary)
      let maxP = 0, maxi = -1;
      for (let i = 0; i < Math.min(7, d.time.length); i++) {
        const p = Number(d.precipitation_sum[i] ?? 0);
        if (Number.isFinite(p) && p > maxP) { maxP = p; maxi = i; }
      }
      if (maxi >= 0) return { idx: null, date: d.time[maxi], mm: maxP, none: true };
    } catch (_) {}
    return null;
  }

  function updateWeatherModalDetails(payload, target) {
    const metaEl = document.getElementById("mwLocMeta");
    const nowEl = document.getElementById("mwNowLine");
    const tableEl = document.getElementById("mwTableBody");
    const statusEl = document.getElementById("mwStatus");

    if (metaEl && target && Number.isFinite(target.lat) && Number.isFinite(target.lon)) {
      metaEl.textContent = `${target.label || "Location"} ‚Ä¢ ${target.lat.toFixed(4)}, ${target.lon.toFixed(4)}`;
    }

    if (payload && payload.current_weather) {
      const cw = payload.current_weather;
      const t = (typeof cw.temperature === "number") ? `${cw.temperature.toFixed(1)}¬∞C` : "‚Äî¬∞C";
      const w = (typeof cw.windspeed === "number") ? ` ‚Ä¢ wind ${Math.round(cw.windspeed)} km/h` : "";
      const hum = (payload && payload.hourly && Array.isArray(payload.hourly.relative_humidity_2m)) ? payload.hourly.relative_humidity_2m[0] : null;
      const htxt = (typeof hum === "number") ? ` ‚Ä¢ humidity ${Math.round(hum)}%` : "";
      if (nowEl) nowEl.textContent = `Now: ${t}${w}${htxt}`;
    } else {
      if (nowEl) nowEl.textContent = "Now: ‚Äî";
    }

    // 7-day table
    if (tableEl) {
      let rows = "";
      const d = payload && payload.daily;
      if (d && Array.isArray(d.time)) {
        const n = Math.min(7, d.time.length);
        for (let i = 0; i < n; i++) {
          const date = _mwFmtDateShort(d.time[i]);
          const p = Number(d.precipitation_sum?.[i] ?? 0);
          const tmin = Number(d.temperature_2m_min?.[i]);
          const tmax = Number(d.temperature_2m_max?.[i]);

          const pTxt = Number.isFinite(p) ? p.toFixed(1) : "‚Äî";
          const tTxt = (Number.isFinite(tmin) && Number.isFinite(tmax)) ? `${tmin.toFixed(1)}‚Äì${tmax.toFixed(1)}¬∞C` : "‚Äî";

          rows += `<tr><td>${date}</td><td style="text-align:right;">${pTxt}</td><td style="text-align:right;">${tTxt}</td></tr>`;
        }
      } else {
        rows = `<tr><td colspan="3" style="color:#9aa;">No forecast available.</td></tr>`;
      }
      tableEl.innerHTML = rows;
    }

    if (statusEl) statusEl.textContent = payload ? "Forecast loaded." : "Forecast unavailable.";
  }

  async function updateMiniWeatherWidget(force = false) {
    const locEl = document.getElementById("mwLoc");
    const tempEl = document.getElementById("mwTemp");
    const nowMiniEl = document.getElementById("mwNowMini");
    const eventEl = document.getElementById("mwEvent");
    const barFill = document.getElementById("mwBarFill");

    const target = getWeatherTarget();
    if (!target || !Number.isFinite(target.lat) || !Number.isFinite(target.lon)) {
      if (locEl) locEl.textContent = "Weather";
      if (tempEl) tempEl.textContent = "‚Äî¬∞C";
      if (nowMiniEl) nowMiniEl.textContent = "Wind ‚Äî km/h ‚Ä¢ Humid ‚Äî%";
      if (eventEl) eventEl.textContent = "Click a point or choose a dam";
      if (barFill) barFill.style.width = "0%";
      return;
    }

    const locLabel = (window.weatherMode === "selected")
      ? (target.label || "Selected")
      : (target.label || "Location");

    if (locEl) locEl.textContent = locLabel;

    const key = `${window.weatherMode}|${target.lat.toFixed(4)},${target.lon.toFixed(4)}`;
    const now = Date.now();
    const ttl = 10 * 60 * 1000; // 10 minutes

    let payload = null;
    if (!force && _mwCache.payload && _mwCache.key === key && (now - _mwCache.t) < ttl) {
      payload = _mwCache.payload;
    } else {
      try {
        payload = await fetchOpenMeteoForecast(target.lat, target.lon);
        _mwCache = { key, t: now, payload };
      } catch (e) {
        if (tempEl) tempEl.textContent = "‚Äî¬∞C";
        if (eventEl) eventEl.textContent = "Forecast unavailable";
        if (barFill) barFill.style.width = "0%";
        updateWeatherModalDetails(null, target);
        return;
      }
    }

    // Temperature
    if (payload && payload.current_weather && typeof payload.current_weather.temperature === "number") {
      if (tempEl) tempEl.textContent = `${payload.current_weather.temperature.toFixed(1)}¬∞C`;
    } else {
      if (tempEl) tempEl.textContent = "‚Äî¬∞C";
    }

    
    // Wind + humidity (current)
    if (nowMiniEl) {
      const cw = payload && payload.current_weather ? payload.current_weather : null;
      const ws = (cw && typeof cw.windspeed === "number") ? Math.round(cw.windspeed) : null;
      const hum = (payload && payload.hourly && Array.isArray(payload.hourly.relative_humidity_2m)) ? payload.hourly.relative_humidity_2m[0] : null;
      const wsTxt = (typeof ws === "number") ? `Wind ${ws} km/h` : "Wind ‚Äî km/h";
      const humTxt = (typeof hum === "number") ? `Humid ${Math.round(hum)}%` : "Humid ‚Äî%";
      nowMiniEl.textContent = `${wsTxt} ‚Ä¢ ${humTxt}`;
    }

// Next precipitation (daily)
    const nxt = _mwNextPrecip(payload);
    if (!nxt) {
      if (eventEl) eventEl.textContent = "No precipitation in 7 days";
      if (barFill) barFill.style.width = "0%";
    } else if (nxt.idx === 0) {
      if (eventEl) eventEl.textContent = `Precipitation today: ${Number(nxt.mm).toFixed(1)} mm`;
      if (barFill) barFill.style.width = "0%";
    } else if (typeof nxt.idx === "number") {
      const days = nxt.idx;
      if (eventEl) eventEl.textContent = `Next precipitation in ${days} day${days === 1 ? "" : "s"}: ${Number(nxt.mm).toFixed(1)} mm`;
      const frac = Math.max(0, Math.min(1, days / 7));
      if (barFill) barFill.style.width = `${Math.round(frac * 100)}%`;
    } else {
      if (eventEl) eventEl.textContent = `Dry week (max ${Number(nxt.mm).toFixed(1)} mm on ${_mwFmtDateShort(nxt.date)})`;
      if (barFill) barFill.style.width = "100%";
    }

    // Keep modal in sync if it is open
    const modal = document.getElementById("weatherMiniModal");
    if (modal && modal.style.display !== "none") {
      updateWeatherModalDetails(payload, target);
    }
  }

  
  // Toggle small info tooltip for the mini weather widget (data source + variables)
  function toggleMwInfo(ev){
    if(ev) ev.stopPropagation();
    const tip = document.getElementById("mwInfoTooltip");
    if(!tip) return;
    const isOn = (tip.style.display === "block");
    tip.style.display = isOn ? "none" : "block";
  }

  // Toggle small info tooltip for the soil moisture comparison (baseline vs recent)
  function toggleSoilInfo(ev){
    // Toggle inline explanation for soil moisture baseline vs recent.  This does not use the
    // floating tooltip (soilInfoTooltip); instead it reveals a small info box beneath the
    // heading so users can read the explanation in context.
    if(ev) ev.stopPropagation();
    const el = document.getElementById('soilInfoContent');
    if(!el) return;
    const show = el.style.display !== 'block';
    el.style.display = show ? 'block' : 'none';
    // After toggling, adjust the parent panel height so the content is not clipped.
    const container = el.closest('.chartTabPane') || el.closest('.layer-panel');
    if(container && container.style.maxHeight){
      container.style.maxHeight = container.scrollHeight + 'px';
    }
  }

  // Hide tooltip on any outside click
  (function(){
    document.addEventListener("click", function(){
      const tip = document.getElementById("mwInfoTooltip");
      if(tip) tip.style.display = "none";
      // Hide any inline soil moisture explanation if visible.
      const soilCnt = document.getElementById('soilInfoContent');
      if(soilCnt) soilCnt.style.display = 'none';
    }, true);
  })();

function openWeatherModal() {
    try { const tip = document.getElementById("mwInfoTooltip"); if (tip) tip.style.display = "none"; } catch (_) {}

    const modal = document.getElementById("weatherMiniModal");
    if (!modal) return;
    modal.style.display = "flex";

    const sel = document.getElementById("mwLocSelect");
    if (sel) sel.value = window.weatherMode || "wala";

    updateMiniWeatherWidget(true);
  }

  function closeWeatherModal() {
    const modal = document.getElementById("weatherMiniModal");
    if (modal) modal.style.display = "none";
  }

  // Wire modal controls + periodic refresh
  (function initMiniWeatherUI() {
    try {
      const sel = document.getElementById("mwLocSelect");
      const btn = document.getElementById("mwRefreshBtn");

      if (sel) sel.addEventListener("change", () => {
        window.weatherMode = sel.value;
        updateMiniWeatherWidget(true);
      });

      if (btn) btn.addEventListener("click", () => updateMiniWeatherWidget(true));

      // Initial refresh: allow time for dam layers to load, then fetch forecast
      setTimeout(() => updateMiniWeatherWidget(true), 1200);

      // Periodic refresh (lightweight, cached)
      setInterval(() => updateMiniWeatherWidget(false), 10 * 60 * 1000);
    } catch (_) {}
  })();
;



  // ============================
  // CLICK INTERACTION (subbasins + assets)
  // ============================
  viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
    // NDVI value (anywhere): only when a NDVI layer is active
    try {
      if (ndviUI && ndviUI.activeMode) {
        const mode = ndviUI.activeMode;
        const ds = ndviUI.datasets[mode];

        // Try pickPosition (terrain), fallback to ellipsoid
        let cartesian = null;
        if (viewer.scene.pickPositionSupported) {
          cartesian = viewer.scene.pickPosition(movement.position);
        }
        if (!Cesium.defined(cartesian)) {
          cartesian = viewer.camera.pickEllipsoid(movement.position, viewer.scene.globe.ellipsoid);
        }

        const rect = viewer.canvas.getBoundingClientRect();
        const pageX = rect.left + movement.position.x;
        const pageY = rect.top + movement.position.y;

        if (!Cesium.defined(cartesian)) {
          hideNdviTooltip();
        } else {
          const carto = Cesium.Cartographic.fromCartesian(cartesian);
          const lon = Cesium.Math.toDegrees(carto.longitude);
          const lat = Cesium.Math.toDegrees(carto.latitude);

          // If dataset not ready yet, show loading once
          if (!ds || !ds.ready) {
            showNdviTooltipAt(pageX, pageY, `NDVI (${mode})`, 'loading‚Ä¶', '');
            // kick load (no await so UI stays responsive)
            ensureNdviDatasetLoaded(mode);
          } else {
            const v = ndviValueAtLonLat(lon, lat, mode);
            if (v === null || !Number.isFinite(v)) {
              hideNdviTooltip();
            } else {
              const label = classifyNdvi(v, mode);
              const title = (mode === 'baseline')
                ? 'Baseline NDVI (2015‚Äì2017)'
                : (mode === 'recent')
                  ? 'Recent NDVI (2023‚Äì2025)'
                  : 'Œî NDVI (2023‚Äì2025 ‚àí 2015‚Äì2017)';

              const valText = (mode === 'delta')
                ? ((v >= 0 ? '+' : '') + v.toFixed(3))
                : v.toFixed(3);

              showNdviTooltipAt(pageX, pageY, title, valText, label);
            }
          }
        }
      } else {
        hideNdviTooltip();
      }
    } catch (e) {
      console.warn('NDVI click probe error:', e);
    }


    // drillPick so buildings don't block clicks
    // Increase drillPick limit so buildings remain pickable under subbasin polygons.
    const picks = viewer.scene.drillPick(movement.position, 50);

    let asset = null;
    let building = null;
    let sub = null;

    for (const p of picks) {
      const e = p?.id;
      if (!e) continue;

      if (e.assetType === "flood_station" || e.assetType === "dam" || e.assetType === "desert_dam") {
        asset = e;
        break; // prioritize assets over subbasins
      }

      if (e.assetType === "building" && !building) {
        building = e;
      }

      if (e.subbasinId != null && !sub) {
        sub = e;
      }
    }

    // 1) Assets
    if (asset) {
      if (asset.assetType === "flood_station") {
        clickStatus.textContent = `Flood Station ${asset.assetId || ''}`.trim();
        clickStatus.className = 'ok';
        renderFloodStationPanel(asset);
        try { const ll = _entityLonLat(asset); if (ll) setWeatherSelectedLocation(ll.lat, ll.lon, (`Flood station ${asset.assetId || ''}`).trim()); } catch (_) {}
        return;
      }

      if (asset.assetType === "dam") {
        clickStatus.textContent = `Dam ${asset.assetId || ''}`.trim();
        clickStatus.className = 'ok';
        renderDamPanel(asset);
        try { const ll = _entityLonLat(asset); if (ll) setWeatherSelectedLocation(ll.lat, ll.lon, (asset.assetName || `Dam ${asset.assetId || ''}`).trim()); } catch (_) {}
        return;
      }

      if (asset.assetType === "desert_dam") {
        clickStatus.textContent = `Desert Dam ${asset.assetId || ''}`.trim();
        clickStatus.className = 'ok';
        renderDesertDamPanel(asset);
        try { const ll = _entityLonLat(asset); if (ll) setWeatherSelectedLocation(ll.lat, ll.lon, (`Desert dam ${asset.assetId || ''}`).trim()); } catch (_) {}
        return;
      }
    }

    // 2) Buildings
    if (building) {
      const h = Number.isFinite(building.buildingHeight) ? building.buildingHeight : null;
      clickStatus.textContent = `Building${h !== null ? (' ‚Ä¢ H ' + h + ' m') : ''}`;
      clickStatus.className = 'ok';
      renderBuildingPanel(building);
      return;
    }

    // 3) Subbasins
    if (sub && sub.subbasinId != null) {
      // Labels are shown only for the selected sub-basin.
      if (selectedSubbasinEntity && selectedSubbasinEntity.label) {
        try { selectedSubbasinEntity.label.show = false; } catch (_) {}
      }
      selectedSubbasinEntity = sub;
      if (selectedSubbasinEntity.label) {
        selectedSubbasinEntity.label.show = true;
      }

      currentSubbasinId = sub.subbasinId;

      // Subbasin info line (lat/lon + optional nearest place)
      updateSubInfoLine(currentSubbasinId);

      clickStatus.textContent = `SUB ${currentSubbasinId} ‚úÖ`;
      clickStatus.className = 'ok';

      hideAssetPanel();
      // Chart panel (Hydrology + Climate)
      document.getElementById('chartPanel').style.display = 'block';

      // Hydrology scenarios exist only for Subbasin_1..Subbasin_71 (SWAT)
      const hasHydro = !!(scenarioData && scenarioData[`Subbasin_${currentSubbasinId}`]);
      const noticeEl = document.getElementById('hydrologyNotice');

      if (noticeEl) noticeEl.style.display = hasHydro ? 'none' : 'block';

      // KPI pills + winners/losers lists
      updateKpisForSubbasin(currentSubbasinId);
      updateRankLists();

      if (hasHydro) {
        // Default to hydrology unless the climate tab is already active
        if (activeChartTab !== 'climate') setChartTab('hydrology');
        updateChart(currentSubbasinId);
      } else {
        // No SWAT time series for this subbasin -> keep Hydrology clean, switch to Climate
        try { if (myChart) myChart.destroy(); } catch(_) {}
        myChart = null;
        setChartTab('climate');
      }

      // Always refresh Climate for the clicked subbasin (cached after first load)
      showClimateForSubbasin(currentSubbasinId);
      return;
    }

    // 3) Nothing useful picked
    // Set Selected (last click) location for Weather when clicking empty space
    try {
      let cart = null;
      if (viewer.scene.pickPositionSupported) cart = viewer.scene.pickPosition(movement.position);
      if (!Cesium.defined(cart)) cart = viewer.camera.pickEllipsoid(movement.position, viewer.scene.globe.ellipsoid);
      const ll = _cartesianToLonLat(cart);
      if (ll) {
        setWeatherSelectedLocation(ll.lat, ll.lon, "Map point");
        if (activeChartTab === "weather") showWeatherPanel();
      }
    } catch (_) {}


    clickStatus.textContent = `none`;
    clickStatus.className = 'warn';
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  // ============================
  // CLIMATE FULL VIEW MODAL (reuse existing chart data; no re-fetch / no re-compute)
  // ============================
  let climateModalChart = null;
  // Soil modal chart instance (used for full‚Äëview zoomable chart)
  let soilModalChart = null;

  function __safeDeepClone(obj){
    try { return JSON.parse(JSON.stringify(obj)); } catch { return obj; }
  }

  function __registerZoomPluginIfNeeded(){
    try {
      if (!window.Chart || typeof window.Chart.register !== "function") return;
      const zp = window.ChartZoom || window["chartjs-plugin-zoom"] || window.ChartjsPluginZoom;
      if (zp && !window.__zoomPluginRegistered) {
        window.Chart.register(zp);
        window.__zoomPluginRegistered = true;
      }
    } catch(_) {}
  }

  function openClimateModal(){
    const overlay = document.getElementById("climateModal");
    const bigCanvas = document.getElementById("climateChartBig");
    if (!overlay || !bigCanvas) return;

    if (!climateChart) {
      alert("Climate chart is not ready yet. Click a sub-basin first.");
      return;
    }

    __registerZoomPluginIfNeeded();

    overlay.style.display = "flex";

    try { if (climateModalChart) climateModalChart.destroy(); } catch(_) {}
    climateModalChart = null;

    const ctx = bigCanvas.getContext("2d");
    const data = __safeDeepClone(climateChart.data);
    const options = __safeDeepClone(climateChart.options) || {};

    options.responsive = true;
    options.maintainAspectRatio = false;

    // Make axes readable in the large view
    if (options.scales?.x?.ticks) {
      options.scales.x.ticks.maxTicksLimit = 24;
      options.scales.x.ticks.autoSkip = true;
      options.scales.x.ticks.font = Object.assign({}, options.scales.x.ticks.font || {}, { size: 12 });
    }
    if (options.scales?.yP?.ticks) {
      options.scales.yP.ticks.font = Object.assign({}, options.scales.yP.ticks.font || {}, { size: 12 });
    }
    if (options.scales?.yA?.ticks) {
      options.scales.yA.ticks.font = Object.assign({}, options.scales.yA.ticks.font || {}, { size: 12 });
    }
    if (options.scales?.yP?.title) {
      options.scales.yP.title.font = Object.assign({}, options.scales.yP.title.font || {}, { size: 13, weight: "600" });
    }
    if (options.scales?.yA?.title) {
      options.scales.yA.title.font = Object.assign({}, options.scales.yA.title.font || {}, { size: 13, weight: "600" });
    }

    // Scroll / zoom friendly (modal only)
    options.plugins = options.plugins || {};
    options.plugins.zoom = {
      pan: { enabled: true, mode: "x" },
      zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: "x" },
      limits: { x: { min: "original", max: "original" } }
    };

    climateModalChart = new Chart(ctx, { data, options });
  }

  function closeClimateModal(){
    const overlay = document.getElementById("climateModal");
    if (overlay) overlay.style.display = "none";
    try { if (climateModalChart) climateModalChart.destroy(); } catch(_) {}
    climateModalChart = null;
  }

  // ============================
  // SOIL FULL VIEW MODAL
  // ============================
  function openSoilModal(){
    const overlay = document.getElementById("soilModal");
    const bigCanvas = document.getElementById("soilChartBig");
    if (!overlay || !bigCanvas) return;

    if (!soilChart) {
      alert("Soil chart is not ready yet. Click a sub-basin first.");
      return;
    }

    __registerZoomPluginIfNeeded();

    overlay.style.display = "flex";

    try { if (soilModalChart) soilModalChart.destroy(); } catch(_) {}
    soilModalChart = null;

    const ctx = bigCanvas.getContext("2d");
    const data = __safeDeepClone(soilChart.data);
    const options = __safeDeepClone(soilChart.options) || {};

    options.responsive = true;
    options.maintainAspectRatio = false;

    // Make axes readable in the large view
    if (options.scales?.x?.ticks) {
      options.scales.x.ticks.maxTicksLimit = 24;
      options.scales.x.ticks.autoSkip = true;
      options.scales.x.ticks.font = Object.assign({}, options.scales.x.ticks.font || {}, { size: 12 });
    }
    if (options.scales?.y?.ticks) {
      options.scales.y.ticks.font = Object.assign({}, options.scales.y.ticks.font || {}, { size: 12 });
    }
    if (options.scales?.yA?.ticks) {
      options.scales.yA.ticks.font = Object.assign({}, options.scales.yA.ticks.font || {}, { size: 12 });
    }
    if (options.scales?.y?.title) {
      options.scales.y.title.font = Object.assign({}, options.scales.y.title.font || {}, { size: 13, weight: "600" });
    }
    if (options.scales?.yA?.title) {
      options.scales.yA.title.font = Object.assign({}, options.scales.yA.title.font || {}, { size: 13, weight: "600" });
    }

    // Scroll / zoom friendly (modal only)
    options.plugins = options.plugins || {};
    options.plugins.zoom = {
      pan: { enabled: true, mode: "x" },
      zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: "x" },
      limits: { x: { min: "original", max: "original" } }
    };

    // Preserve the original chart type (bar for monthly comparison, line for anomaly)
    const chartType = soilChart?.config?.type || undefined;
    soilModalChart = new Chart(ctx, { type: chartType, data, options });
  }

  function closeSoilModal(){
    const overlay = document.getElementById("soilModal");
    if (overlay) overlay.style.display = "none";
    try { if (soilModalChart) soilModalChart.destroy(); } catch(_) {}
    soilModalChart = null;
  }

  // ============================
  // Response-based dynamic visualization (Rainfall ‚Üí Runoff ‚Üí Dam)
  // Phase 1: animated river flow lines + key dam "inflow rise"
  // ============================
  let __simRainOn = false;
  const __simCfg = {
    rainFactor: 1.20,      // +20% rainfall scenario (toggle)
    runoffElasticity: 1.75 // documented assumption: +20% P ‚Üí +35% runoff (SWAT elasticity)
  };
  let __simDamOverlays = [];
  let __riverTrailImg = null;

  function __runoffFactorFromRainFactor(rainFactor){
    const rf = Number(rainFactor);
    const e = Number(__simCfg.runoffElasticity);
    if (!Number.isFinite(rf) || !Number.isFinite(e)) return 1.0;
    return 1.0 + (rf - 1.0) * e;
  }

  function __ensureTrailImage(){
    if (__riverTrailImg) return __riverTrailImg;
    try {
      const c = document.createElement("canvas");
      c.width = 64; c.height = 1;
      const g = c.getContext("2d");
      const grad = g.createLinearGradient(0,0,64,0);
      grad.addColorStop(0.00, "rgba(255,255,255,0.0)");
      grad.addColorStop(0.45, "rgba(255,255,255,0.25)");
      grad.addColorStop(1.00, "rgba(255,255,255,1.0)");
      g.fillStyle = grad;
      g.fillRect(0,0,64,1);
      __riverTrailImg = c.toDataURL("image/png");
    } catch(_) {
      __riverTrailImg = null;
    }
    return __riverTrailImg;
  }

  function __ensurePolylineTrailMaterial(){
    if (!Cesium?.Material) return;
    if (Cesium.Material.PolylineTrailType) return;

    Cesium.Material.PolylineTrailType = "PolylineTrail";
    Cesium.Material.PolylineTrailSource = `
      czm_material czm_getMaterial(czm_materialInput materialInput)
      {
        czm_material material = czm_getDefaultMaterial(materialInput);
        vec2 st = materialInput.st;
        vec4 colorImage = texture(image, vec2(fract(st.s - time), st.t));
        material.alpha = colorImage.a * color.a;
        material.diffuse = color.rgb;
        return material;
      }`;

    Cesium.Material._materialCache.addMaterial(Cesium.Material.PolylineTrailType, {
      fabric: {
        type: Cesium.Material.PolylineTrailType,
        uniforms: {
          color: new Cesium.Color(0.0, 1.0, 1.0, 0.85),
          image: __ensureTrailImage(),
          time: 0
        },
        source: Cesium.Material.PolylineTrailSource
      },
      translucent: function(){ return true; }
    });

    function PolylineTrailMaterialProperty(options){
      this._definitionChanged = new Cesium.Event();
      this.color = options?.color || Cesium.Color.CYAN.withAlpha(0.85);
      this.speed = Number(options?.speed) || 0.18;
      this.image = options?.image || __ensureTrailImage();
    }
    Object.defineProperties(PolylineTrailMaterialProperty.prototype, {
      isConstant: { get: function(){ return false; } },
      definitionChanged: { get: function(){ return this._definitionChanged; } }
    });
    PolylineTrailMaterialProperty.prototype.getType = function(){ return Cesium.Material.PolylineTrailType; };
    PolylineTrailMaterialProperty.prototype.getValue = function(time, result){
      if (!Cesium.defined(result)) result = {};
      result.color = this.color;
      result.image = this.image;
      const seconds = (Cesium.JulianDate.toDate(time).getTime() / 1000.0);
      result.time = (seconds * this.speed) % 1.0;
      return result;
    };
    PolylineTrailMaterialProperty.prototype.equals = function(other){ return this === other; };

    window.PolylineTrailMaterialProperty = PolylineTrailMaterialProperty;
  }

  function __setRiverFlowAnimation(enabled, runoffFactor){
    const ds = layers["rivers"];
    if (!ds) return;

    if (enabled) __ensurePolylineTrailMaterial();

    const f = Math.max(0.8, Math.min(2.5, Number(runoffFactor) || 1.0));
    ds.entities.values.forEach(e => {
      if (!e.polyline) return;

      if (!e.__riverDefaultMaterial) e.__riverDefaultMaterial = e.polyline.material;
      if (!e.__riverDefaultWidth) e.__riverDefaultWidth = e.polyline.width;

      if (enabled && window.PolylineTrailMaterialProperty) {
        e.polyline.material = new window.PolylineTrailMaterialProperty({
          color: Cesium.Color.CYAN.withAlpha(0.85),
          speed: 0.14 + 0.12 * (f - 1.0),
          image: __ensureTrailImage()
        });
        const baseW = Number(e.__riverDefaultWidth) || 2;
        e.polyline.width = Math.min(7, baseW + 6 * (f - 1.0));
      } else {
        e.polyline.material = e.__riverDefaultMaterial;
        e.polyline.width = e.__riverDefaultWidth || 2;
      }
    });
  }

  function __clearDamOverlays(){
    try { __simDamOverlays.forEach(ent => viewer.entities.remove(ent)); } catch(_) {}
    __simDamOverlays = [];
  }

  function __pickKeyDams(damDs){
    const all = (damDs?.entities?.values) || [];
    const wala = all.filter(e => String(e.assetName || "").toLowerCase().includes("wala"));
    if (wala.length) return wala.slice(0, 1);
    return all.filter(e => !!e.position).slice(0, 3);
  }

  function __addDamOverlays(runoffFactor){
    const damDs = layers["dams"];
    if (!damDs) return;

    __clearDamOverlays();

    const dams = __pickKeyDams(damDs);
    const now = Cesium.JulianDate.now();
    const f = Math.max(0.8, Math.min(2.5, Number(runoffFactor) || 1.0));
    const pct = Math.round((f - 1.0) * 100);

    dams.forEach((e) => {
      if (!e.position) return;

      let pos = null;
      try { pos = e.position.getValue ? e.position.getValue(now) : e.position; } catch(_) {}
      if (!pos) return;

      const carto = Cesium.Cartographic.fromCartesian(pos);
      const lon = carto.longitude, lat = carto.latitude;
      let baseH = viewer.scene.globe.getHeight(carto);
      if (!Number.isFinite(baseH)) baseH = carto.height || 0;

      const targetLen = 55 * f;  // meters (visual)
      const startMs = (typeof performance !== "undefined" ? performance.now() : Date.now());

      const overlay = viewer.entities.add({
        polyline: {
          positions: new Cesium.CallbackProperty(function(){
            const nowMs = (typeof performance !== "undefined" ? performance.now() : Date.now());
            const t = Math.min(1.0, Math.max(0.0, (nowMs - startMs) / 1200.0));
            const cur = targetLen * t;
            return [
              Cesium.Cartesian3.fromRadians(lon, lat, baseH),
              Cesium.Cartesian3.fromRadians(lon, lat, baseH + cur)
            ];
          }, false),
          width: 10,
          material: Cesium.Color.AQUA.withAlpha(0.70),
          clampToGround: false
        },
        label: {
          text: `${e.assetName || "Dam"} ‚Ä¢ inflow ${pct >= 0 ? "+" : ""}${pct}%`,
          font: "12px sans-serif",
          fillColor: Cesium.Color.WHITE,
          outlineColor: Cesium.Color.BLACK,
          outlineWidth: 3,
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          pixelOffset: new Cesium.Cartesian2(0, -20),
          disableDepthTestDistance: Number.POSITIVE_INFINITY,
          showBackground: true,
          backgroundColor: Cesium.Color.BLACK.withAlpha(0.55),
          backgroundPadding: new Cesium.Cartesian2(6, 4)
        }
      });

      __simDamOverlays.push(overlay);
    });
  }

  async function toggleRainResponseSimulation(){
    __simRainOn = !__simRainOn;

    if (__simRainOn) {
      await toggleLayer("rivers", true);
      await toggleLayer("dams", true);
    }

    const btn = document.getElementById("simRainBtn");
    if (btn) {
      btn.classList.toggle("active", __simRainOn);
      btn.setAttribute("aria-pressed", __simRainOn ? "true" : "false");
      btn.textContent = __simRainOn ? "Stop Sim" : "+20% Rain";
      btn.title = __simRainOn ? "Stop simulation" : "Response-based simulation: Rainfall ‚Üí Runoff ‚Üí Dam";
    }

    const statusEl = document.getElementById("climateStatus");
    if (statusEl && !statusEl.dataset.baseText) statusEl.dataset.baseText = statusEl.textContent || "";

    if (__simRainOn) {
      const runoffFactor = __runoffFactorFromRainFactor(__simCfg.rainFactor);
      __setRiverFlowAnimation(true, runoffFactor);
      __addDamOverlays(runoffFactor);
      if (statusEl) statusEl.textContent = `Scenario: +20% rainfall ‚Üí ~+${Math.round((runoffFactor-1)*100)}% runoff (SWAT elasticity). Rivers animate; key dam shows inflow rise.`;
    } else {
      __setRiverFlowAnimation(false, 1.0);
      __clearDamOverlays();
      if (statusEl) statusEl.textContent = statusEl.dataset.baseText || statusEl.textContent;
    }
  }

  // Patch toggleLayer once to re-apply simulation visuals when a layer is toggled back on
  (function(){
    if (window.__toggleLayerPatched) return;
    window.__toggleLayerPatched = true;

    const __origToggleLayer = toggleLayer;
    toggleLayer = async function(id, isVisible){
      await __origToggleLayer(id, isVisible);
      if (!__simRainOn) return;
      const runoffFactor = __runoffFactorFromRainFactor(__simCfg.rainFactor);
      if (id === "rivers" && isVisible) __setRiverFlowAnimation(true, runoffFactor);
      if (id === "dams" && isVisible) __addDamOverlays(runoffFactor);
    };
  })();

  // UI hooks (Option A: click anywhere on the chart to expand)
  (function(){
    const c = document.getElementById("climateChart");
    if (c) {
      c.style.cursor = "zoom-in";
      c.addEventListener("click", openClimateModal);
    }
    const expandBtn = document.getElementById("climateExpandBtn");
    if (expandBtn) expandBtn.addEventListener("click", openClimateModal);

    const overlay = document.getElementById("climateModal");
    const closeBtn = document.getElementById("climateModalClose");
    if (closeBtn) closeBtn.addEventListener("click", closeClimateModal);
    if (overlay) {
      overlay.addEventListener("click", function(ev){
        if (ev.target === overlay) closeClimateModal();
      });
    }
    document.addEventListener("keydown", function(ev){
      if (ev.key === "Escape") closeClimateModal();
    });

    const simBtn = document.getElementById("simRainBtn");
    if (simBtn) simBtn.addEventListener("click", toggleRainResponseSimulation);

    // Soil moisture: toggle between monthly comparison and anomaly views
    const soilToggle = document.getElementById("soilToggleBtn");
    if (soilToggle) {
      soilToggle.addEventListener("click", () => {
        soilMode = (soilMode === 'compare') ? 'anomaly' : 'compare';
        // Update button label to reflect next action
        soilToggle.textContent = (soilMode === 'compare') ? 'Show Anomaly' : 'Show Monthly Comparison';
        // Refresh panel immediately if soil tab is visible
        const soilTab = document.getElementById("soilTab");
        if (soilTab && soilTab.style.display !== 'none') {
          showSoilPanel();
        }
      });
      // Initialise button text according to default mode
      soilToggle.textContent = (soilMode === 'compare') ? 'Show Anomaly' : 'Show Monthly Comparison';
    }

    // Soil zoom button ‚Üí open full view modal
    const soilZoom = document.getElementById("soilZoomBtn");
    if (soilZoom) {
      soilZoom.addEventListener("click", openSoilModal);
    }
    // Soil modal close button
    const soilClose = document.getElementById("soilModalClose");
    if (soilClose) {
      soilClose.addEventListener("click", closeSoilModal);
    }

    // Close soil modal with Escape key
    document.addEventListener("keydown", function(ev){
      if (ev.key === "Escape") closeSoilModal();
    });
  })();

  // ============================
  // UI Accordion + Init
  // ============================
  const acc = document.getElementsByClassName("category-btn");

  function collapseAllAccordions(exceptBtn = null){
    for (let j = 0; j < acc.length; j++) {
      const btn = acc[j];
      if (btn.classList.contains('analysis-btn')) continue;
      if (exceptBtn && btn === exceptBtn) continue;
      btn.classList.remove("active");
      const p = btn.nextElementSibling;
      if (p && p.classList && p.classList.contains("layer-panel")) {
        p.style.maxHeight = null;
      }
    }
  }

  for (let i = 0; i < acc.length; i++) {
    acc[i].addEventListener("click", function() {
      if (this.classList.contains('analysis-btn')) return;

      const panel = this.nextElementSibling;
      if (!panel || !(panel.classList && panel.classList.contains("layer-panel"))) return;

      const willOpen = !this.classList.contains("active");
      // Single-open accordion: opening one collapses the others.
      collapseAllAccordions(this);

      if (willOpen) {
        this.classList.add("active");
        panel.style.maxHeight = panel.scrollHeight + "px";
      } else {
        this.classList.remove("active");
        panel.style.maxHeight = null;
      }
    });
  }

  // Default UI on first run: keep all categories collapsed.
  collapseAllAccordions();

  // Load data + layers (sequential init ensures alignment: basin becomes the reference).
  (async () => {
    // Scenario JSON is optional for static runoff/sediment, but enables Œî mode + decision map.
    loadScenarioData();

    // Subbasin info (lat/lon + optional nearest place)
    loadSubLocations().catch(console.error);
    loadSubPlacesOptional().catch(()=>{});

    // Default on first run: show only the basin boundary (clean, top-level context).
    await toggleLayer('basin', true);
  })();
</script>

    <!-- ============================== -->
    <!-- Hydro-DT Assistant Chatbot -->
    <!-- ============================== -->
    <!-- Styles for the assistant -->
    <style>
      /* Hide the container by default */
      #assistantContainer.hide { display: none; }
      #assistantContainer {
        position: fixed;
        bottom: 80px;
        right: 20px;
        /* Compact default size (small on screen, like the original) */
        width: 270px;
        height: 380px;
        max-height: 52vh;
        min-height: 300px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        background: rgba(11,12,16,0.95);
        border: 1px solid #66fcf1;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        z-index: 1000;
        color: #c5c6c7;
        font-family: 'Roboto','Segoe UI',sans-serif;
      }
#assistantHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(255,255,255,0.10);
        background: rgba(15,20,30,0.9);
      }
      #assistantHeader .title {
        font-weight: 700;
        color: #66fcf1;
        font-size: 13px;
      }
      #assistantClose {
        background: none;
        border: none;
        color: #c5c6c7;
        font-size: 18px;
        cursor: pointer;
        transition: 0.2s;
      }
      #assistantClose:hover {
        color: #66fcf1;
      }
      #assistantMessages {
        /* Scrollable Q/A area */
        flex: 1 1 auto;
        min-height: 0; /* critical for flex children to scroll instead of pushing the input out */
        padding: 12px;
        overflow-y: auto;
        overscroll-behavior: contain;
        scrollbar-width: thin;
      }
      .assistant-message {
        margin-bottom: 8px;
        line-height: 1.4;
        font-size: 12px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .assistant-message.user {
        text-align: right;
        color: #66fcf1;
      }
      .assistant-message.bot {
        text-align: left;
        color: #c5c6c7;
      }
      #assistantChipsContainer {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 8px;
        border-top: 1px solid rgba(255,255,255,0.10);
        background: rgba(15,23,42,0.95);
        flex: 0 0 auto;
      }
      .chips-arrow {
        background: none;
        border: none;
        color: #66fcf1;
        font-size: 16px;
        cursor: pointer;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
      }
      .chips-arrow:disabled {
        color: rgba(102,252,241,0.3);
        cursor: default;
      }
      #assistantChips {
        flex: 1;
        display: flex;
        overflow-x: auto;
        gap: 6px;
        scroll-behavior: smooth;
      }
      .assistant-chip {
        font-size: 10px;
        padding: 4px 8px;
        background: rgba(69,162,158,0.15);
        border: 1px solid rgba(102,252,241,0.35);
        border-radius: 999px;
        color: #66fcf1;
        white-space: nowrap;
        cursor: pointer;
        user-select: none;
        transition: 0.15s;
      }
      .assistant-chip:hover {
        background: rgba(102,252,241,0.25);
      }
      #assistantSuggestions {
        position: absolute;
        bottom: 80px;
        right: 20px;
        width: 260px;
        background: rgba(11,12,16,0.95);
        border: 1px solid rgba(102,252,241,0.35);
        border-radius: 8px;
        max-height: 40vh;
        overflow-y: auto;
        display: none;
        z-index: 1001;
      }
      .suggestion-item {
        padding: 6px 10px;
        font-size: 12px;
        color: #c5c6c7;
        cursor: pointer;
      }
      .suggestion-item:hover {
        background: rgba(102,252,241,0.15);
        color: #66fcf1;
      }
      #assistantInputArea {
        display: flex;
        padding: 8px;
        border-top: 1px solid rgba(255,255,255,0.10);
        background: rgba(15,23,42,0.95);
        flex: 0 0 auto;
      }
      #assistantInput {
        flex: 1;
        padding: 6px 8px;
        background: rgba(0,0,0,0.4);
        border: 1px solid rgba(102,252,241,0.35);
        border-radius: 8px;
        color: #c5c6c7;
        font-size: 12px;
        outline: none;
      }
      #assistantSend {
        margin-left: 6px;
        padding: 6px 10px;
        background: #66fcf1;
        color: #0b0c10;
        border: none;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 700;
        cursor: pointer;
        transition: 0.2s;
      }
      #assistantSend:hover {
        background: #45a29e;
        color: #ffffff;
      }
      .assistant-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: #66fcf1;
        color: #0b0c10;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        /* Increase font size for the chatbot icon */
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 6px 16px rgba(0,0,0,0.5);
        transition: 0.2s;
      }
      .assistant-toggle:hover {
        background: #45a29e;
        color: #ffffff;
      }
      /* Disclaimer styling for the assistant */
      #assistantDisclaimer {
        padding: 8px 12px;
        font-size: 10.5px;
        line-height: 1.35;
        color: #9fa6b2;
        background: rgba(15,23,42,0.95);
        border-bottom: 1px solid rgba(255,255,255,0.08);
        /* Show the full disclaimer (no truncation/ellipsis) */
        white-space: normal;
        overflow: visible;
        flex: 0 0 auto;
      }

    /* ============================
       TOP BAR ACTIONS (Overview)
       ============================ */
    .topbarActionBtn{
      border: 1px solid rgba(102,252,241,0.45);
      background: rgba(69,162,158,0.12);
      color: #66fcf1;
      padding: 8px 12px;
      border-radius: 12px;
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: background 140ms ease, border-color 140ms ease, transform 140ms ease;
      white-space: nowrap;
    }
    .topbarActionBtn:hover{
      background: rgba(102,252,241,0.14);
      border-color: rgba(102,252,241,0.70);
      transform: translateY(-1px);
    }
    .topbarActionBtn:active{ transform: translateY(0px); }

    /* ============================
       OVERVIEW MODAL
       ============================ */
    .overviewModalCard{
      width: min(980px, 96vw);
      height: min(740px, 88vh);
    }
    .overviewBody{
      overflow: auto;
      padding: 14px 16px 18px 16px;
    }
    .overviewHeadline{
      font-weight: 900;
      font-size: 18px;
      color: #66fcf1;
      letter-spacing: 0.2px;
    }
    .overviewSubhead{
      margin-top: 4px;
      font-weight: 700;
      font-size: 12px;
      color: rgba(229,231,235,0.92);
    }
    .overviewText{
      margin: 10px 0 0;
      font-size: 13px;
      line-height: 1.5;
      color: rgba(197,198,199,0.95);
      max-width: 78ch;
    }
    .overviewGrid{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }
    .overviewCardSmall{
      background: rgba(31,40,51,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
    }
    .overviewCardTitle{
      font-weight: 900;
      font-size: 12px;
      letter-spacing: 0.08em;
      color: rgba(229,231,235,0.90);
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .overviewList{
      margin: 0;
      padding-left: 18px;
      color: rgba(197,198,199,0.95);
      font-size: 13px;
      line-height: 1.45;
    }
    .overviewDetails{
      margin-top: 14px;
      background: rgba(31,40,51,0.35);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .overviewDetails summary{
      cursor: pointer;
      color: #66fcf1;
      font-weight: 900;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      outline: none;
      user-select: none;
    }
    .overviewCases{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    .overviewLinkBtn{
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(102,252,241,0.35);
      background: rgba(0,0,0,0.18);
      color: rgba(229,231,235,0.96);
      text-decoration: none;
      font-weight: 800;
      font-size: 13px;
      transition: background 140ms ease, border-color 140ms ease, transform 140ms ease;
      min-height: 74px;
    }
    .overviewLinkBtn:hover{
      background: rgba(102,252,241,0.10);
      border-color: rgba(102,252,241,0.70);
      transform: translateY(-1px);
    }
    .overviewLinkMeta{
      font-weight: 600;
      font-size: 12px;
      color: rgba(197,198,199,0.92);
    }
    .overviewNote{
      margin-top: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.16);
      color: rgba(197,198,199,0.92);
      font-size: 12px;
      line-height: 1.45;
    }

    @media (max-width: 820px){
      .overviewGrid{ grid-template-columns: 1fr; }
      .overviewCases{ grid-template-columns: 1fr; }
    }

</style>

    <!-- Assistant container and toggle -->
    <div id="assistantContainer" class="hide">
      <div id="assistantHeader">
        <!-- Add a chatbot icon to the header title to visually represent the assistant -->
        <span class="title">&#x1F916; Hydro‚ÄëDT Assistant</span>
        <button id="assistantClose" title="Close assistant">√ó</button>
      </div>
      <!-- Disclaimer informs users about the assistant's capabilities and limitations -->
      <div id="assistantDisclaimer" class="assistant-disclaimer">
        Mujib Digital Twin Assistant answers questions about the basin‚Äôs data layers, restoration interventions and hydrological concepts. It can also fetch general definitions from Wikipedia for unfamiliar terms.
        <br/>
        It does not draw or edit map features, nor does it provide policy decisions or replace expert judgment.
      </div>
      <div id="assistantMessages"></div>
      <div id="assistantChipsContainer">
        <button id="chipsLeft" class="chips-arrow">‚Äπ</button>
        <div id="assistantChips"></div>
        <button id="chipsRight" class="chips-arrow">‚Ä∫</button>
      </div>
      <div id="assistantInputArea">
        <input id="assistantInput" type="text" placeholder="Ask about NDVI, Marab, SWAT‚Ä¶"/>
        <button id="assistantSend">Send</button>
      </div>
    </div>
    <div id="assistantSuggestions"></div>
    <button id="assistantToggle" class="assistant-toggle" title="Open assistant">ü§ñ</button>

    <script>
      (function(){
        // ============================
        // Hydro-DT dictionary
        // ============================
        const hydroDictionary = {
          'ndvi': {
            definition: 'NDVI (Normalized Difference Vegetation Index) compares near‚Äëinfrared and red reflectance to assess vegetation greenness. Within a given dataset, higher values correspond to denser or healthier vegetation.',
            related: ['vegetation health','remote sensing','land degradation'],
            suggestions: ['What does an NDVI of 0.12 mean?','Show baseline NDVI','What is Œî NDVI?']
          },
          'baseline ndvi': {
            definition: 'The Baseline NDVI layer shows vegetation greenness for an earlier reference period in the Mujib Basin. It represents the starting vegetation condition against which current changes are measured.',
            related: ['reference period','vegetation baseline'],
            suggestions: ['Show baseline NDVI','How old is the baseline data?']
          },
          'recent ndvi': {
            definition: 'The Recent NDVI layer depicts the most up‚Äëto‚Äëdate vegetation greenness from the latest satellite imagery. Comparing it to the baseline reveals where vegetation has increased or decreased.',
            related: ['current vegetation','satellite imagery'],
            suggestions: ['Show recent NDVI','Compare baseline and recent NDVI']
          },
          'delta ndvi': {
            definition: 'The Œî NDVI layer highlights the change in vegetation greenness between the baseline and recent periods. Positive values (Œî &gt; +0.01) indicate vegetation increase, negative values (Œî &lt; ‚àí0.01) indicate vegetation decrease, and values near zero (|Œî| ‚â§ 0.01) represent little change.',
            related: ['vegetation change','difference map'],
            suggestions: ['Show Œî NDVI','Why are some areas red or blue?']
          },
          'vallerani': {
            definition: 'Vallerani micro-catchments are small rainwater harvesting pits dug along contour lines using a specialised plough. These pits capture runoff and increase soil moisture, enabling shrubs and grasses to establish on degraded slopes.',
            related: ['rainwater harvesting','micro-catchments','restoration'],
            suggestions: ['Show Vallerani sites','How does Vallerani work?','Why use Vallerani pits?']
          },
          'marab': {
            definition: 'A Marab is a large flood-spreading water harvesting system built on flat plains. It diverts and spreads wadi floodwater over a wide area using earth bunds and spillways, creating moist fields for crops like barley.',
            related: ['floodwater harvesting','macro-catchment','barley cultivation'],
            suggestions: ['Show Marab areas','What crops grow in Marabs?']
          },
          'soil moisture': {
            definition: 'The soil moisture indicator shows how much water is present in the upper soil layer. High soil moisture means wet soils after rainfall or water harvesting; low values indicate dry conditions and plant stress.',
            related: ['water availability','root zone','moisture layer'],
            suggestions: ['Show Soil Moisture layer','What is soil moisture?']
          },
          'evapotranspiration': {
            definition: 'Evapotranspiration (ET) is the sum of water evaporated from the soil and transpired by plants. High ET areas indicate vigorous vegetation and high water use, while low ET areas reflect sparse vegetation or dry soils.',
            related: ['water cycle','actual evapotranspiration','AET'],
            suggestions: ['Show ET layer','What is evapotranspiration?']
          },
          'swat model': {
            definition: 'The SWAT (Soil and Water Assessment Tool) model simulates rainfall-runoff and erosion processes in the watershed. In the Mujib Basin, SWAT outputs include runoff and sediment yield maps that reveal where water flow and soil erosion are highest.',
            related: ['runoff','sediment yield','hydrological modelling'],
            suggestions: ['Show Runoff layer','Show Sediment Yield layer','What is SWAT?']
          },
          'ecological restoration indicators': {
            definition: 'Ecological restoration indicators track improvements in ecosystem health after interventions. A primary indicator is vegetation recovery: increasing NDVI values at treated sites signal successful restoration.',
            related: ['vegetation recovery','restoration monitoring'],
            suggestions: ['Highlight restoration areas','How to interpret NDVI increase?']
          },
          'overgrazing': {
            definition: 'Overgrazing occurs when too many livestock feed on a rangeland area, stripping away vegetation and exposing soil. In the Mujib Basin, overgrazing accelerates erosion and reduces rainwater infiltration.',
            related: ['rangeland degradation','soil erosion'],
            suggestions: ['Effects of overgrazing','How to prevent overgrazing?']
          },
          'soil crusting': {
            definition: 'Soil crusting is the formation of a hard, compact layer on the soil surface, often in arid regions when raindrops hit bare soil. Crusted soil reduces infiltration and hinders seedling emergence.',
            related: ['surface sealing','infiltration','soil degradation'],
            suggestions: ['Why does soil crust?','How to break soil crust?']
          },
          'wadi': {
            definition: 'A wadi is a dry riverbed or seasonal stream channel that carries water only during rainfall events. The Mujib Basin has a network of wadis that convey floodwater through the landscape.',
            related: ['seasonal rivers','ephemeral streams'],
            suggestions: ['Show Wadi network','What is a wadi?']
          },
          'dam': {
            definition: 'A dam is a barrier built across a river or wadi to store water and create a reservoir. The main dam in the Mujib Basin captures seasonal runoff and provides water storage for cities and irrigation.',
            related: ['reservoir','water storage'],
            suggestions: ['Show dams layer','How much water does Mujib Dam hold?']
          },
          'hafir': {
            definition: 'A hafir is a man-made rainwater harvesting pond excavated to collect runoff during rains. These small reservoirs store water for livestock and recharge groundwater in the dry Badia.',
            related: ['rainwater harvesting','ponds','water storage'],
            suggestions: ['Show Ponds layer','What is a hafir?']
          },
          'groundwater well': {
            definition: 'A groundwater well is a borehole drilled into the ground to pump water from an aquifer. Wells provide drinking water and irrigation but over-extraction can lower groundwater levels.',
            related: ['aquifer','water supply'],
            suggestions: ['Show wells layer','Why manage groundwater?']
          },
          'rainwater harvesting': {
            definition: 'Rainwater harvesting encompasses techniques that capture and use rainwater locally rather than letting it run off. In the Mujib Basin, practices include Vallerani pits, Marab flood-spreading systems, hafir ponds and terraces.',
            related: ['water harvesting','water conservation','RWH'],
            suggestions: ['Show Rainwater Harvesting sites','Why harvest rainwater?']
          }
        };
        // Map synonyms and alternate terms to canonical dictionary keys
        const aliasMap = {
          'normalized difference vegetation index':'ndvi',
          'vegetation index':'ndvi',
          'baseline':'baseline ndvi',
          'initial ndvi':'baseline ndvi',
          'reference ndvi':'baseline ndvi',
          'recent':'recent ndvi',
          'current ndvi':'recent ndvi',
          'delta':'delta ndvi',
          'ndvi change':'delta ndvi',
          'vegetation change':'delta ndvi',
          'vallerani micro-catchments':'vallerani',
          'vallerani pits':'vallerani',
          'vallerani water harvesting':'vallerani',
          'marab system':'marab',
          'marab fields':'marab',
          'soil moisture map':'soil moisture',
          'wetness index':'soil moisture',
          'et':'evapotranspiration',
          'aet':'evapotranspiration',
          'actual et':'evapotranspiration',
          'swat':'swat model',
          'runoff map':'swat model',
          'sediment yield map':'swat model',
          'restoration indicators':'ecological restoration indicators',
          'vegetation recovery':'ecological restoration indicators',
          'wadi network':'wadi',
          'wadi channel':'wadi',
          'dam reservoir':'dam',
          'reservoir':'dam',
          'pond':'hafir',
          'hafir pond':'hafir',
          'well':'groundwater well',
          'borehole':'groundwater well',
          'rainwater harvesting techniques':'rainwater harvesting',
          'rwh':'rainwater harvesting'
        };
        // Default quick chips shown when the assistant opens or after replies
        const defaultChips = [
          { label: 'Show Baseline NDVI', command: 'show baseline ndvi' },
          { label: 'Show Recent NDVI', command: 'show recent ndvi' },
          { label: 'Show Œî NDVI', command: 'show delta ndvi' },
          { label: 'Turn off NDVI', command: 'turn off ndvi' },
          { label: 'What is NDVI?', command: 'what is ndvi' },
          { label: 'What is Vallerani?', command: 'vallerani' },
          { label: 'What is Marab?', command: 'marab' },
          { label: 'Show SWAT Runoff', command: 'show runoff layer' }
        ];

        // Add a message to the chat area
        function addMessage(sender, text){
          const messagesEl = document.getElementById('assistantMessages');
          if(!messagesEl) return;
          const div = document.createElement('div');
          div.className = 'assistant-message ' + (sender === 'user' ? 'user' : 'bot');
          div.textContent = text;
          messagesEl.appendChild(div);
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        // Update horizontal chips and arrow states
        function updateChips(chips){
          const chipsEl = document.getElementById('assistantChips');
          const leftBtn = document.getElementById('chipsLeft');
          const rightBtn = document.getElementById('chipsRight');
          if(!chipsEl || !leftBtn || !rightBtn) return;
          chipsEl.innerHTML = '';
          chips.forEach(item => {
            const chip = document.createElement('div');
            chip.className = 'assistant-chip';
            chip.textContent = item.label;
            chip.addEventListener('click', () => {
              addMessage('user', item.label);
              processInput(item.command || item.label);
            });
            chipsEl.appendChild(chip);
          });
          // Reset scroll to start
          chipsEl.scrollLeft = 0;
          // Update arrow disabled state
          updateArrows();
        }
        function updateArrows(){
          const chipsEl = document.getElementById('assistantChips');
          const leftBtn = document.getElementById('chipsLeft');
          const rightBtn = document.getElementById('chipsRight');
          if(!chipsEl || !leftBtn || !rightBtn) return;
          const maxScroll = chipsEl.scrollWidth - chipsEl.clientWidth;
          leftBtn.disabled = chipsEl.scrollLeft <= 0;
          rightBtn.disabled = chipsEl.scrollLeft >= maxScroll - 2;
        }
        // Scroll chips left or right
        function scrollChips(dir){
          const chipsEl = document.getElementById('assistantChips');
          if(!chipsEl) return;
          const amount = 140;
          chipsEl.scrollLeft += dir * amount;
          setTimeout(updateArrows, 200);
        }
        // Update predictive suggestions based on input
        function updateSuggestions(val){
          const suggEl = document.getElementById('assistantSuggestions');
          const inputVal = String(val || '').trim().toLowerCase();
          if(!suggEl) return;
          if(!inputVal){
            suggEl.style.display = 'none';
            suggEl.innerHTML = '';
            return;
          }
          const results = [];
          // find dictionary keys starting with input
          Object.keys(hydroDictionary).forEach(k => {
            if(k.startsWith(inputVal)) results.push(k);
          });
          // alias keys
          Object.keys(aliasMap).forEach(k => {
            if(k.startsWith(inputVal)) results.push(aliasMap[k]);
          });
          // de-duplicate and limit
          const uniq = [...new Set(results)].slice(0, 5);
          if(!uniq.length){
            suggEl.style.display = 'none';
            suggEl.innerHTML = '';
            return;
          }
          suggEl.innerHTML = '';
          uniq.forEach(term => {
            const div = document.createElement('div');
            div.className = 'suggestion-item';
            div.textContent = term;
            div.addEventListener('click', () => {
              const inputEl = document.getElementById('assistantInput');
              if(inputEl){
                inputEl.value = term;
              }
              suggEl.innerHTML = '';
              suggEl.style.display = 'none';
              processInput(term);
            });
            suggEl.appendChild(div);
          });
          suggEl.style.display = 'block';
        }
        // Get dictionary response for a given text; returns null if not found
        function getDictionaryResponse(text){
          const t = String(text || '').trim().toLowerCase();
          if(!t) return null;
          // If exact match in dictionary
          if(hydroDictionary[t]){
            const entry = hydroDictionary[t];
            let resp = entry.definition;
            if(entry.related && entry.related.length){
              resp += ' Related: ' + entry.related.join(', ') + '.';
            }
            if(entry.suggestions && entry.suggestions.length){
              resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
            }
            return resp;
          }
          // If alias mapping
          if(aliasMap[t] && hydroDictionary[aliasMap[t]]){
            const entry = hydroDictionary[aliasMap[t]];
            let resp = entry.definition;
            if(entry.related && entry.related.length){
              resp += ' Related: ' + entry.related.join(', ') + '.';
            }
            if(entry.suggestions && entry.suggestions.length){
              resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
            }
            return resp;
          }
          // Patterns like "what is ...", "define ...", "explain ..."
          const patterns = ['what is','define','explain','what does'];
          for(const p of patterns){
            if(t.startsWith(p + ' ')){
              const term = t.slice(p.length + 1).trim();
              const key = aliasMap[term] || term;
              if(hydroDictionary[key]){
                const entry = hydroDictionary[key];
                let resp = entry.definition;
                if(entry.related && entry.related.length){
                  resp += ' Related: ' + entry.related.join(', ') + '.';
                }
                if(entry.suggestions && entry.suggestions.length){
                  resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
                }
                return resp;
              }
            }
          }
          // If text ends with dictionary term
          const words = t.split(' ');
          const last = words[words.length - 1];
          if(hydroDictionary[last]){
            const entry = hydroDictionary[last];
            let resp = entry.definition;
            if(entry.related && entry.related.length){
              resp += ' Related: ' + entry.related.join(', ') + '.';
            }
            if(entry.suggestions && entry.suggestions.length){
              resp += ' Suggestions: ' + entry.suggestions.join(', ') + '.';
            }
            return resp;
          }
          return null;
        }
        // Explain NDVI numeric values
        function explainNdviValue(val){
          const v = Number(val);
          if(isNaN(v)) return null;
          // Interpret NDVI values using classes tuned to the Mujib basin datasets (range ~0.04‚Äì0.27).
          if(v < 0.04) return 'NDVI values below 0.04 typically indicate water, shadow or non‚Äëvegetated surfaces.';
          if(v < 0.06) return 'An NDVI of ' + v.toFixed(2) + ' suggests very sparse vegetation or bare soil.';
          if(v < 0.08) return 'An NDVI of ' + v.toFixed(2) + ' indicates low vegetation cover.';
          if(v < 0.10) return 'An NDVI of ' + v.toFixed(2) + ' indicates sparse vegetation cover.';
          if(v < 0.13) return 'An NDVI of ' + v.toFixed(2) + ' represents moderate vegetation cover.';
          return 'An NDVI of ' + v.toFixed(2) + ' indicates relatively high vegetation cover for this region.';
        }
        // Wikipedia API calls with caching
        const __wikiCache = new Map();
        async function fetchWikiSummary(title){
          const key = String(title || '').trim();
          if(!key) return null;
          if(__wikiCache.has(key)) return __wikiCache.get(key);
          const url = 'https://en.wikipedia.org/api/rest_v1/page/summary/' + encodeURIComponent(key);
          try{
            const resp = await fetch(url, { mode:'cors' });
            if(!resp.ok) throw new Error('wiki summary failed');
            const data = await resp.json();
            const out = {
              title: data.title || key,
              extract: data.extract || '',
              page: (data.content_urls && data.content_urls.desktop && data.content_urls.desktop.page) ? data.content_urls.desktop.page : ''
            };
            __wikiCache.set(key, out);
            return out;
          }catch(e){
            __wikiCache.set(key, null);
            return null;
          }
        }
        async function wikiOpenSearch(query){
          const q = String(query || '').trim();
          if(!q) return null;
          const langs = ['en','de','nl'];
          for(const lang of langs){
            const url = `https://${lang}.wikipedia.org/w/api.php?action=opensearch&search=${encodeURIComponent(q)}&limit=1&namespace=0&format=json&origin=*`;
            try{
              const resp = await fetch(url);
              const data = await resp.json();
              const title = (data && data[1] && data[1][0]) ? data[1][0] : null;
              if(title) return title;
            }catch(e){
              // continue to next language
            }
          }
          return null;
        }
        // Process user input and respond
        async function processInput(input){
          const raw = String(input || '').trim();
          const text = raw.toLowerCase();
          if(!text) return;
          // Commands to toggle NDVI layers
          if(text.includes('show') && text.includes('baseline') && text.includes('ndvi')){
            try{
              setNdviMode('baseline', true);
            }catch(e){}
            addMessage('bot','Baseline NDVI layer enabled.');
            updateChips(defaultChips);
            return;
          }
          if(text.includes('show') && text.includes('recent') && text.includes('ndvi')){
            try{
              setNdviMode('recent', true);
            }catch(e){}
            addMessage('bot','Recent NDVI layer enabled.');
            updateChips(defaultChips);
            return;
          }
          if(text.includes('show') && (text.includes('delta') || text.includes('change')) && text.includes('ndvi')){
            try{
              setNdviMode('delta', true);
            }catch(e){}
            addMessage('bot','Œî NDVI layer enabled.');
            updateChips(defaultChips);
            return;
          }
          if((text.includes('turn off') || text.includes('off') || text.includes('disable')) && text.includes('ndvi')){
            // Turn off whatever NDVI mode is active
            try{
              if(window.ndviUI && ndviUI.activeMode){
                setNdviMode(ndviUI.activeMode, false);
              } else {
                const b = document.getElementById('ndviBaselineChk');
                const r = document.getElementById('ndviRecentChk');
                const d = document.getElementById('ndviDeltaChk');
                if(b) b.checked = false;
                if(r) r.checked = false;
                if(d) d.checked = false;
                if(typeof updateNdviOverlay === 'function') updateNdviOverlay();
              }
            }catch(e){}
            addMessage('bot','NDVI layers disabled.');
            updateChips(defaultChips);
            return;
          }
          // NDVI numeric meaning queries (e.g. "ndvi 0.12")
          if(text.includes('ndvi')){
            const m = text.match(/-?\d*\.?\d+/);
            if(m){
              const explanation = explainNdviValue(m[0]);
              if(explanation){
                addMessage('bot', explanation);
                updateChips(defaultChips);
                return;
              }
            }
          }
          // Dictionary definitions
          const dictResp = getDictionaryResponse(text);
          if(dictResp){
            addMessage('bot', dictResp);
            updateChips(defaultChips);
            return;
          }
          // Explicit Wikipedia search
          if(text.startsWith('search wikipedia:')){
            const query = raw.slice('search wikipedia:'.length).trim();
            if(!query){
              addMessage('bot','Please specify what to search on Wikipedia.');
              updateChips(defaultChips);
              return;
            }
            addMessage('bot','Searching Wikipedia for "' + query + '"‚Ä¶');
            try{
              const title = await wikiOpenSearch(query);
              if(!title){
                addMessage('bot','I couldn\'t find a relevant Wikipedia page.');
                updateChips(defaultChips);
                return;
              }
              const data = await fetchWikiSummary(title);
              if(!data || !data.extract){
                addMessage('bot','No summary available for "' + title + '".');
                updateChips(defaultChips);
                return;
              }
              const excerpt = data.extract.length > 520 ? (data.extract.slice(0,520) + '‚Ä¶') : data.extract;
              addMessage('bot', `Wikipedia (${data.title}): ${excerpt}${data.page ? '\n' + data.page : ''}`);
            }catch(err){
              addMessage('bot','Sorry, I couldn\'t fetch information from Wikipedia.');
            }
            updateChips(defaultChips);
            return;
          }
          // Greetings and farewells
          if(/\b(hi|hello|hey|hallo|hola)\b/.test(text)){
            addMessage('bot','Hello! Ask me about NDVI, rainwater harvesting, SWAT, or other hydro topics.');
            updateChips(defaultChips);
            return;
          }
          if(/\b(bye|goodbye|see you|tot ziens|auf wiedersehen)\b/.test(text)){
            addMessage('bot','Goodbye! Feel free to return with more questions.');
            updateChips(defaultChips);
            return;
          }
          // Final fallback: attempt Wikipedia lookup for the entire query
          addMessage('bot','Let me check Wikipedia‚Ä¶');
          try{
            const title = await wikiOpenSearch(raw);
            if(!title){
              addMessage('bot','Sorry, I couldn\'t find anything relevant.');
              updateChips(defaultChips);
              return;
            }
            const s = await fetchWikiSummary(title);
            if(!s || !s.extract){
              addMessage('bot',`I found "${title}", but there was no summary available.`);
              updateChips(defaultChips);
              return;
            }
            const excerpt = s.extract.length > 520 ? (s.extract.slice(0,520) + '‚Ä¶') : s.extract;
            addMessage('bot', `Wikipedia (${s.title}): ${excerpt}${s.page ? '\n' + s.page : ''}`);
          }catch(err){
            addMessage('bot','Sorry, I couldn\'t fetch an answer.');
          }
          updateChips(defaultChips);
        }
        // Event bindings after DOM load
        document.addEventListener('DOMContentLoaded', () => {
          const toggleBtn = document.getElementById('assistantToggle');
          const container = document.getElementById('assistantContainer');
          const closeBtn = document.getElementById('assistantClose');
          const sendBtn = document.getElementById('assistantSend');
          const inputEl = document.getElementById('assistantInput');
          const messagesEl = document.getElementById('assistantMessages');
          const chipsEl = document.getElementById('assistantChips');
          const suggEl = document.getElementById('assistantSuggestions');
          const leftBtn = document.getElementById('chipsLeft');
          const rightBtn = document.getElementById('chipsRight');

          // Prevent Cesium from capturing mouse-wheel / trackpad scroll when interacting with the assistant.
          // Without this, the globe zooms instead of the chat area scrolling.
          const stopWheelPropagation = (e) => {
            e.stopPropagation();
          };
          [container, messagesEl, chipsEl, inputEl].forEach(el => {
            if(!el) return;
            el.addEventListener('wheel', stopWheelPropagation, { passive: true, capture: true });
          });
          // Toggle open/close
          if(toggleBtn && container){
            toggleBtn.addEventListener('click', () => {
              container.classList.toggle('hide');
              // hide suggestions when toggling
              if(suggEl){
                suggEl.innerHTML = '';
                suggEl.style.display = 'none';
              }
            });
          }
          // Close button
          if(closeBtn && container){
            closeBtn.addEventListener('click', () => {
              container.classList.add('hide');
              if(suggEl){
                suggEl.innerHTML = '';
                suggEl.style.display = 'none';
              }
            });
          }
          // Send button
          if(sendBtn && inputEl){
            sendBtn.addEventListener('click', () => {
              const val = inputEl.value;
              if(val){
                addMessage('user', val);
                processInput(val);
                inputEl.value = '';
              }
            });
            inputEl.addEventListener('keypress', (e) => {
              if(e.key === 'Enter'){
                const val = inputEl.value;
                if(val){
                  addMessage('user', val);
                  processInput(val);
                  inputEl.value = '';
                }
              }
            });
            inputEl.addEventListener('input', () => {
              updateSuggestions(inputEl.value);
            });
          }
          // Chips scrolling
          if(leftBtn){
            leftBtn.addEventListener('click', () => {
              scrollChips(-1);
            });
          }
          if(rightBtn){
            rightBtn.addEventListener('click', () => {
              scrollChips(1);
            });
          }
          // Reset suggestions when clicking outside suggestions area
          document.addEventListener('click', (e) => {
            if(!suggEl || !inputEl) return;
            if(e.target !== inputEl && !suggEl.contains(e.target)){
              suggEl.style.display = 'none';
              suggEl.innerHTML = '';
            }
          });
          // Initialize default chips
          updateChips(defaultChips);
        });
      })();
    </script>
</body>
</html>
